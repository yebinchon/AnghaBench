#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  lua_State ;
typedef  int /*<<< orphan*/  Proto ;

/* Variables and functions */
 int FS_OBJ_NAME_LEN ; 
 int LUA_ERR_CC_INTOVERFLOW ; 
 int LUA_ERR_CC_NOTINTEGER ; 
 int /*<<< orphan*/  FUNC0 (char*) ; 
 scalar_t__ VFS_RES_OK ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ *,int,int,char*) ; 
 char* FUNC2 (int /*<<< orphan*/ *,int,size_t*) ; 
 int FUNC3 (int /*<<< orphan*/ *,char*) ; 
 scalar_t__ FUNC4 (int /*<<< orphan*/ *,char const*) ; 
 int /*<<< orphan*/  FUNC5 (int /*<<< orphan*/ *,char*) ; 
 char* FUNC6 (int /*<<< orphan*/ *,size_t) ; 
 int FUNC7 (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int*,int) ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ *) ; 
 char* FUNC9 (int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  FUNC10 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC11 (char*,char*) ; 
 int /*<<< orphan*/  FUNC12 (char*,char const*) ; 
 int FUNC13 (char const*) ; 
 int /*<<< orphan*/ * FUNC14 (int /*<<< orphan*/ *,int) ; 
 char* FUNC15 (char const*) ; 
 int /*<<< orphan*/  FUNC16 (int) ; 
 scalar_t__ FUNC17 (int) ; 
 int FUNC18 (char*,char*) ; 
 int /*<<< orphan*/  writer ; 

__attribute__((used)) static int FUNC19( lua_State* L )
{
  Proto* f;
  int file_fd = 0;
  size_t len;
  const char *fname = FUNC2( L, 1, &len );
  const char *basename = FUNC15( fname );
  FUNC1(L, FUNC13(basename) <= FS_OBJ_NAME_LEN && FUNC13(fname) == len, 1, "filename invalid");

  char *output = FUNC6( L, len+1 );
  FUNC12(output, fname);
  // check here that filename end with ".lua".
  if (len < 4 || (FUNC11( output + len - 4, ".lua") != 0) ) {
    FUNC5( L, output );
    return FUNC3(L, "not a .lua file");
  }

  output[FUNC13(output) - 2] = 'c';
  output[FUNC13(output) - 1] = '\0';
  FUNC0(output);
  FUNC0("\n");
  if (FUNC4(L, fname) != 0) {
    FUNC5( L, output );
    return FUNC3(L, FUNC9(L, -1));
  }

  f = FUNC14(L, -1);

  int stripping = 1;      /* strip debug information? */

  file_fd = FUNC18(output, "w+");
  if (!file_fd)
  {
    FUNC5( L, output );
    return FUNC3(L, "cannot open/write to file");
  }

  FUNC8(L);
  int result = FUNC7(L, f, writer, &file_fd, stripping);
  FUNC10(L);

  if (FUNC17(file_fd) != VFS_RES_OK) {
    // overwrite Lua error, like writer() does in case of a file io error
    result = 1;
  }
  FUNC16(file_fd);
  file_fd = 0;
  FUNC5( L, output );

  if (result == LUA_ERR_CC_INTOVERFLOW) {
    return FUNC3(L, "value too big or small for target integer type");
  }
  if (result == LUA_ERR_CC_NOTINTEGER) {
    return FUNC3(L, "target lua_Number is integral but fractional value found");
  }
  if (result == 1) {    // result status generated by writer() or fs_flush() fail
    return FUNC3(L, "writing to file failed");
  }

  return 0;
}