#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_9__   TYPE_2__ ;
typedef  struct TYPE_8__   TYPE_1__ ;

/* Type definitions */
struct TYPE_8__ {int img_x; int img_y; } ;
typedef  TYPE_1__ stbi__context ;
struct TYPE_9__ {int hsz; int mr; int mg; int mb; int ma; int bpp; scalar_t__ all_a; void* offset; } ;
typedef  TYPE_2__ stbi__bmp_data ;

/* Variables and functions */
 void* FUNC0 (char*,char*) ; 
 int FUNC1 (TYPE_1__*) ; 
 void* FUNC2 (TYPE_1__*) ; 
 char FUNC3 (TYPE_1__*) ; 

__attribute__((used)) static void *FUNC4(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (FUNC3(s) != 'B' || FUNC3(s) != 'M') return FUNC0("not BMP", "Corrupt BMP");
   FUNC2(s); // discard filesize
   FUNC1(s); // discard reserved
   FUNC1(s); // discard reserved
   info->offset = FUNC2(s);
   info->hsz = hsz = FUNC2(s);
   info->mr = info->mg = info->mb = info->ma = 0;

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return FUNC0("unknown BMP", "BMP type not supported: unknown");
   if (hsz == 12) {
      s->img_x = FUNC1(s);
      s->img_y = FUNC1(s);
   } else {
      s->img_x = FUNC2(s);
      s->img_y = FUNC2(s);
   }
   if (FUNC1(s) != 1) return FUNC0("bad BMP", "bad BMP");
   info->bpp = FUNC1(s);
   if (hsz != 12) {
      int compress = FUNC2(s);
      if (compress == 1 || compress == 2) return FUNC0("BMP RLE", "BMP type not supported: RLE");
      FUNC2(s); // discard sizeof
      FUNC2(s); // discard hres
      FUNC2(s); // discard vres
      FUNC2(s); // discard colorsused
      FUNC2(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            FUNC2(s);
            FUNC2(s);
            FUNC2(s);
            FUNC2(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               if (info->bpp == 32) {
                  info->mr = 0xffu << 16;
                  info->mg = 0xffu <<  8;
                  info->mb = 0xffu <<  0;
                  info->ma = 0xffu << 24;
                  info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
               } else {
                  info->mr = 31u << 10;
                  info->mg = 31u <<  5;
                  info->mb = 31u <<  0;
               }
            } else if (compress == 3) {
               info->mr = FUNC2(s);
               info->mg = FUNC2(s);
               info->mb = FUNC2(s);
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return FUNC0("bad BMP", "bad BMP");
               }
            } else
               return FUNC0("bad BMP", "bad BMP");
         }
      } else {
         int i;
         if (hsz != 108 && hsz != 124)
            return FUNC0("bad BMP", "bad BMP");
         info->mr = FUNC2(s);
         info->mg = FUNC2(s);
         info->mb = FUNC2(s);
         info->ma = FUNC2(s);
         FUNC2(s); // discard color space
         for (i=0; i < 12; ++i)
            FUNC2(s); // discard color space parameters
         if (hsz == 124) {
            FUNC2(s); // discard rendering intent
            FUNC2(s); // discard offset of profile data
            FUNC2(s); // discard size of profile data
            FUNC2(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}