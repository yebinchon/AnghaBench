#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  mpz_t ;
typedef  int /*<<< orphan*/  mpz_dig_t ;
typedef  int /*<<< orphan*/  mp_obj_t ;
struct TYPE_4__ {int /*<<< orphan*/  mpz; } ;
typedef  TYPE_1__ mp_obj_int_t ;
typedef  int /*<<< orphan*/  mp_int_t ;
typedef  int mp_float_t ;
typedef  int mp_binary_op_t ;

/* Variables and functions */
 int MPZ_NUM_DIG_FOR_INT ; 
#define  MP_BINARY_OP_ADD 154 
#define  MP_BINARY_OP_AND 153 
 int MP_BINARY_OP_CONTAINS ; 
 int MP_BINARY_OP_DIVMOD ; 
#define  MP_BINARY_OP_EQUAL 152 
#define  MP_BINARY_OP_FLOOR_DIVIDE 151 
#define  MP_BINARY_OP_INPLACE_ADD 150 
#define  MP_BINARY_OP_INPLACE_AND 149 
#define  MP_BINARY_OP_INPLACE_FLOOR_DIVIDE 148 
#define  MP_BINARY_OP_INPLACE_LSHIFT 147 
#define  MP_BINARY_OP_INPLACE_MODULO 146 
#define  MP_BINARY_OP_INPLACE_MULTIPLY 145 
#define  MP_BINARY_OP_INPLACE_OR 144 
#define  MP_BINARY_OP_INPLACE_POWER 143 
#define  MP_BINARY_OP_INPLACE_RSHIFT 142 
#define  MP_BINARY_OP_INPLACE_SUBTRACT 141 
 int MP_BINARY_OP_INPLACE_TRUE_DIVIDE ; 
#define  MP_BINARY_OP_INPLACE_XOR 140 
#define  MP_BINARY_OP_LESS 139 
#define  MP_BINARY_OP_LESS_EQUAL 138 
#define  MP_BINARY_OP_LSHIFT 137 
#define  MP_BINARY_OP_MODULO 136 
#define  MP_BINARY_OP_MORE 135 
#define  MP_BINARY_OP_MORE_EQUAL 134 
#define  MP_BINARY_OP_MULTIPLY 133 
#define  MP_BINARY_OP_OR 132 
#define  MP_BINARY_OP_POWER 131 
#define  MP_BINARY_OP_RSHIFT 130 
#define  MP_BINARY_OP_SUBTRACT 129 
 int MP_BINARY_OP_TRUE_DIVIDE ; 
#define  MP_BINARY_OP_XOR 128 
 int /*<<< orphan*/  FUNC0 (TYPE_1__*) ; 
 int /*<<< orphan*/  MP_OBJ_NULL ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC2 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC3 (int) ; 
 int /*<<< orphan*/  FUNC4 (int,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC5 (int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC6 (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC7 (int /*<<< orphan*/ ) ; 
 TYPE_1__* FUNC8 () ; 
 scalar_t__ FUNC9 (int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC10 (int /*<<< orphan*/ ) ; 
 int FUNC11 (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC12 (int) ; 
 int /*<<< orphan*/  FUNC13 (int) ; 
 int /*<<< orphan*/  FUNC14 (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC15 (char*) ; 
 int /*<<< orphan*/  FUNC16 (int /*<<< orphan*/ *,char*) ; 
 int /*<<< orphan*/  mp_type_ZeroDivisionError ; 
 int /*<<< orphan*/  mp_type_complex ; 
 int /*<<< orphan*/  mp_type_int ; 
 int /*<<< orphan*/  FUNC17 (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ; 
 int /*<<< orphan*/  FUNC18 (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ; 
 int FUNC19 (int /*<<< orphan*/  const*) ; 
 int FUNC20 (int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ; 
 int /*<<< orphan*/  FUNC21 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC22 (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ; 
 int /*<<< orphan*/  FUNC23 (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC24 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC25 (int /*<<< orphan*/  const*) ; 
 scalar_t__ FUNC26 (int /*<<< orphan*/  const*) ; 
 int /*<<< orphan*/  FUNC27 (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ; 
 int /*<<< orphan*/  FUNC28 (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ; 
 int /*<<< orphan*/  FUNC29 (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ; 
 int /*<<< orphan*/  FUNC30 (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC31 (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC32 (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ; 
 int /*<<< orphan*/  FUNC33 (int /*<<< orphan*/ *,int /*<<< orphan*/  const*,int /*<<< orphan*/  const*) ; 

mp_obj_t FUNC34(mp_binary_op_t op, mp_obj_t lhs_in, mp_obj_t rhs_in) {
    const mpz_t *zlhs;
    const mpz_t *zrhs;
    mpz_t z_int;
    mpz_dig_t z_int_dig[MPZ_NUM_DIG_FOR_INT];

    // lhs could be a small int (eg small-int + mpz)
    if (FUNC10(lhs_in)) {
        FUNC23(&z_int, z_int_dig, MPZ_NUM_DIG_FOR_INT, FUNC1(lhs_in));
        zlhs = &z_int;
    } else {
        FUNC3(FUNC11(lhs_in, &mp_type_int));
        zlhs = &((mp_obj_int_t*)FUNC2(lhs_in))->mpz;
    }

    // if rhs is small int, then lhs was not (otherwise mp_binary_op handles it)
    if (FUNC10(rhs_in)) {
        FUNC23(&z_int, z_int_dig, MPZ_NUM_DIG_FOR_INT, FUNC1(rhs_in));
        zrhs = &z_int;
    } else if (FUNC11(rhs_in, &mp_type_int)) {
        zrhs = &((mp_obj_int_t*)FUNC2(rhs_in))->mpz;
#if MICROPY_PY_BUILTINS_FLOAT
    } else if (mp_obj_is_float(rhs_in)) {
        return mp_obj_float_binary_op(op, mpz_as_float(zlhs), rhs_in);
#if MICROPY_PY_BUILTINS_COMPLEX
    } else if (mp_obj_is_type(rhs_in, &mp_type_complex)) {
        return mp_obj_complex_binary_op(op, mpz_as_float(zlhs), 0, rhs_in);
#endif
#endif
    } else {
        // delegate to generic function to check for extra cases
        return FUNC6(op, lhs_in, rhs_in);
    }

#if MICROPY_PY_BUILTINS_FLOAT
    if (op == MP_BINARY_OP_TRUE_DIVIDE || op == MP_BINARY_OP_INPLACE_TRUE_DIVIDE) {
        if (mpz_is_zero(zrhs)) {
            goto zero_division_error;
        }
        mp_float_t flhs = mpz_as_float(zlhs);
        mp_float_t frhs = mpz_as_float(zrhs);
        return mp_obj_new_float(flhs / frhs);
    } else
#endif

    if (op >= MP_BINARY_OP_INPLACE_OR && op < MP_BINARY_OP_CONTAINS) {
        mp_obj_int_t *res = FUNC8();

        switch (op) {
            case MP_BINARY_OP_ADD:
            case MP_BINARY_OP_INPLACE_ADD:
                FUNC17(&res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_SUBTRACT:
            case MP_BINARY_OP_INPLACE_SUBTRACT:
                FUNC32(&res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_MULTIPLY:
            case MP_BINARY_OP_INPLACE_MULTIPLY:
                FUNC27(&res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_FLOOR_DIVIDE:
            case MP_BINARY_OP_INPLACE_FLOOR_DIVIDE: {
                if (FUNC26(zrhs)) {
                    zero_division_error:
                    FUNC16(&mp_type_ZeroDivisionError, "divide by zero");
                }
                mpz_t rem; FUNC24(&rem);
                FUNC22(&res->mpz, &rem, zlhs, zrhs);
                FUNC21(&rem);
                break;
            }
            case MP_BINARY_OP_MODULO:
            case MP_BINARY_OP_INPLACE_MODULO: {
                if (FUNC26(zrhs)) {
                    goto zero_division_error;
                }
                mpz_t quo; FUNC24(&quo);
                FUNC22(&quo, &res->mpz, zlhs, zrhs);
                FUNC21(&quo);
                break;
            }

            case MP_BINARY_OP_AND:
            case MP_BINARY_OP_INPLACE_AND:
                FUNC18(&res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_OR:
            case MP_BINARY_OP_INPLACE_OR:
                FUNC28(&res->mpz, zlhs, zrhs);
                break;
            case MP_BINARY_OP_XOR:
            case MP_BINARY_OP_INPLACE_XOR:
                FUNC33(&res->mpz, zlhs, zrhs);
                break;

            case MP_BINARY_OP_LSHIFT:
            case MP_BINARY_OP_INPLACE_LSHIFT:
            case MP_BINARY_OP_RSHIFT:
            case MP_BINARY_OP_INPLACE_RSHIFT: {
                mp_int_t irhs = FUNC7(rhs_in);
                if (irhs < 0) {
                    FUNC15("negative shift count");
                }
                if (op == MP_BINARY_OP_LSHIFT || op == MP_BINARY_OP_INPLACE_LSHIFT) {
                    FUNC30(&res->mpz, zlhs, irhs);
                } else {
                    FUNC31(&res->mpz, zlhs, irhs);
                }
                break;
            }

            case MP_BINARY_OP_POWER:
            case MP_BINARY_OP_INPLACE_POWER:
                if (FUNC25(zrhs)) {
                    #if MICROPY_PY_BUILTINS_FLOAT
                    return mp_obj_float_binary_op(op, mpz_as_float(zlhs), rhs_in);
                    #else
                    FUNC15("negative power with no float support");
                    #endif
                }
                FUNC29(&res->mpz, zlhs, zrhs);
                break;

            default: {
                FUNC3(op == MP_BINARY_OP_DIVMOD);
                if (FUNC26(zrhs)) {
                    goto zero_division_error;
                }
                mp_obj_int_t *quo = FUNC8();
                FUNC22(&quo->mpz, &res->mpz, zlhs, zrhs);
                mp_obj_t tuple[2] = {FUNC0(quo), FUNC0(res)};
                return FUNC14(2, tuple);
            }
        }

        return FUNC0(res);

    } else {
        int cmp = FUNC20(zlhs, zrhs);
        switch (op) {
            case MP_BINARY_OP_LESS:
                return FUNC12(cmp < 0);
            case MP_BINARY_OP_MORE:
                return FUNC12(cmp > 0);
            case MP_BINARY_OP_LESS_EQUAL:
                return FUNC12(cmp <= 0);
            case MP_BINARY_OP_MORE_EQUAL:
                return FUNC12(cmp >= 0);
            case MP_BINARY_OP_EQUAL:
                return FUNC12(cmp == 0);

            default:
                return MP_OBJ_NULL; // op not supported
        }
    }
}