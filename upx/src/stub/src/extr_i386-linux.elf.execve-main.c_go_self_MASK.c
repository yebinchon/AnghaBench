#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int /*<<< orphan*/  FD_CLOEXEC ; 
 int /*<<< orphan*/  F_SETFD ; 
 int /*<<< orphan*/  MAP_PRIVATE ; 
 int O_CREAT ; 
 int O_EXCL ; 
 int O_RDONLY ; 
 int O_WRONLY ; 
 int PROT_READ ; 
 int PROT_WRITE ; 
 int R_OK ; 
 int /*<<< orphan*/  SEEK_END ; 
 int /*<<< orphan*/  FUNC0 (char* const,char,float,char,char) ; 
 unsigned int UPX2 ; 
 int X_OK ; 
 scalar_t__ FUNC1 (char*,int) ; 
 int /*<<< orphan*/  FUNC2 (int const) ; 
 int /*<<< orphan*/  FUNC3 (char*,char**,char**) ; 
 int /*<<< orphan*/  FUNC4 (int) ; 
 int /*<<< orphan*/  FUNC5 (int const,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int const FUNC6 () ; 
 unsigned int FUNC7 (int const,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 char* FUNC8 (char*,unsigned int const,int,int /*<<< orphan*/ ,int const,int /*<<< orphan*/ ) ; 
 int FUNC9 (char const*,int,int) ; 
 int /*<<< orphan*/  FUNC10 (char const*) ; 
 char* FUNC11 (int const,char* const) ; 
 scalar_t__ FUNC12 (int const,char* const,unsigned int const) ; 

__attribute__((used)) static int
#if (ACC_CC_GNUC >= 0x030300)
__attribute__((__noinline__, __used__, __stdcall__))
#endif
FUNC13(char const *tmpname, char *argv[], char *envp[])
{
    // Old FreeBSD does not have /proc/self, so use /proc/<pid> instead.

    // Open the temp file.
    int const fdi = FUNC9(tmpname, O_RDONLY, 0);

    if (0 <= fdi) {
        // 17 chars for "/proc/PPPPP/fd/XX" should be enough, but we
        // play safe in case there will be 32-bit pid_t at some time.
        //char procself_buf[17+1];
        char procself_buf[31+1];

        // Compute name of temp fdi.
        FUNC0(procself_buf + 0, '/', 'p', 'r', 'o');
        FUNC0(procself_buf + 4, 'c', '/',  0 ,  0 );
        {
            char *const procself = FUNC11(FUNC6(), procself_buf + 6);
            FUNC0(procself, '/', 'f', 'd', '/');
            FUNC11(fdi, procself + 4);
        }

        // Check for working /proc/self/fd/X by accessing the
        // temp file again, now via temp fdi.
        if (UPX2 == (unsigned) FUNC1(procself_buf, R_OK | X_OK)) {
            // Now it's safe to unlink the temp file (as it is still open).
            FUNC10(tmpname);
            // Set the file close-on-exec.
            FUNC5(fdi, F_SETFD, FD_CLOEXEC);
            // Execute the original program via /proc/self/fd/X.
            FUNC3(procself_buf, argv, envp);
            // NOTE: if we get here we've lost.

            // 2008-March: Ubuntu 7.10 linux-image-2.6.22-14.52-generic
            // and SuSE 10.3 have a patch to fs/dcache.c which causes
            // execve() [above] to fail with ENOENT.
            // Fedora kernel-2.6.22.14-72.fc6 omits the patch, and works:
// https://sourceforge.net/tracker/?func=detail&atid=102331&aid=1825006&group_id=2331

            // Now we must re-create the file; it was unlink()ed!
            // link(procself_buf, tmpname) gets EXDEV (cross-device link).
            // Luckily we still have an open fdi to the file.
            // Errors from {lseek, mmap, open, write} are all caught
            // by the one check on write().
            unsigned const lenf = FUNC7(fdi, 0, SEEK_END);
            char *const buf = FUNC8((char *)0, lenf, PROT_READ|PROT_WRITE,
                MAP_PRIVATE, fdi, 0);
            int const fdo = FUNC9(tmpname, O_WRONLY | O_CREAT | O_EXCL, 0700);
            if (lenf!=(unsigned)FUNC12(fdo, buf, lenf)) {
                FUNC4(127);
            }
            FUNC2(fdo);
        }

        // The proc filesystem isn't working. No problem.
        FUNC2(fdi);
    }
    return fdi;
}