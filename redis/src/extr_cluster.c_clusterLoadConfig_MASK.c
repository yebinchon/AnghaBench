#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_13__   TYPE_3__ ;
typedef  struct TYPE_12__   TYPE_2__ ;
typedef  struct TYPE_11__   TYPE_1__ ;

/* Type definitions */
struct stat {scalar_t__ st_size; } ;
typedef  char* sds ;
struct TYPE_12__ {void* port; int /*<<< orphan*/  name; void* configEpoch; void* pong_received; void* ping_sent; struct TYPE_12__* slaveof; int /*<<< orphan*/  flags; void* fail_time; void* cport; int /*<<< orphan*/  ip; } ;
typedef  TYPE_2__ clusterNode ;
struct TYPE_13__ {TYPE_1__* cluster; } ;
struct TYPE_11__ {scalar_t__ currentEpoch; TYPE_2__* myself; TYPE_2__** importing_slots_from; TYPE_2__** migrating_slots_to; void* lastVoteEpoch; } ;
typedef  int /*<<< orphan*/  FILE ;

/* Variables and functions */
 int /*<<< orphan*/  CLUSTER_NODE_FAIL ; 
 int /*<<< orphan*/  CLUSTER_NODE_HANDSHAKE ; 
 int /*<<< orphan*/  CLUSTER_NODE_MASTER ; 
 int /*<<< orphan*/  CLUSTER_NODE_MYSELF ; 
 int /*<<< orphan*/  CLUSTER_NODE_NOADDR ; 
 int /*<<< orphan*/  CLUSTER_NODE_NOFAILOVER ; 
 int /*<<< orphan*/  CLUSTER_NODE_PFAIL ; 
 int /*<<< orphan*/  CLUSTER_NODE_SLAVE ; 
 int CLUSTER_PORT_INCR ; 
 int CLUSTER_SLOTS ; 
 int C_ERR ; 
 int C_OK ; 
 scalar_t__ ENOENT ; 
 int /*<<< orphan*/  LL_NOTICE ; 
 int /*<<< orphan*/  LL_WARNING ; 
 void* FUNC0 (char*) ; 
 int /*<<< orphan*/  FUNC1 (TYPE_2__*) ; 
 int /*<<< orphan*/  FUNC2 (TYPE_2__*,int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC3 () ; 
 TYPE_2__* FUNC4 (char*) ; 
 int /*<<< orphan*/  FUNC5 (TYPE_2__*,TYPE_2__*) ; 
 TYPE_2__* FUNC6 (char*,int /*<<< orphan*/ ) ; 
 scalar_t__ errno ; 
 int /*<<< orphan*/  FUNC7 (int) ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * FUNC9 (char*,int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC10 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * FUNC11 (char*,char*) ; 
 int FUNC12 (int /*<<< orphan*/ ,struct stat*) ; 
 int /*<<< orphan*/  FUNC13 (int /*<<< orphan*/ ,char*,scalar_t__) ; 
 void* FUNC14 () ; 
 TYPE_2__* myself ; 
 int /*<<< orphan*/  FUNC15 (char**,int) ; 
 char** FUNC16 (char*,int*) ; 
 TYPE_3__ server ; 
 int /*<<< orphan*/  FUNC17 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC18 (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  FUNC19 (char*) ; 
 scalar_t__ FUNC20 (char*,char*) ; 
 char* FUNC21 (char*,char) ; 
 int /*<<< orphan*/  FUNC22 (scalar_t__) ; 
 scalar_t__ FUNC23 (char*) ; 
 char* FUNC24 (char*,char) ; 
 void* FUNC25 (char*,int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  FUNC26 (char*) ; 
 char* FUNC27 (int) ; 

int FUNC28(char *filename) {
    FILE *fp = FUNC11(filename,"r");
    struct stat sb;
    char *line;
    int maxline, j;

    if (fp == NULL) {
        if (errno == ENOENT) {
            return C_ERR;
        } else {
            FUNC18(LL_WARNING,
                "Loading the cluster node config from %s: %s",
                filename, FUNC22(errno));
            FUNC7(1);
        }
    }

    /* Check if the file is zero-length: if so return C_ERR to signal
     * we have to write the config. */
    if (FUNC12(FUNC10(fp),&sb) != -1 && sb.st_size == 0) {
        FUNC8(fp);
        return C_ERR;
    }

    /* Parse the file. Note that single lines of the cluster config file can
     * be really long as they include all the hash slots of the node.
     * This means in the worst possible case, half of the Redis slots will be
     * present in a single line, possibly in importing or migrating state, so
     * together with the node ID of the sender/receiver.
     *
     * To simplify we allocate 1024+CLUSTER_SLOTS*128 bytes per line. */
    maxline = 1024+CLUSTER_SLOTS*128;
    line = FUNC27(maxline);
    while(FUNC9(line,maxline,fp) != NULL) {
        int argc;
        sds *argv;
        clusterNode *n, *master;
        char *p, *s;

        /* Skip blank lines, they can be created either by users manually
         * editing nodes.conf or by the config writing process if stopped
         * before the truncate() call. */
        if (line[0] == '\n' || line[0] == '\0') continue;

        /* Split the line into arguments for processing. */
        argv = FUNC16(line,&argc);
        if (argv == NULL) goto fmterr;

        /* Handle the special "vars" line. Don't pretend it is the last
         * line even if it actually is when generated by Redis. */
        if (FUNC20(argv[0],"vars") == 0) {
            if (!(argc % 2)) goto fmterr;
            for (j = 1; j < argc; j += 2) {
                if (FUNC20(argv[j],"currentEpoch") == 0) {
                    server.cluster->currentEpoch =
                            FUNC25(argv[j+1],NULL,10);
                } else if (FUNC20(argv[j],"lastVoteEpoch") == 0) {
                    server.cluster->lastVoteEpoch =
                            FUNC25(argv[j+1],NULL,10);
                } else {
                    FUNC18(LL_WARNING,
                        "Skipping unknown cluster config variable '%s'",
                        argv[j]);
                }
            }
            FUNC15(argv,argc);
            continue;
        }

        /* Regular config lines have at least eight fields */
        if (argc < 8) goto fmterr;

        /* Create this node if it does not exist */
        n = FUNC4(argv[0]);
        if (!n) {
            n = FUNC6(argv[0],0);
            FUNC1(n);
        }
        /* Address and port */
        if ((p = FUNC24(argv[1],':')) == NULL) goto fmterr;
        *p = '\0';
        FUNC13(n->ip,argv[1],FUNC23(argv[1])+1);
        char *port = p+1;
        char *busp = FUNC21(port,'@');
        if (busp) {
            *busp = '\0';
            busp++;
        }
        n->port = FUNC0(port);
        /* In older versions of nodes.conf the "@busport" part is missing.
         * In this case we set it to the default offset of 10000 from the
         * base port. */
        n->cport = busp ? FUNC0(busp) : n->port + CLUSTER_PORT_INCR;

        /* Parse flags */
        p = s = argv[2];
        while(p) {
            p = FUNC21(s,',');
            if (p) *p = '\0';
            if (!FUNC20(s,"myself")) {
                FUNC17(server.cluster->myself == NULL);
                myself = server.cluster->myself = n;
                n->flags |= CLUSTER_NODE_MYSELF;
            } else if (!FUNC20(s,"master")) {
                n->flags |= CLUSTER_NODE_MASTER;
            } else if (!FUNC20(s,"slave")) {
                n->flags |= CLUSTER_NODE_SLAVE;
            } else if (!FUNC20(s,"fail?")) {
                n->flags |= CLUSTER_NODE_PFAIL;
            } else if (!FUNC20(s,"fail")) {
                n->flags |= CLUSTER_NODE_FAIL;
                n->fail_time = FUNC14();
            } else if (!FUNC20(s,"handshake")) {
                n->flags |= CLUSTER_NODE_HANDSHAKE;
            } else if (!FUNC20(s,"noaddr")) {
                n->flags |= CLUSTER_NODE_NOADDR;
            } else if (!FUNC20(s,"nofailover")) {
                n->flags |= CLUSTER_NODE_NOFAILOVER;
            } else if (!FUNC20(s,"noflags")) {
                /* nothing to do */
            } else {
                FUNC19("Unknown flag in redis cluster config file");
            }
            if (p) s = p+1;
        }

        /* Get master if any. Set the master and populate master's
         * slave list. */
        if (argv[3][0] != '-') {
            master = FUNC4(argv[3]);
            if (!master) {
                master = FUNC6(argv[3],0);
                FUNC1(master);
            }
            n->slaveof = master;
            FUNC5(master,n);
        }

        /* Set ping sent / pong received timestamps */
        if (FUNC0(argv[4])) n->ping_sent = FUNC14();
        if (FUNC0(argv[5])) n->pong_received = FUNC14();

        /* Set configEpoch for this node. */
        n->configEpoch = FUNC25(argv[6],NULL,10);

        /* Populate hash slots served by this instance. */
        for (j = 8; j < argc; j++) {
            int start, stop;

            if (argv[j][0] == '[') {
                /* Here we handle migrating / importing slots */
                int slot;
                char direction;
                clusterNode *cn;

                p = FUNC21(argv[j],'-');
                FUNC17(p != NULL);
                *p = '\0';
                direction = p[1]; /* Either '>' or '<' */
                slot = FUNC0(argv[j]+1);
                if (slot < 0 || slot >= CLUSTER_SLOTS) goto fmterr;
                p += 3;
                cn = FUNC4(p);
                if (!cn) {
                    cn = FUNC6(p,0);
                    FUNC1(cn);
                }
                if (direction == '>') {
                    server.cluster->migrating_slots_to[slot] = cn;
                } else {
                    server.cluster->importing_slots_from[slot] = cn;
                }
                continue;
            } else if ((p = FUNC21(argv[j],'-')) != NULL) {
                *p = '\0';
                start = FUNC0(argv[j]);
                stop = FUNC0(p+1);
            } else {
                start = stop = FUNC0(argv[j]);
            }
            if (start < 0 || start >= CLUSTER_SLOTS) goto fmterr;
            if (stop < 0 || stop >= CLUSTER_SLOTS) goto fmterr;
            while(start <= stop) FUNC2(n, start++);
        }

        FUNC15(argv,argc);
    }
    /* Config sanity check */
    if (server.cluster->myself == NULL) goto fmterr;

    FUNC26(line);
    FUNC8(fp);

    FUNC18(LL_NOTICE,"Node configuration loaded, I'm %.40s", myself->name);

    /* Something that should never happen: currentEpoch smaller than
     * the max epoch found in the nodes configuration. However we handle this
     * as some form of protection against manual editing of critical files. */
    if (FUNC3() > server.cluster->currentEpoch) {
        server.cluster->currentEpoch = FUNC3();
    }
    return C_OK;

fmterr:
    FUNC18(LL_WARNING,
        "Unrecoverable error: corrupted cluster config file.");
    FUNC26(line);
    if (fp) FUNC8(fp);
    FUNC7(1);
}