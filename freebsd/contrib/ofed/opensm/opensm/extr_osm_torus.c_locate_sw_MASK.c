#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct torus {int flags; TYPE_1__* osm; scalar_t__ debug; int /*<<< orphan*/  z_sz; int /*<<< orphan*/  y_sz; int /*<<< orphan*/  x_sz; } ;
struct TYPE_2__ {int /*<<< orphan*/  log; } ;

/* Variables and functions */
 int /*<<< orphan*/  FUNC0 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,char*,unsigned int,int,int,int) ; 
 int /*<<< orphan*/  OSM_LOG_ERROR ; 
 int X_MESH ; 
 int Y_MESH ; 
 int Z_MESH ; 
 int FUNC1 (int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC2 (struct torus*,int,int,int) ; 
 unsigned int FUNC3 (struct torus*,int,int,int) ; 
 int FUNC4 (struct torus*,int,int,int) ; 
 int FUNC5 (struct torus*,int,int,int) ; 
 int FUNC6 (struct torus*,int,int,int) ; 
 int FUNC7 (struct torus*,int,int,int) ; 
 int FUNC8 (struct torus*,int,int,int) ; 
 int FUNC9 (struct torus*,int,int,int) ; 
 int FUNC10 (struct torus*,int,int,int) ; 
 int FUNC11 (struct torus*,int,int,int) ; 
 int FUNC12 (struct torus*,int,int,int) ; 
 int FUNC13 (struct torus*,int,int,int) ; 
 int FUNC14 (struct torus*,int,int,int) ; 
 int FUNC15 (struct torus*,int,int,int) ; 
 int FUNC16 (struct torus*,int,int,int) ; 
 int FUNC17 (struct torus*,int,int,int) ; 
 int FUNC18 (struct torus*,int,int,int) ; 
 int FUNC19 (struct torus*,int,int,int) ; 
 int FUNC20 (struct torus*,int,int,int) ; 
 int FUNC21 (struct torus*,int,int,int) ; 
 int FUNC22 (struct torus*,int,int,int) ; 
 int FUNC23 (struct torus*,int,int,int) ; 
 int FUNC24 (struct torus*,int,int,int) ; 
 int FUNC25 (struct torus*,int,int,int) ; 
 int FUNC26 (struct torus*,int,int,int) ; 
 int FUNC27 (struct torus*,int,int,int) ; 
 int FUNC28 (struct torus*,int,int,int) ; 
 int FUNC29 (struct torus*,int,int,int) ; 
 int FUNC30 (struct torus*,int,int,int) ; 
 int FUNC31 (struct torus*,int,int,int) ; 
 int FUNC32 (struct torus*,int,int,int) ; 
 int FUNC33 (struct torus*,int,int,int) ; 
 int FUNC34 (struct torus*,int,int,int) ; 
 int FUNC35 (struct torus*,int,int,int) ; 
 int FUNC36 (struct torus*,int,int,int) ; 
 int FUNC37 (struct torus*,int,int,int) ; 
 int FUNC38 (struct torus*,int,int,int) ; 
 int FUNC39 (struct torus*,int,int,int) ; 
 int FUNC40 (struct torus*,int,int,int) ; 
 int FUNC41 (struct torus*,int,int,int) ; 
 int FUNC42 (struct torus*,int,int,int) ; 
 int FUNC43 (struct torus*,int,int,int) ; 
 int FUNC44 (struct torus*,int,int,int) ; 
 int FUNC45 (struct torus*,int,int,int) ; 
 int FUNC46 (struct torus*,int,int,int) ; 
 int FUNC47 (struct torus*,int,int,int) ; 
 int FUNC48 (struct torus*,int,int,int) ; 
 int FUNC49 (struct torus*,int,int,int) ; 
 int FUNC50 (struct torus*,int,int,int) ; 
 int FUNC51 (struct torus*,int,int,int) ; 
 int FUNC52 (struct torus*,int,int,int) ; 
 int FUNC53 (struct torus*,int,int,int) ; 
 int FUNC54 (struct torus*,int,int,int) ; 
 int FUNC55 (struct torus*,int,int,int) ; 
 int FUNC56 (struct torus*,int,int,int) ; 
 int FUNC57 (struct torus*,int,int,int) ; 
 int FUNC58 (struct torus*,int,int,int) ; 
 int FUNC59 (struct torus*,int,int,int) ; 
 int FUNC60 (struct torus*,int,int,int) ; 
 int FUNC61 (struct torus*,int,int,int) ; 
 int FUNC62 (struct torus*,int,int,int) ; 
 int FUNC63 (struct torus*,int,int,int) ; 
 int FUNC64 (struct torus*,int,int,int) ; 
 int FUNC65 (struct torus*,int,int,int) ; 
 int FUNC66 (struct torus*,int,int,int) ; 
 int FUNC67 (struct torus*,int,int,int) ; 
 int FUNC68 (struct torus*,int,int,int) ; 
 int FUNC69 (struct torus*,int,int,int) ; 
 int FUNC70 (struct torus*,int,int,int) ; 
 int FUNC71 (struct torus*,int,int,int) ; 
 int FUNC72 (struct torus*,int,int,int) ; 
 int FUNC73 (struct torus*,int,int,int) ; 
 int FUNC74 (struct torus*,int,int,int) ; 
 int FUNC75 (struct torus*,int,int,int) ; 
 int FUNC76 (struct torus*,int,int,int) ; 
 int FUNC77 (struct torus*,int,int,int) ; 
 int FUNC78 (struct torus*,int,int,int) ; 
 int FUNC79 (struct torus*,int,int,int) ; 
 int FUNC80 (struct torus*,int,int,int) ; 
 int FUNC81 (struct torus*,int,int,int) ; 
 int FUNC82 (struct torus*,int,int,int) ; 
 int FUNC83 (struct torus*,int,int,int) ; 
 int FUNC84 (struct torus*,int,int,int) ; 
 int FUNC85 (struct torus*,int,int,int) ; 
 int FUNC86 (struct torus*,int,int,int) ; 
 int FUNC87 (struct torus*,int,int,int) ; 
 int FUNC88 (struct torus*,int,int,int) ; 
 int FUNC89 (struct torus*,int,int,int) ; 
 int FUNC90 (struct torus*,int,int,int) ; 
 int FUNC91 (struct torus*,int,int,int) ; 
 int FUNC92 (struct torus*,int,int,int) ; 
 int FUNC93 (struct torus*,int,int,int) ; 
 int FUNC94 (struct torus*,int,int,int) ; 
 int FUNC95 (struct torus*,int,int,int) ; 
 int FUNC96 (struct torus*,int,int,int) ; 
 int FUNC97 (struct torus*,int,int,int) ; 
 int FUNC98 (struct torus*,int,int,int) ; 
 int FUNC99 (struct torus*,int,int,int) ; 
 int FUNC100 (struct torus*,int,int,int) ; 
 int FUNC101 (struct torus*,int,int,int) ; 
 int FUNC102 (struct torus*,int,int,int) ; 
 int FUNC103 (struct torus*,int,int,int) ; 
 int FUNC104 (struct torus*,int,int,int) ; 
 int FUNC105 (struct torus*,int,int,int) ; 
 int FUNC106 (struct torus*,int,int,int) ; 
 int FUNC107 (struct torus*,int,int,int) ; 
 int FUNC108 (struct torus*,int,int,int) ; 
 int FUNC109 (struct torus*,int,int,int) ; 

__attribute__((used)) static
void FUNC110(struct torus *t, int i, int j, int k)
{
	unsigned fp;
	bool success;

	i = FUNC1(i, t->x_sz);
	j = FUNC1(j, t->y_sz);
	k = FUNC1(k, t->z_sz);

	/*
	 * By definition, if a coordinate direction is meshed, we don't
	 * allow it to wrap to zero.
	 */
	if (t->flags & X_MESH) {
		int ip1 = FUNC1(i + 1, t->x_sz);
		if (ip1 < i)
			goto out;
	}
	if (t->flags & Y_MESH) {
		int jp1 = FUNC1(j + 1, t->y_sz);
		if (jp1 < j)
			goto out;
	}
	if (t->flags & Z_MESH) {
		int kp1 = FUNC1(k + 1, t->z_sz);
		if (kp1 < k)
			goto out;
	}
	/*
	 * There are various reasons that the links are not installed between
	 * known torus switches.  These include cases where the search for
	 * new switches only partially succeeds due to missing switches, and
	 * cases where we haven't processed this position yet, but processing
	 * of multiple independent neighbor positions has installed switches
	 * into corners of our case.
	 *
	 * In any event, the topology assumptions made in handling the
	 * fingerprint for this position require that all links be installed
	 * between installed switches for this position.
	 */
again:
	FUNC2(t, i, j, k);
	fp = FUNC3(t, i, j, k);

	switch (fp) {
	/*
	 * When all switches are present, we are done.  Otherwise, one of
	 * the cases below will be unsuccessful, and we'll be done also.
	 *
	 * Note that check_tlinks() above will ensure all links that are
	 * present are connected, in the event that all our switches are
	 * present due to successful case handling in the surrounding
	 * torus/mesh.
	 */
	case 0x300:
	case 0x500:
	case 0x600:
	case 0x700:
		goto out;
	/*
	 * Ignore the 2D cases where there isn't enough information to uniquely
	 * locate/place a switch into the cube.
	 */
	case 0x30f: 	/* 0 corners available */
	case 0x533: 	/* 0 corners available */
	case 0x655: 	/* 0 corners available */
	case 0x30e:	/* 1 corner available */
	case 0x532:	/* 1 corner available */
	case 0x654:	/* 1 corner available */
	case 0x30d:	/* 1 corner available */
	case 0x531:	/* 1 corner available */
	case 0x651:	/* 1 corner available */
	case 0x30b:	/* 1 corner available */
	case 0x523:	/* 1 corner available */
	case 0x645:	/* 1 corner available */
	case 0x307:	/* 1 corner available */
	case 0x513:	/* 1 corner available */
	case 0x615:	/* 1 corner available */
		goto out;
	/*
	 * Handle the 2D cases with a single existing edge.
	 *
	 */
	case 0x30c:
		success = FUNC11(t, i, j, k);
		break;
	case 0x303:
		success = FUNC6(t, i, j, k);
		break;
	case 0x305:
		success = FUNC8(t, i, j, k);
		break;
	case 0x30a:
		success = FUNC10(t, i, j, k);
		break;
	case 0x503:
		success = FUNC14(t, i, j, k);
		break;
	case 0x511:
		success = FUNC16(t, i, j, k);
		break;
	case 0x522:
		success = FUNC18(t, i, j, k);
		break;
	case 0x530:
		success = FUNC19(t, i, j, k);
		break;
	case 0x605:
		success = FUNC22(t, i, j, k);
		break;
	case 0x611:
		success = FUNC24(t, i, j, k);
		break;
	case 0x644:
		success = FUNC26(t, i, j, k);
		break;
	case 0x650:
		success = FUNC27(t, i, j, k);
		break;
	/*
	 * Handle the 2D cases where two existing edges meet at a corner.
	 */
	case 0x301:
		success = FUNC4(t, i, j, k);
		break;
	case 0x302:
		success = FUNC5(t, i, j, k);
		break;
	case 0x304:
		success = FUNC7(t, i, j, k);
		break;
	case 0x308:
		success = FUNC9(t, i, j, k);
		break;
	case 0x501:
		success = FUNC12(t, i, j, k);
		break;
	case 0x502:
		success = FUNC13(t, i, j, k);
		break;
	case 0x520:
		success = FUNC17(t, i, j, k);
		break;
	case 0x510:
		success = FUNC15(t, i, j, k);
		break;
	case 0x601:
		success = FUNC20(t, i, j, k);
		break;
	case 0x604:
		success = FUNC21(t, i, j, k);
		break;
	case 0x610:
		success = FUNC23(t, i, j, k);
		break;
	case 0x640:
		success = FUNC25(t, i, j, k);
		break;
	/*
	 * Ignore the 3D cases where there isn't enough information to uniquely
	 * locate/place a switch into the cube.
	 */
	case 0x7ff:	/* 0 corners available */
	case 0x7fe:	/* 1 corner available */
	case 0x7fd:	/* 1 corner available */
	case 0x7fb:	/* 1 corner available */
	case 0x7f7:	/* 1 corner available */
	case 0x7ef:	/* 1 corner available */
	case 0x7df:	/* 1 corner available */
	case 0x7bf:	/* 1 corner available */
	case 0x77f:	/* 1 corner available */
	case 0x7fc:	/* 2 adj corners available */
	case 0x7fa:	/* 2 adj corners available */
	case 0x7f5:	/* 2 adj corners available */
	case 0x7f3:	/* 2 adj corners available */
	case 0x7cf:	/* 2 adj corners available */
	case 0x7af:	/* 2 adj corners available */
	case 0x75f:	/* 2 adj corners available */
	case 0x73f:	/* 2 adj corners available */
	case 0x7ee:	/* 2 adj corners available */
	case 0x7dd:	/* 2 adj corners available */
	case 0x7bb:	/* 2 adj corners available */
	case 0x777:	/* 2 adj corners available */
		goto out;
	/*
	 * Handle the 3D cases where two existing edges meet at a corner.
	 *
	 */
	case 0x71f:
		success = FUNC46(t, i, j, k);
		break;
	case 0x72f:
		success = FUNC52(t, i, j, k);
		break;
	case 0x737:
		success = FUNC57(t, i, j, k);
		break;
	case 0x73b:
		success = FUNC58(t, i, j, k);
		break;
	case 0x74f:
		success = FUNC64(t, i, j, k);
		break;
	case 0x757:
		success = FUNC69(t, i, j, k);
		break;
	case 0x75d:
		success = FUNC70(t, i, j, k);
		break;
	case 0x773:
		success = FUNC73(t, i, j, k);
		break;
	case 0x775:
		success = FUNC74(t, i, j, k);
		break;
	case 0x78f:
		success = FUNC80(t, i, j, k);
		break;
	case 0x7ab:
		success = FUNC85(t, i, j, k);
		break;
	case 0x7ae:
		success = FUNC86(t, i, j, k);
		break;
	case 0x7b3:
		success = FUNC89(t, i, j, k);
		break;
	case 0x7ba:
		success = FUNC90(t, i, j, k);
		break;
	case 0x7cd:
		success = FUNC95(t, i, j, k);
		break;
	case 0x7ce:
		success = FUNC96(t, i, j, k);
		break;
	case 0x7d5:
		success = FUNC99(t, i, j, k);
		break;
	case 0x7dc:
		success = FUNC100(t, i, j, k);
		break;
	case 0x7ea:
		success = FUNC103(t, i, j, k);
		break;
	case 0x7ec:
		success = FUNC104(t, i, j, k);
		break;
	case 0x7f1:
		success = FUNC106(t, i, j, k);
		break;
	case 0x7f2:
		success = FUNC107(t, i, j, k);
		break;
	case 0x7f4:
		success = FUNC108(t, i, j, k);
		break;
	case 0x7f8:
		success = FUNC109(t, i, j, k);
		break;
	/*
	 * Handle the cases where three existing edges meet at a corner.
	 *
	 */
	case 0x717:
		success = FUNC45(t, i, j, k);
		break;
	case 0x72b:
		success = FUNC51(t, i, j, k);
		break;
	case 0x74d:
		success = FUNC63(t, i, j, k);
		break;
	case 0x771:
		success = FUNC72(t, i, j, k);
		break;
	case 0x78e:
		success = FUNC79(t, i, j, k);
		break;
	case 0x7b2:
		success = FUNC88(t, i, j, k);
		break;
	case 0x7d4:
		success = FUNC98(t, i, j, k);
		break;
	case 0x7e8:
		success = FUNC102(t, i, j, k);
		break;
	/*
	 * Handle the cases where four corners on a single face are missing.
	 */
	case 0x70f:
		success = FUNC40(t, i, j, k);
		break;
	case 0x733:
		success = FUNC56(t, i, j, k);
		break;
	case 0x755:
		success = FUNC68(t, i, j, k);
		break;
	case 0x7aa:
		success = FUNC84(t, i, j, k);
		break;
	case 0x7cc:
		success = FUNC94(t, i, j, k);
		break;
	case 0x7f0:
		success = FUNC105(t, i, j, k);
		break;
	/*
	 * Handle the cases where three corners on a single face are missing.
	 */
	case 0x707:
		success = FUNC33(t, i, j, k);
		break;
	case 0x70b:
		success = FUNC36(t, i, j, k);
		break;
	case 0x70d:
		success = FUNC38(t, i, j, k);
		break;
	case 0x70e:
		success = FUNC39(t, i, j, k);
		break;
	case 0x713:
		success = FUNC43(t, i, j, k);
		break;
	case 0x715:
		success = FUNC44(t, i, j, k);
		break;
	case 0x723:
		success = FUNC49(t, i, j, k);
		break;
	case 0x72a:
		success = FUNC50(t, i, j, k);
		break;
	case 0x731:
		success = FUNC54(t, i, j, k);
		break;
	case 0x732:
		success = FUNC55(t, i, j, k);
		break;
	case 0x745:
		success = FUNC61(t, i, j, k);
		break;
	case 0x74c:
		success = FUNC62(t, i, j, k);
		break;
	case 0x751:
		success = FUNC66(t, i, j, k);
		break;
	case 0x754:
		success = FUNC67(t, i, j, k);
		break;
	case 0x770:
		success = FUNC71(t, i, j, k);
		break;
	case 0x78a:
		success = FUNC77(t, i, j, k);
		break;
	case 0x78c:
		success = FUNC78(t, i, j, k);
		break;
	case 0x7a2:
		success = FUNC82(t, i, j, k);
		break;
	case 0x7a8:
		success = FUNC83(t, i, j, k);
		break;
	case 0x7b0:
		success = FUNC87(t, i, j, k);
		break;
	case 0x7c4:
		success = FUNC92(t, i, j, k);
		break;
	case 0x7c8:
		success = FUNC93(t, i, j, k);
		break;
	case 0x7d0:
		success = FUNC97(t, i, j, k);
		break;
	case 0x7e0:
		success = FUNC101(t, i, j, k);
		break;
	/*
	 * Handle the cases where two corners on a single edge are missing.
	 */
	case 0x703:
		success = FUNC30(t, i, j, k);
		break;
	case 0x705:
		success = FUNC32(t, i, j, k);
		break;
	case 0x70a:
		success = FUNC35(t, i, j, k);
		break;
	case 0x70c:
		success = FUNC37(t, i, j, k);
		break;
	case 0x711:
		success = FUNC42(t, i, j, k);
		break;
	case 0x722:
		success = FUNC48(t, i, j, k);
		break;
	case 0x730:
		success = FUNC53(t, i, j, k);
		break;
	case 0x744:
		success = FUNC60(t, i, j, k);
		break;
	case 0x750:
		success = FUNC65(t, i, j, k);
		break;
	case 0x788:
		success = FUNC76(t, i, j, k);
		break;
	case 0x7a0:
		success = FUNC81(t, i, j, k);
		break;
	case 0x7c0:
		success = FUNC91(t, i, j, k);
		break;
	/*
	 * Handle the cases where a single corner is missing.
	 */
	case 0x701:
		success = FUNC28(t, i, j, k);
		break;
	case 0x702:
		success = FUNC29(t, i, j, k);
		break;
	case 0x704:
		success = FUNC31(t, i, j, k);
		break;
	case 0x708:
		success = FUNC34(t, i, j, k);
		break;
	case 0x710:
		success = FUNC41(t, i, j, k);
		break;
	case 0x720:
		success = FUNC47(t, i, j, k);
		break;
	case 0x740:
		success = FUNC59(t, i, j, k);
		break;
	case 0x780:
		success = FUNC75(t, i, j, k);
		break;

	default:
		/*
		 * There's lots of unhandled cases still, but it's not clear
		 * we care.  Let debugging show us what they are so we can
		 * learn if we care.
		 */
		if (t->debug)
			FUNC0(&t->osm->log, OSM_LOG_ERROR,
				"Unhandled fingerprint 0x%03x @ %d %d %d\n",
				fp, i, j, k);
		goto out;
	}
	/*
	 * If we successfully handled a case, we may be able to make more
	 * progress at this position, so try again.  Otherwise, even though
	 * we didn't successfully handle a case, we may have installed a
	 * switch into the torus/mesh, so try to install links as well.
	 * Then we'll have another go at the next position.
	 */
	if (success) {
		if (t->debug)
			FUNC0(&t->osm->log, OSM_LOG_ERROR,
				"Success on fingerprint 0x%03x @ %d %d %d\n",
				fp, i, j, k);
		goto again;
	} else {
		FUNC2(t, i, j, k);
		if (t->debug)
			FUNC0(&t->osm->log, OSM_LOG_ERROR,
				"Failed on fingerprint 0x%03x @ %d %d %d\n",
				fp, i, j, k);
	}
out:
	return;
}