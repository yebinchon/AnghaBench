#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_14__   TYPE_5__ ;
typedef  struct TYPE_13__   TYPE_1__ ;

/* Type definitions */
typedef  enum pragma_context { ____Placeholder_pragma_context } pragma_context ;
struct TYPE_13__ {int error; } ;
typedef  TYPE_1__ c_parser ;
struct TYPE_14__ {unsigned int pragma_kind; } ;

/* Variables and functions */
 int /*<<< orphan*/  CPP_PRAGMA_EOL ; 
 unsigned int PRAGMA_FIRST_EXTERNAL ; 
#define  PRAGMA_GCC_PCH_PREPROCESS 132 
 unsigned int PRAGMA_NONE ; 
#define  PRAGMA_OMP_BARRIER 131 
#define  PRAGMA_OMP_FLUSH 130 
#define  PRAGMA_OMP_SECTION 129 
#define  PRAGMA_OMP_THREADPRIVATE 128 
 int /*<<< orphan*/  FUNC0 (unsigned int) ; 
 int /*<<< orphan*/  FUNC1 (TYPE_1__*) ; 
 int /*<<< orphan*/  FUNC2 (TYPE_1__*,char*) ; 
 int /*<<< orphan*/  FUNC3 (TYPE_1__*) ; 
 int /*<<< orphan*/  FUNC4 (TYPE_1__*) ; 
 int /*<<< orphan*/  FUNC5 (TYPE_1__*) ; 
 int /*<<< orphan*/  FUNC6 (TYPE_1__*) ; 
 TYPE_5__* FUNC7 (TYPE_1__*) ; 
 int /*<<< orphan*/  FUNC8 (TYPE_1__*) ; 
 int /*<<< orphan*/  FUNC9 (TYPE_1__*,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC10 (char*) ; 
 int /*<<< orphan*/  FUNC11 (int) ; 
 int pragma_compound ; 
 int pragma_external ; 
 int pragma_stmt ; 

__attribute__((used)) static bool
FUNC12 (c_parser *parser, enum pragma_context context)
{
  unsigned int id;

  id = FUNC7 (parser)->pragma_kind;
  FUNC11 (id != PRAGMA_NONE);

  switch (id)
    {
    case PRAGMA_OMP_BARRIER:
      if (context != pragma_compound)
	{
	  if (context == pragma_stmt)
	    FUNC2 (parser, "%<#pragma omp barrier%> may only be "
			    "used in compound statements");
	  goto bad_stmt;
	}
      FUNC3 (parser);
      return false;

    case PRAGMA_OMP_FLUSH:
      if (context != pragma_compound)
	{
	  if (context == pragma_stmt)
	    FUNC2 (parser, "%<#pragma omp flush%> may only be "
			    "used in compound statements");
	  goto bad_stmt;
	}
      FUNC5 (parser);
      return false;

    case PRAGMA_OMP_THREADPRIVATE:
      FUNC6 (parser);
      return false;

    case PRAGMA_OMP_SECTION:
      FUNC10 ("%<#pragma omp section%> may only be used in "
	     "%<#pragma omp sections%> construct");
      FUNC9 (parser, CPP_PRAGMA_EOL, NULL);
      return false;

    case PRAGMA_GCC_PCH_PREPROCESS:
      FUNC2 (parser, "%<#pragma GCC pch_preprocess%> must be first");
      FUNC9 (parser, CPP_PRAGMA_EOL, NULL);
      return false;

    default:
      if (id < PRAGMA_FIRST_EXTERNAL)
	{
	  if (context == pragma_external)
	    {
	    bad_stmt:
	      FUNC2 (parser, "expected declaration specifiers");
	      FUNC9 (parser, CPP_PRAGMA_EOL, NULL);
	      return false;
	    }
	  FUNC4 (parser);
	  return true;
	}
      break;
    }

  FUNC1 (parser);
  FUNC0 (id);

  /* Skip to EOL, but suppress any error message.  Those will have been 
     generated by the handler routine through calling error, as opposed
     to calling c_parser_error.  */
  parser->error = true;
  FUNC8 (parser);

  return false;
}