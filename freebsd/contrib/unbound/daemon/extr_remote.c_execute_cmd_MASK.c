#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_2__ ;
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
struct TYPE_3__ {int /*<<< orphan*/  auth_zones; } ;
struct worker {TYPE_2__* daemon; TYPE_1__ env; } ;
struct daemon_remote {int dummy; } ;
struct TYPE_4__ {int /*<<< orphan*/  local_zones; } ;
typedef  int /*<<< orphan*/  RES ;

/* Variables and functions */
 scalar_t__ FUNC0 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC1 (struct daemon_remote*,int /*<<< orphan*/ *,char*) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC3 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC5 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC6 (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC7 (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC9 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC10 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC11 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC12 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC13 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC14 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC15 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC16 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC17 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC18 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC19 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC20 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC21 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC22 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC23 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC24 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC25 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC26 (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC27 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC28 (int /*<<< orphan*/ *,struct worker*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC29 (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC30 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC31 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC32 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC33 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC34 (int /*<<< orphan*/ *,struct daemon_remote*) ; 
 int /*<<< orphan*/  FUNC35 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC36 (int /*<<< orphan*/ *,struct daemon_remote*,int) ; 
 int /*<<< orphan*/  FUNC37 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC38 (int /*<<< orphan*/ *,struct daemon_remote*) ; 
 int /*<<< orphan*/  FUNC39 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC40 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC41 (int /*<<< orphan*/ *,char*) ; 
 int /*<<< orphan*/  FUNC42 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC43 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC44 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC45 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC46 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC47 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC48 (int /*<<< orphan*/ *,struct worker*,char*) ; 
 int /*<<< orphan*/  FUNC49 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC50 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC51 (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC52 (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC53 (int /*<<< orphan*/ *,struct worker*) ; 
 scalar_t__ FUNC54 (int /*<<< orphan*/ *,struct worker*) ; 
 int /*<<< orphan*/  FUNC55 (int /*<<< orphan*/ *) ; 
 char* FUNC56 (char*) ; 
 int /*<<< orphan*/  FUNC57 (int /*<<< orphan*/ *,char*,char*) ; 

__attribute__((used)) static void
FUNC58(struct daemon_remote* rc, RES* ssl, char* cmd, 
	struct worker* worker)
{
	char* p = FUNC56(cmd);
	/* compare command */
	if(FUNC0(p, "stop", 4)) {
		FUNC38(ssl, rc);
		return;
	} else if(FUNC0(p, "reload", 6)) {
		FUNC34(ssl, rc);
		return;
	} else if(FUNC0(p, "stats_noreset", 13)) {
		FUNC36(ssl, rc, 0);
		return;
	} else if(FUNC0(p, "stats", 5)) {
		FUNC36(ssl, rc, 1);
		return;
	} else if(FUNC0(p, "status", 6)) {
		FUNC37(ssl, worker);
		return;
	} else if(FUNC0(p, "dump_cache", 10)) {
		(void)FUNC53(ssl, worker);
		return;
	} else if(FUNC0(p, "load_cache", 10)) {
		if(FUNC54(ssl, worker)) FUNC55(ssl);
		return;
	} else if(FUNC0(p, "list_forwards", 13)) {
		FUNC27(ssl, worker);
		return;
	} else if(FUNC0(p, "list_stubs", 10)) {
		FUNC30(ssl, worker);
		return;
	} else if(FUNC0(p, "list_insecure", 13)) {
		FUNC23(ssl, worker);
		return;
	} else if(FUNC0(p, "list_local_zones", 16)) {
		FUNC29(ssl, worker->daemon->local_zones);
		return;
	} else if(FUNC0(p, "list_local_data", 15)) {
		FUNC28(ssl, worker, worker->daemon->local_zones);
		return;
	} else if(FUNC0(p, "view_list_local_zones", 21)) {
		FUNC46(ssl, worker, FUNC56(p+21));
		return;
	} else if(FUNC0(p, "view_list_local_data", 20)) {
		FUNC45(ssl, worker, FUNC56(p+20));
		return;
	} else if(FUNC0(p, "ratelimit_list", 14)) {
		FUNC33(ssl, worker, p+14);
		return;
	} else if(FUNC0(p, "ip_ratelimit_list", 17)) {
		FUNC25(ssl, worker, p+17);
		return;
	} else if(FUNC0(p, "list_auth_zones", 15)) {
		FUNC26(ssl, worker->env.auth_zones);
		return;
	} else if(FUNC0(p, "auth_zone_reload", 16)) {
		FUNC2(ssl, worker, FUNC56(p+16));
		return;
	} else if(FUNC0(p, "auth_zone_transfer", 18)) {
		FUNC3(ssl, worker, FUNC56(p+18));
		return;
	} else if(FUNC0(p, "stub_add", 8)) {
		/* must always distribute this cmd */
		if(rc) FUNC1(rc, ssl, cmd);
		FUNC39(ssl, worker, FUNC56(p+8));
		return;
	} else if(FUNC0(p, "stub_remove", 11)) {
		/* must always distribute this cmd */
		if(rc) FUNC1(rc, ssl, cmd);
		FUNC40(ssl, worker, FUNC56(p+11));
		return;
	} else if(FUNC0(p, "forward_add", 11)) {
		/* must always distribute this cmd */
		if(rc) FUNC1(rc, ssl, cmd);
		FUNC19(ssl, worker, FUNC56(p+11));
		return;
	} else if(FUNC0(p, "forward_remove", 14)) {
		/* must always distribute this cmd */
		if(rc) FUNC1(rc, ssl, cmd);
		FUNC20(ssl, worker, FUNC56(p+14));
		return;
	} else if(FUNC0(p, "insecure_add", 12)) {
		/* must always distribute this cmd */
		if(rc) FUNC1(rc, ssl, cmd);
		FUNC22(ssl, worker, FUNC56(p+12));
		return;
	} else if(FUNC0(p, "insecure_remove", 15)) {
		/* must always distribute this cmd */
		if(rc) FUNC1(rc, ssl, cmd);
		FUNC24(ssl, worker, FUNC56(p+15));
		return;
	} else if(FUNC0(p, "forward", 7)) {
		/* must always distribute this cmd */
		if(rc) FUNC1(rc, ssl, cmd);
		FUNC18(ssl, worker, FUNC56(p+7));
		return;
	} else if(FUNC0(p, "flush_stats", 11)) {
		/* must always distribute this cmd */
		if(rc) FUNC1(rc, ssl, cmd);
		FUNC15(ssl, worker);
		return;
	} else if(FUNC0(p, "flush_requestlist", 17)) {
		/* must always distribute this cmd */
		if(rc) FUNC1(rc, ssl, cmd);
		FUNC14(ssl, worker);
		return;
	} else if(FUNC0(p, "lookup", 6)) {
		FUNC32(ssl, worker, FUNC56(p+6));
		return;
	}

#ifdef THREADS_DISABLED
	/* other processes must execute the command as well */
	/* commands that should not be distributed, returned above. */
	if(rc) { /* only if this thread is the master (rc) thread */
		/* done before the code below, which may split the string */
		distribute_cmd(rc, ssl, cmd);
	}
#endif
	if(FUNC0(p, "verbosity", 9)) {
		FUNC41(ssl, FUNC56(p+9));
	} else if(FUNC0(p, "local_zone_remove", 17)) {
		FUNC50(ssl, worker->daemon->local_zones, FUNC56(p+17));
	} else if(FUNC0(p, "local_zones_remove", 18)) {
		FUNC52(ssl, worker->daemon->local_zones);
	} else if(FUNC0(p, "local_zone", 10)) {
		FUNC49(ssl, worker->daemon->local_zones, FUNC56(p+10));
	} else if(FUNC0(p, "local_zones", 11)) {
		FUNC51(ssl, worker->daemon->local_zones);
	} else if(FUNC0(p, "local_data_remove", 17)) {
		FUNC5(ssl, worker->daemon->local_zones, FUNC56(p+17));
	} else if(FUNC0(p, "local_datas_remove", 18)) {
		FUNC7(ssl, worker->daemon->local_zones);
	} else if(FUNC0(p, "local_data", 10)) {
		FUNC4(ssl, worker->daemon->local_zones, FUNC56(p+10));
	} else if(FUNC0(p, "local_datas", 11)) {
		FUNC6(ssl, worker->daemon->local_zones);
	} else if(FUNC0(p, "view_local_zone_remove", 22)) {
		FUNC48(ssl, worker, FUNC56(p+22));
	} else if(FUNC0(p, "view_local_zone", 15)) {
		FUNC47(ssl, worker, FUNC56(p+15));
	} else if(FUNC0(p, "view_local_data_remove", 22)) {
		FUNC43(ssl, worker, FUNC56(p+22));
	} else if(FUNC0(p, "view_local_data", 15)) {
		FUNC42(ssl, worker, FUNC56(p+15));
	} else if(FUNC0(p, "view_local_datas", 16)) {
		FUNC44(ssl, worker, FUNC56(p+16));
	} else if(FUNC0(p, "flush_zone", 10)) {
		FUNC17(ssl, worker, FUNC56(p+10));
	} else if(FUNC0(p, "flush_type", 10)) {
		FUNC16(ssl, worker, FUNC56(p+10));
	} else if(FUNC0(p, "flush_infra", 11)) {
		FUNC11(ssl, worker, FUNC56(p+11));
	} else if(FUNC0(p, "flush", 5)) {
		FUNC12(ssl, worker, FUNC56(p+5));
	} else if(FUNC0(p, "dump_requestlist", 16)) {
		FUNC9(ssl, worker);
	} else if(FUNC0(p, "dump_infra", 10)) {
		FUNC8(ssl, worker);
	} else if(FUNC0(p, "log_reopen", 10)) {
		FUNC31(ssl, worker);
	} else if(FUNC0(p, "set_option", 10)) {
		FUNC35(ssl, worker, FUNC56(p+10));
	} else if(FUNC0(p, "get_option", 10)) {
		FUNC21(ssl, worker, FUNC56(p+10));
	} else if(FUNC0(p, "flush_bogus", 11)) {
		FUNC10(ssl, worker);
	} else if(FUNC0(p, "flush_negative", 14)) {
		FUNC13(ssl, worker);
	} else {
		(void)FUNC57(ssl, "error unknown command '%s'\n", p);
	}
}