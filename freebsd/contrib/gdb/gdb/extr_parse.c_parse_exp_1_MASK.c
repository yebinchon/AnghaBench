#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct expression {int nelts; TYPE_1__* language_defn; } ;
struct cleanup {int dummy; } ;
struct block {int dummy; } ;
struct TYPE_2__ {int /*<<< orphan*/  (* la_error ) (int /*<<< orphan*/ *) ;scalar_t__ (* la_parser ) () ;} ;

/* Variables and functions */
 int /*<<< orphan*/  FUNC0 (struct block*) ; 
 scalar_t__ FUNC1 (int) ; 
 scalar_t__ FUNC2 (scalar_t__) ; 
 int comma_terminates ; 
 TYPE_1__* current_language ; 
 int /*<<< orphan*/  FUNC3 (struct cleanup*) ; 
 int /*<<< orphan*/  FUNC4 (struct expression*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC5 (struct expression*,int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC6 (char*) ; 
 struct expression* expout ; 
 int expout_ptr ; 
 int expout_size ; 
 struct block* expression_context_block ; 
 int /*<<< orphan*/  expression_context_pc ; 
 scalar_t__ expressiondebug ; 
 int /*<<< orphan*/  free_current_contents ; 
 int /*<<< orphan*/  free_funcalls ; 
 scalar_t__ funcall_chain ; 
 int /*<<< orphan*/  gdb_stdlog ; 
 struct block* FUNC7 (int /*<<< orphan*/ *) ; 
 scalar_t__* lexptr ; 
 struct cleanup* FUNC8 (int /*<<< orphan*/ ,struct expression**) ; 
 char* namecopy ; 
 scalar_t__ paren_depth ; 
 int /*<<< orphan*/  FUNC9 (struct expression*) ; 
 int /*<<< orphan*/ * prev_lexptr ; 
 scalar_t__ FUNC10 (scalar_t__*) ; 
 scalar_t__ FUNC11 () ; 
 int /*<<< orphan*/  FUNC12 (int /*<<< orphan*/ *) ; 
 scalar_t__ type_stack_depth ; 
 scalar_t__ FUNC13 (scalar_t__) ; 
 scalar_t__ FUNC14 (char*,scalar_t__) ; 

struct expression *
FUNC15 (char **stringptr, struct block *block, int comma)
{
  struct cleanup *old_chain;

  lexptr = *stringptr;
  prev_lexptr = NULL;

  paren_depth = 0;
  type_stack_depth = 0;

  comma_terminates = comma;

  if (lexptr == 0 || *lexptr == 0)
    FUNC6 ("expression to compute");

  old_chain = FUNC8 (free_funcalls, 0 /*ignore*/);
  funcall_chain = 0;

  if (block)
    {
      expression_context_block = block;
      expression_context_pc = FUNC0 (block);
    }
  else
    expression_context_block = FUNC7 (&expression_context_pc);

  namecopy = (char *) FUNC2 (FUNC10 (lexptr) + 1);
  expout_size = 10;
  expout_ptr = 0;
  expout = (struct expression *)
    FUNC13 (sizeof (struct expression) + FUNC1 (expout_size));
  expout->language_defn = current_language;
  FUNC8 (free_current_contents, &expout);

  if (current_language->la_parser ())
    current_language->la_error (NULL);

  FUNC3 (old_chain);

  /* Record the actual number of expression elements, and then
     reallocate the expression memory so that we free up any
     excess elements. */

  expout->nelts = expout_ptr;
  expout = (struct expression *)
    FUNC14 ((char *) expout,
	      sizeof (struct expression) + FUNC1 (expout_ptr));;

  /* Convert expression from postfix form as generated by yacc
     parser, to a prefix form. */

  if (expressiondebug)
    FUNC5 (expout, gdb_stdlog,
			 "before conversion to prefix form");

  FUNC9 (expout);

  if (expressiondebug)
    FUNC4 (expout, gdb_stdlog);

  *stringptr = lexptr;
  return expout;
}