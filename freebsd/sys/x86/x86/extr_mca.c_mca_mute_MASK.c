#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct mca_record {scalar_t__ mr_bank; int mr_status; } ;

/* Variables and functions */
 int FUNC0 (int /*<<< orphan*/ ) ; 
 int FUNC1 (int /*<<< orphan*/ ) ; 
 scalar_t__ CPU_VENDOR_INTEL ; 
 int /*<<< orphan*/  cpu_id ; 
 scalar_t__ cpu_vendor_id ; 
 int /*<<< orphan*/  intel6h_HSD131 ; 

__attribute__((used)) static int
FUNC2(const struct mca_record *rec)
{

	/*
	 * Skip spurious corrected parity errors generated by Intel Haswell-
	 * and Broadwell-based CPUs (see HSD131, HSM142, HSW131 and BDM48
	 * erratum respectively), unless reporting is enabled.
	 * Note that these errors also have been observed with the D0-stepping
	 * of Haswell, while at least initially the CPU specification updates
	 * suggested only the C0-stepping to be affected.  Similarly, Celeron
	 * 2955U with a CPU ID of 0x45 apparently are also concerned with the
	 * same problem, with HSM142 only referring to 0x3c and 0x46.
	 */
	if (cpu_vendor_id == CPU_VENDOR_INTEL &&
	    FUNC0(cpu_id) == 0x6 &&
	    (FUNC1(cpu_id) == 0x3c ||	/* HSD131, HSM142, HSW131 */
	    FUNC1(cpu_id) == 0x3d ||	/* BDM48 */
	    FUNC1(cpu_id) == 0x45 ||
	    FUNC1(cpu_id) == 0x46) &&	/* HSM142 */
	    rec->mr_bank == 0 &&
	    (rec->mr_status & 0xa0000000ffffffff) == 0x80000000000f0005 &&
	    !intel6h_HSD131)
	    	return (1);

	return (0);
}