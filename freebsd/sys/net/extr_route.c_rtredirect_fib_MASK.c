#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_6__   TYPE_3__ ;
typedef  struct TYPE_5__   TYPE_2__ ;
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  u_int ;
struct sockaddr {int /*<<< orphan*/  sa_family; } ;
struct rtentry {int rt_flags; struct ifaddr* rt_ifa; int /*<<< orphan*/  rt_gateway; } ;
struct rt_addrinfo {int rti_flags; struct sockaddr** rti_info; struct ifaddr* rti_ifa; } ;
struct rib_head {int dummy; } ;
struct ifaddr {TYPE_1__* ifa_addr; } ;
typedef  int /*<<< orphan*/  info ;
typedef  int /*<<< orphan*/  caddr_t ;
struct TYPE_6__ {short rts_dynamic; short rts_newgateway; int /*<<< orphan*/  rts_badredirect; } ;
struct TYPE_5__ {int sa_len; } ;
struct TYPE_4__ {scalar_t__ sa_family; } ;

/* Variables and functions */
 scalar_t__ AF_LINK ; 
 int EAFNOSUPPORT ; 
 int EHOSTUNREACH ; 
 int EINVAL ; 
 int ENETUNREACH ; 
 int /*<<< orphan*/  FUNC0 () ; 
 int /*<<< orphan*/  FUNC1 (struct rib_head*) ; 
 int /*<<< orphan*/  FUNC2 (struct rib_head*) ; 
 size_t RTAX_AUTHOR ; 
 size_t RTAX_DST ; 
 size_t RTAX_GATEWAY ; 
 size_t RTAX_NETMASK ; 
 int /*<<< orphan*/  FUNC3 (struct rtentry*) ; 
 int RTF_DONE ; 
 int RTF_DYNAMIC ; 
 int RTF_GATEWAY ; 
 int RTF_HOST ; 
 int RTF_MODIFIED ; 
 int /*<<< orphan*/  RTM_ADD ; 
 int /*<<< orphan*/  RTM_REDIRECT ; 
 int /*<<< orphan*/  FUNC4 (struct rtentry*) ; 
 int /*<<< orphan*/  FUNC5 (struct rtentry*) ; 
 TYPE_3__ V_rtstat ; 
 int /*<<< orphan*/  FUNC6 (int /*<<< orphan*/ ,int) ; 
 scalar_t__ FUNC7 (struct sockaddr*) ; 
 struct ifaddr* FUNC8 (struct sockaddr*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC9 (struct ifaddr*) ; 
 int /*<<< orphan*/  FUNC10 (struct rtentry*) ; 
 TYPE_2__* FUNC11 (struct rtentry*) ; 
 int /*<<< orphan*/  FUNC12 (int /*<<< orphan*/ ,struct rt_addrinfo*,int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC13 (struct rtentry*,int /*<<< orphan*/ ,struct sockaddr*) ; 
 struct rib_head* FUNC14 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 struct rtentry* FUNC15 (struct sockaddr*,int /*<<< orphan*/ ,unsigned long,int /*<<< orphan*/ ) ; 
 int FUNC16 (int /*<<< orphan*/ ,struct rt_addrinfo*,struct rtentry**,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC17 (struct sockaddr*,int /*<<< orphan*/ ) ; 

void
FUNC18(struct sockaddr *dst,
	struct sockaddr *gateway,
	struct sockaddr *netmask,
	int flags,
	struct sockaddr *src,
	u_int fibnum)
{
	struct rtentry *rt;
	int error = 0;
	short *stat = NULL;
	struct rt_addrinfo info;
	struct ifaddr *ifa;
	struct rib_head *rnh;

	FUNC0();

	ifa = NULL;
	rnh = FUNC14(fibnum, dst->sa_family);
	if (rnh == NULL) {
		error = EAFNOSUPPORT;
		goto out;
	}
	/* verify the gateway is directly reachable */
	if ((ifa = FUNC8(gateway, 0, fibnum)) == NULL) {
		error = ENETUNREACH;
		goto out;
	}
	rt = FUNC15(dst, 0, 0UL, fibnum);	/* NB: rt is locked */
	/*
	 * If the redirect isn't from our current router for this dst,
	 * it's either old or wrong.  If it redirects us to ourselves,
	 * we have a routing loop, perhaps as a result of an interface
	 * going down recently.
	 */
	if (!(flags & RTF_DONE) && rt) {
		if (!FUNC17(src, rt->rt_gateway)) {
			error = EINVAL;
			goto done;
		}
		if (rt->rt_ifa != ifa && ifa->ifa_addr->sa_family != AF_LINK) {
			error = EINVAL;
			goto done;
		}
	}
	if ((flags & RTF_GATEWAY) && FUNC7(gateway)) {
		error = EHOSTUNREACH;
		goto done;
	}
	/*
	 * Create a new entry if we just got back a wildcard entry
	 * or the lookup failed.  This is necessary for hosts
	 * which use routing redirects generated by smart gateways
	 * to dynamically build the routing tables.
	 */
	if (rt == NULL || (FUNC11(rt) && FUNC11(rt)->sa_len < 2))
		goto create;
	/*
	 * Don't listen to the redirect if it's
	 * for a route to an interface.
	 */
	if (rt->rt_flags & RTF_GATEWAY) {
		if (((rt->rt_flags & RTF_HOST) == 0) && (flags & RTF_HOST)) {
			/*
			 * Changing from route to net => route to host.
			 * Create new route, rather than smashing route to net.
			 */
		create:
			if (rt != NULL)
				FUNC3(rt);
		
			flags |= RTF_DYNAMIC;
			FUNC6((caddr_t)&info, sizeof(info));
			info.rti_info[RTAX_DST] = dst;
			info.rti_info[RTAX_GATEWAY] = gateway;
			info.rti_info[RTAX_NETMASK] = netmask;
			FUNC9(ifa);
			info.rti_ifa = ifa;
			info.rti_flags = flags;
			error = FUNC16(RTM_ADD, &info, &rt, fibnum);
			if (rt != NULL) {
				FUNC4(rt);
				flags = rt->rt_flags;
			}
			
			stat = &V_rtstat.rts_dynamic;
		} else {

			/*
			 * Smash the current notion of the gateway to
			 * this destination.  Should check about netmask!!!
			 */
			if ((flags & RTF_GATEWAY) == 0)
				rt->rt_flags &= ~RTF_GATEWAY;
			rt->rt_flags |= RTF_MODIFIED;
			flags |= RTF_MODIFIED;
			stat = &V_rtstat.rts_newgateway;
			/*
			 * add the key and gateway (in one malloc'd chunk).
			 */
			FUNC5(rt);
			FUNC1(rnh);
			FUNC4(rt);
			FUNC13(rt, FUNC10(rt), gateway);
			FUNC2(rnh);
		}
	} else
		error = EHOSTUNREACH;
done:
	if (rt)
		FUNC3(rt);
 out:
	if (error)
		V_rtstat.rts_badredirect++;
	else if (stat != NULL)
		(*stat)++;
	FUNC6((caddr_t)&info, sizeof(info));
	info.rti_info[RTAX_DST] = dst;
	info.rti_info[RTAX_GATEWAY] = gateway;
	info.rti_info[RTAX_NETMASK] = netmask;
	info.rti_info[RTAX_AUTHOR] = src;
	FUNC12(RTM_REDIRECT, &info, flags, error, fibnum);
}