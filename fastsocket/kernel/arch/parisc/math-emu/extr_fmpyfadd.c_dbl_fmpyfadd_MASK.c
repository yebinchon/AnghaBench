#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  dbl_floating_point ;
typedef  scalar_t__ boolean ;

/* Variables and functions */
 int DBLEXT_THRESHOLD ; 
 int DBL_BIAS ; 
 int DBL_INFINITY_EXPONENT ; 
 int DBL_P ; 
 scalar_t__ FUNC0 (unsigned int) ; 
 scalar_t__ FUNC1 (unsigned int) ; 
 scalar_t__ FUNC2 (unsigned int) ; 
 scalar_t__ FUNC3 (unsigned int) ; 
 int /*<<< orphan*/  FUNC4 (unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC5 (unsigned int) ; 
 int /*<<< orphan*/  FUNC6 (unsigned int) ; 
 int /*<<< orphan*/  FUNC7 (unsigned int) ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ *,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC9 (unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC10 (unsigned int,unsigned int,int /*<<< orphan*/ *) ; 
 int FUNC11 (unsigned int) ; 
 int FUNC12 (unsigned int) ; 
 int /*<<< orphan*/  FUNC13 (unsigned int,unsigned int) ; 
 scalar_t__ FUNC14 (unsigned int) ; 
 scalar_t__ FUNC15 (unsigned int,unsigned int) ; 
 scalar_t__ FUNC16 (unsigned int) ; 
 scalar_t__ FUNC17 (unsigned int,unsigned int) ; 
 scalar_t__ FUNC18 (unsigned int) ; 
 scalar_t__ FUNC19 (unsigned int) ; 
 scalar_t__ FUNC20 (unsigned int) ; 
 int /*<<< orphan*/  FUNC21 (unsigned int) ; 
 scalar_t__ FUNC22 (unsigned int) ; 
 scalar_t__ FUNC23 (unsigned int) ; 
 scalar_t__ FUNC24 (unsigned int,unsigned int) ; 
 scalar_t__ FUNC25 (unsigned int) ; 
 scalar_t__ FUNC26 (unsigned int) ; 
 scalar_t__ FUNC27 (unsigned int) ; 
 scalar_t__ FUNC28 (unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC29 (unsigned int) ; 
 int /*<<< orphan*/  FUNC30 (unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC31 (unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC32 (unsigned int,unsigned int,int) ; 
 int /*<<< orphan*/  FUNC33 (unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC34 (unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC35 (unsigned int,int) ; 
 int /*<<< orphan*/  FUNC36 (unsigned int) ; 
 int /*<<< orphan*/  FUNC37 (unsigned int,int) ; 
 int /*<<< orphan*/  FUNC38 (unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC39 (unsigned int) ; 
 int /*<<< orphan*/  FUNC40 (unsigned int) ; 
 int /*<<< orphan*/  FUNC41 (unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC42 (unsigned int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC43 (unsigned int) ; 
 int FUNC44 (unsigned int) ; 
 int FUNC45 (unsigned int) ; 
 int /*<<< orphan*/  FUNC46 (unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC47 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC48 (unsigned int) ; 
 int /*<<< orphan*/  FUNC49 (unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC50 (unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC51 (unsigned int,unsigned int,unsigned int,unsigned int,int,scalar_t__) ; 
 scalar_t__ FUNC52 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC53 (unsigned int) ; 
 scalar_t__ FUNC54 (unsigned int) ; 
 scalar_t__ FUNC55 (unsigned int) ; 
 int /*<<< orphan*/  FUNC56 (unsigned int) ; 
 int /*<<< orphan*/  FUNC57 (unsigned int) ; 
 scalar_t__ FUNC58 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC59 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC60 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC61 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC62 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC63 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC64 (unsigned int,unsigned int,unsigned int,unsigned int,int) ; 
 int /*<<< orphan*/  FUNC65 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC66 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC67 (unsigned int,int) ; 
 int /*<<< orphan*/  FUNC68 (unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC69 (unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC70 (unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC71 (unsigned int,unsigned int,unsigned int) ; 
 int /*<<< orphan*/  FUNC72 (unsigned int,unsigned int,unsigned int) ; 
 scalar_t__ FALSE ; 
 int /*<<< orphan*/  FUNC73 (unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC74 (unsigned int) ; 
 scalar_t__ FUNC75 () ; 
 scalar_t__ FUNC76 () ; 
 scalar_t__ FUNC77 () ; 
 scalar_t__ FUNC78 (int) ; 
 scalar_t__ FUNC79 () ; 
 int NOEXCEPTION ; 
 int OPC_2E_INEXACTEXCEPTION ; 
 int OPC_2E_INVALIDEXCEPTION ; 
 int OPC_2E_OVERFLOWEXCEPTION ; 
 int OPC_2E_UNDERFLOWEXCEPTION ; 
#define  ROUNDMINUS 131 
#define  ROUNDNEAREST 130 
#define  ROUNDPLUS 129 
#define  ROUNDZERO 128 
 int FUNC80 () ; 
 int /*<<< orphan*/  FUNC81 () ; 
 int /*<<< orphan*/  FUNC82 () ; 
 int /*<<< orphan*/  FUNC83 () ; 
 int /*<<< orphan*/  FUNC84 () ; 
 scalar_t__ TRUE ; 
 int /*<<< orphan*/  ovfl ; 
 int /*<<< orphan*/  unfl ; 

int
FUNC85(
	    dbl_floating_point *src1ptr,
	    dbl_floating_point *src2ptr,
	    dbl_floating_point *src3ptr,
	    unsigned int *status,
	    dbl_floating_point *dstptr)
{
	unsigned int opnd1p1, opnd1p2, opnd2p1, opnd2p2, opnd3p1, opnd3p2;
	register unsigned int tmpresp1, tmpresp2, tmpresp3, tmpresp4;
	unsigned int rightp1, rightp2, rightp3, rightp4;
	unsigned int resultp1, resultp2 = 0, resultp3 = 0, resultp4 = 0;
	register int mpy_exponent, add_exponent, count;
	boolean inexact = FALSE, is_tiny = FALSE;

	unsigned int signlessleft1, signlessright1, save;
	register int result_exponent, diff_exponent;
	int sign_save, jumpsize;
	
	FUNC8(src1ptr,opnd1p1,opnd1p2);
	FUNC8(src2ptr,opnd2p1,opnd2p2);
	FUNC8(src3ptr,opnd3p1,opnd3p2);

	/* 
	 * set sign bit of result of multiply
	 */
	if (FUNC44(opnd1p1) ^ FUNC44(opnd2p1)) 
		FUNC39(resultp1); 
	else FUNC43(resultp1);

	/*
	 * Generate multiply exponent 
	 */
	mpy_exponent = FUNC11(opnd1p1) + FUNC11(opnd2p1) - DBL_BIAS;

	/*
	 * check first operand for NaN's or infinity
	 */
	if (FUNC16(opnd1p1)) {
		if (FUNC28(opnd1p1,opnd1p2)) {
			if (FUNC17(opnd2p1,opnd2p2) &&
			    FUNC17(opnd3p1,opnd3p2)) {
				if (FUNC24(opnd2p1,opnd2p2)) {
					/* 
					 * invalid since operands are infinity 
					 * and zero 
					 */
					if (FUNC76())
						return(OPC_2E_INVALIDEXCEPTION);
					FUNC82();
					FUNC31(resultp1,resultp2);
					FUNC10(resultp1,resultp2,dstptr);
					return(NOEXCEPTION);
				}
				/*
				 * Check third operand for infinity with a
				 *  sign opposite of the multiply result
				 */
				if (FUNC15(opnd3p1,opnd3p2) &&
				    (FUNC44(resultp1) ^ FUNC44(opnd3p1))) {
					/* 
					 * invalid since attempting a magnitude
					 * subtraction of infinities
					 */
					if (FUNC76())
						return(OPC_2E_INVALIDEXCEPTION);
					FUNC82();
					FUNC31(resultp1,resultp2);
					FUNC10(resultp1,resultp2,dstptr);
					return(NOEXCEPTION);
				}

				/*
			 	 * return infinity
			 	 */
				FUNC38(resultp1,resultp2);
				FUNC10(resultp1,resultp2,dstptr);
				return(NOEXCEPTION);
			}
		}
		else {
			/*
		 	 * is NaN; signaling or quiet?
		 	 */
			if (FUNC22(opnd1p1)) {
				/* trap if INVALIDTRAP enabled */
				if (FUNC76()) 
			    		return(OPC_2E_INVALIDEXCEPTION);
				/* make NaN quiet */
				FUNC82();
				FUNC36(opnd1p1);
			}
			/* 
			 * is second operand a signaling NaN? 
			 */
			else if (FUNC14(opnd2p1)) {
				/* trap if INVALIDTRAP enabled */
				if (FUNC76())
			    		return(OPC_2E_INVALIDEXCEPTION);
				/* make NaN quiet */
				FUNC82();
				FUNC36(opnd2p1);
				FUNC10(opnd2p1,opnd2p2,dstptr);
				return(NOEXCEPTION);
			}
			/* 
			 * is third operand a signaling NaN? 
			 */
			else if (FUNC14(opnd3p1)) {
				/* trap if INVALIDTRAP enabled */
				if (FUNC76())
			    		return(OPC_2E_INVALIDEXCEPTION);
				/* make NaN quiet */
				FUNC82();
				FUNC36(opnd3p1);
				FUNC10(opnd3p1,opnd3p2,dstptr);
				return(NOEXCEPTION);
			}
			/*
		 	 * return quiet NaN
		 	 */
			FUNC10(opnd1p1,opnd1p2,dstptr);
			return(NOEXCEPTION);
		}
	}

	/*
	 * check second operand for NaN's or infinity
	 */
	if (FUNC16(opnd2p1)) {
		if (FUNC28(opnd2p1,opnd2p2)) {
			if (FUNC17(opnd3p1,opnd3p2)) {
				if (FUNC24(opnd1p1,opnd1p2)) {
					/* 
					 * invalid since multiply operands are
					 * zero & infinity
					 */
					if (FUNC76())
						return(OPC_2E_INVALIDEXCEPTION);
					FUNC82();
					FUNC31(opnd2p1,opnd2p2);
					FUNC10(opnd2p1,opnd2p2,dstptr);
					return(NOEXCEPTION);
				}

				/*
				 * Check third operand for infinity with a
				 *  sign opposite of the multiply result
				 */
				if (FUNC15(opnd3p1,opnd3p2) &&
				    (FUNC44(resultp1) ^ FUNC44(opnd3p1))) {
					/* 
					 * invalid since attempting a magnitude
					 * subtraction of infinities
					 */
					if (FUNC76())
				       		return(OPC_2E_INVALIDEXCEPTION);
				       	FUNC82();
				       	FUNC31(resultp1,resultp2);
					FUNC10(resultp1,resultp2,dstptr);
					return(NOEXCEPTION);
				}

				/*
				 * return infinity
				 */
				FUNC38(resultp1,resultp2);
				FUNC10(resultp1,resultp2,dstptr);
				return(NOEXCEPTION);
			}
		}
		else {
			/*
			 * is NaN; signaling or quiet?
			 */
			if (FUNC22(opnd2p1)) {
				/* trap if INVALIDTRAP enabled */
				if (FUNC76())
					return(OPC_2E_INVALIDEXCEPTION);
				/* make NaN quiet */
				FUNC82();
				FUNC36(opnd2p1);
			}
			/* 
			 * is third operand a signaling NaN? 
			 */
			else if (FUNC14(opnd3p1)) {
			       	/* trap if INVALIDTRAP enabled */
			       	if (FUNC76())
				   		return(OPC_2E_INVALIDEXCEPTION);
			       	/* make NaN quiet */
			       	FUNC82();
			       	FUNC36(opnd3p1);
				FUNC10(opnd3p1,opnd3p2,dstptr);
		       		return(NOEXCEPTION);
			}
			/*
			 * return quiet NaN
			 */
			FUNC10(opnd2p1,opnd2p2,dstptr);
			return(NOEXCEPTION);
		}
	}

	/*
	 * check third operand for NaN's or infinity
	 */
	if (FUNC16(opnd3p1)) {
		if (FUNC28(opnd3p1,opnd3p2)) {
			/* return infinity */
			FUNC10(opnd3p1,opnd3p2,dstptr);
			return(NOEXCEPTION);
		} else {
			/*
			 * is NaN; signaling or quiet?
			 */
			if (FUNC22(opnd3p1)) {
				/* trap if INVALIDTRAP enabled */
				if (FUNC76())
					return(OPC_2E_INVALIDEXCEPTION);
				/* make NaN quiet */
				FUNC82();
				FUNC36(opnd3p1);
			}
			/*
			 * return quiet NaN
 			 */
			FUNC10(opnd3p1,opnd3p2,dstptr);
			return(NOEXCEPTION);
		}
    	}

	/*
	 * Generate multiply mantissa
	 */
	if (FUNC18(opnd1p1)) {
		/* set hidden bit */
		FUNC7(opnd1p1);
	}
	else {
		/* check for zero */
		if (FUNC28(opnd1p1,opnd1p2)) {
			/*
			 * Perform the add opnd3 with zero here.
			 */
			if (FUNC24(opnd3p1,opnd3p2)) {
				if (FUNC78(ROUNDMINUS)) {
					FUNC33(opnd3p1,resultp1);
				} else {
					FUNC4(opnd3p1,resultp1);
				}
			}
			/*
			 * Now let's check for trapped underflow case.
			 */
			else if (FUNC23(opnd3p1) &&
			         FUNC79()) {
                    		/* need to normalize results mantissa */
                    		sign_save = FUNC45(opnd3p1);
				result_exponent = 0;
                    		FUNC30(opnd3p1,opnd3p2);
                    		FUNC32(opnd3p1,opnd3p2,result_exponent);
                    		FUNC37(opnd3p1,/*using*/sign_save);
                    		FUNC42(opnd3p1,result_exponent,
							unfl);
                    		FUNC10(opnd3p1,opnd3p2,dstptr);
                    		/* inexact = FALSE */
                    		return(OPC_2E_UNDERFLOWEXCEPTION);
			}
			FUNC10(opnd3p1,opnd3p2,dstptr);
			return(NOEXCEPTION);
		}
		/* is denormalized, adjust exponent */
		FUNC6(opnd1p1);
		FUNC30(opnd1p1,opnd1p2);
		FUNC32(opnd1p1,opnd1p2,mpy_exponent);
	}
	/* opnd2 needs to have hidden bit set with msb in hidden bit */
	if (FUNC18(opnd2p1)) {
		FUNC7(opnd2p1);
	}
	else {
		/* check for zero */
		if (FUNC28(opnd2p1,opnd2p2)) {
			/*
			 * Perform the add opnd3 with zero here.
			 */
			if (FUNC24(opnd3p1,opnd3p2)) {
				if (FUNC78(ROUNDMINUS)) {
					FUNC33(opnd3p1,resultp1);
				} else {
					FUNC4(opnd3p1,resultp1);
				}
			}
			/*
			 * Now let's check for trapped underflow case.
			 */
			else if (FUNC23(opnd3p1) &&
			    FUNC79()) {
                    		/* need to normalize results mantissa */
                    		sign_save = FUNC45(opnd3p1);
				result_exponent = 0;
                    		FUNC30(opnd3p1,opnd3p2);
                    		FUNC32(opnd3p1,opnd3p2,result_exponent);
                    		FUNC37(opnd3p1,/*using*/sign_save);
                    		FUNC42(opnd3p1,result_exponent,
							unfl);
                    		FUNC10(opnd3p1,opnd3p2,dstptr);
                    		/* inexact = FALSE */
				return(OPC_2E_UNDERFLOWEXCEPTION);
			}
			FUNC10(opnd3p1,opnd3p2,dstptr);
			return(NOEXCEPTION);
		}
		/* is denormalized; want to normalize */
		FUNC6(opnd2p1);
		FUNC30(opnd2p1,opnd2p2);
		FUNC32(opnd2p1,opnd2p2,mpy_exponent);
	}

	/* Multiply the first two source mantissas together */

	/* 
	 * The intermediate result will be kept in tmpres,
	 * which needs enough room for 106 bits of mantissa,
	 * so lets call it a Double extended.
	 */
	FUNC68(tmpresp1,tmpresp2,tmpresp3,tmpresp4);

	/* 
	 * Four bits at a time are inspected in each loop, and a 
	 * simple shift and add multiply algorithm is used. 
	 */ 
	for (count = DBL_P-1; count >= 0; count -= 4) {
		FUNC66(tmpresp1,tmpresp2,tmpresp3,tmpresp4);
		if (FUNC0(opnd1p2)) {
	 		/* Fourword_add should be an ADD followed by 3 ADDC's */
			FUNC73(tmpresp1, tmpresp2, tmpresp3, tmpresp4, 
			 opnd2p1<<3 | opnd2p2>>29, opnd2p2<<3, 0, 0);
		}
		if (FUNC1(opnd1p2)) {
			FUNC73(tmpresp1, tmpresp2, tmpresp3, tmpresp4,
			 opnd2p1<<2 | opnd2p2>>30, opnd2p2<<2, 0, 0);
		}
		if (FUNC2(opnd1p2)) {
			FUNC73(tmpresp1, tmpresp2, tmpresp3, tmpresp4,
			 opnd2p1<<1 | opnd2p2>>31, opnd2p2<<1, 0, 0);
		}
		if (FUNC3(opnd1p2)) {
			FUNC73(tmpresp1, tmpresp2, tmpresp3, tmpresp4,
			 opnd2p1, opnd2p2, 0, 0);
		}
		FUNC34(opnd1p1,opnd1p2);
	}
	if (FUNC74(tmpresp1)) {
		/* result mantissa >= 2 (mantissa overflow) */
		mpy_exponent++;
		FUNC65(tmpresp1,tmpresp2,tmpresp3,tmpresp4);
	}

	/*
	 * Restore the sign of the mpy result which was saved in resultp1.
	 * The exponent will continue to be kept in mpy_exponent.
	 */
	FUNC67(tmpresp1,FUNC44(resultp1));

	/* 
	 * No rounding is required, since the result of the multiply
	 * is exact in the extended format.
	 */

	/*
	 * Now we are ready to perform the add portion of the operation.
	 *
	 * The exponents need to be kept as integers for now, since the
	 * multiply result might not fit into the exponent field.  We
	 * can't overflow or underflow because of this yet, since the
	 * add could bring the final result back into range.
	 */
	add_exponent = FUNC11(opnd3p1);

	/*
	 * Check for denormalized or zero add operand.
	 */
	if (add_exponent == 0) {
		/* check for zero */
		if (FUNC28(opnd3p1,opnd3p2)) {
			/* right is zero */
			/* Left can't be zero and must be result.
			 *
			 * The final result is now in tmpres and mpy_exponent,
			 * and needs to be rounded and squeezed back into
			 * double precision format from double extended.
			 */
			result_exponent = mpy_exponent;
			FUNC49(tmpresp1,tmpresp2,tmpresp3,tmpresp4,
				resultp1,resultp2,resultp3,resultp4);
			sign_save = FUNC45(resultp1);/*save sign*/
			goto round;
		}

		/* 
		 * Neither are zeroes.  
		 * Adjust exponent and normalize add operand.
		 */
		sign_save = FUNC45(opnd3p1);	/* save sign */
		FUNC6(opnd3p1);
		FUNC30(opnd3p1,opnd3p2);
		FUNC32(opnd3p1,opnd3p2,add_exponent);
		FUNC37(opnd3p1,sign_save);	/* restore sign */
	} else {
		FUNC5(opnd3p1);
	}
	/*
	 * Copy opnd3 to the double extended variable called right.
	 */
	FUNC9(opnd3p1,opnd3p2,rightp1,rightp2,rightp3,rightp4);

	/*
	 * A zero "save" helps discover equal operands (for later),
	 * and is used in swapping operands (if needed).
	 */
	FUNC72(tmpresp1,rightp1,/*to*/save);

	/*
	 * Compare magnitude of operands.
	 */
	FUNC50(tmpresp1,signlessleft1);
	FUNC50(rightp1,signlessright1);
	if (mpy_exponent < add_exponent || mpy_exponent == add_exponent &&
	    FUNC52(tmpresp2,rightp2,signlessleft1,signlessright1)){
		/*
		 * Set the left operand to the larger one by XOR swap.
		 * First finish the first word "save".
		 */
		FUNC71(save,rightp1,/*to*/rightp1);
		FUNC71(save,tmpresp1,/*to*/tmpresp1);
		FUNC70(tmpresp2,tmpresp3,tmpresp4,
			rightp2,rightp3,rightp4);
		/* also setup exponents used in rest of routine */
		diff_exponent = add_exponent - mpy_exponent;
		result_exponent = add_exponent;
	} else {
		/* also setup exponents used in rest of routine */
		diff_exponent = mpy_exponent - add_exponent;
		result_exponent = mpy_exponent;
	}
	/* Invariant: left is not smaller than right. */

	/*
	 * Special case alignment of operands that would force alignment
	 * beyond the extent of the extension.  A further optimization
	 * could special case this but only reduces the path length for
	 * this infrequent case.
	 */
	if (diff_exponent > DBLEXT_THRESHOLD) {
		diff_exponent = DBLEXT_THRESHOLD;
	}

	/* Align right operand by shifting it to the right */
	FUNC48(rightp1);
	FUNC64(rightp1,rightp2,rightp3,rightp4,
		/*shifted by*/diff_exponent);
	
	/* Treat sum and difference of the operands separately. */
	if ((int)save < 0) {
		/*
		 * Difference of the two operands.  Overflow can occur if the
		 * multiply overflowed.  A borrow can occur out of the hidden
		 * bit and force a post normalization phase.
		 */
		FUNC69(tmpresp1,tmpresp2,tmpresp3,tmpresp4,
			rightp1,rightp2,rightp3,rightp4,
			resultp1,resultp2,resultp3,resultp4);
		sign_save = FUNC45(resultp1);
		if (FUNC25(resultp1)) {
			/* Handle normalization */
		/* A straight foward algorithm would now shift the
		 * result and extension left until the hidden bit
		 * becomes one.  Not all of the extension bits need
		 * participate in the shift.  Only the two most 
		 * significant bits (round and guard) are needed.
		 * If only a single shift is needed then the guard
		 * bit becomes a significant low order bit and the
		 * extension must participate in the rounding.
		 * If more than a single shift is needed, then all
		 * bits to the right of the guard bit are zeros, 
		 * and the guard bit may or may not be zero. */
			FUNC59(resultp1,resultp2,resultp3,
				resultp4);

			/* Need to check for a zero result.  The sign and
			 * exponent fields have already been zeroed.  The more
			 * efficient test of the full object can be used.
			 */
			 if(FUNC58(resultp1,resultp2,resultp3,resultp4)){
				/* Must have been "x-x" or "x+(-x)". */
				if (FUNC78(ROUNDMINUS))
					FUNC40(resultp1);
				FUNC10(resultp1,resultp2,dstptr);
				return(NOEXCEPTION);
			}
			result_exponent--;

			/* Look to see if normalization is finished. */
			if (FUNC19(resultp1)) {
				/* No further normalization is needed */
				goto round;
			}

			/* Discover first one bit to determine shift amount.
			 * Use a modified binary search.  We have already
			 * shifted the result one position right and still
			 * not found a one so the remainder of the extension
			 * must be zero and simplifies rounding. */
			/* Scan bytes */
			while (FUNC27(resultp1)) {
				FUNC63(resultp1,resultp2,resultp3,resultp4);
				result_exponent -= 8;
			}
			/* Now narrow it down to the nibble */
			if (FUNC26(resultp1)) {
				/* The lower nibble contains the
				 * normalizing one */
				FUNC62(resultp1,resultp2,resultp3,resultp4);
				result_exponent -= 4;
			}
			/* Select case where first bit is set (already
			 * normalized) otherwise select the proper shift. */
			jumpsize = FUNC12(resultp1);
			if (jumpsize <= 7) switch(jumpsize) {
			case 1:
				FUNC61(resultp1,resultp2,resultp3,
					resultp4);
				result_exponent -= 3;
				break;
			case 2:
			case 3:
				FUNC60(resultp1,resultp2,resultp3,
					resultp4);
				result_exponent -= 2;
				break;
			case 4:
			case 5:
			case 6:
			case 7:
				FUNC59(resultp1,resultp2,resultp3,
					resultp4);
				result_exponent -= 1;
				break;
			}
		} /* end if (hidden...)... */
	/* Fall through and round */
	} /* end if (save < 0)... */
	else {
		/* Add magnitudes */
		FUNC46(tmpresp1,tmpresp2,tmpresp3,tmpresp4,
			rightp1,rightp2,rightp3,rightp4,
			/*to*/resultp1,resultp2,resultp3,resultp4);
		sign_save = FUNC45(resultp1);
		if (FUNC20(resultp1)) {
	    		/* Prenormalization required. */
	    		FUNC47(resultp1,resultp2,resultp3,
				resultp4);
	    		result_exponent++;
		} /* end if hiddenoverflow... */
	} /* end else ...add magnitudes... */

	/* Round the result.  If the extension and lower two words are
	 * all zeros, then the result is exact.  Otherwise round in the
	 * correct direction.  Underflow is possible. If a postnormalization
	 * is necessary, then the mantissa is all zeros so no shift is needed.
	 */
  round:
	if (result_exponent <= 0 && !FUNC79()) {
		FUNC51(resultp1,resultp2,resultp3,resultp4,
			result_exponent,is_tiny);
	}
	FUNC37(resultp1,/*using*/sign_save);
	if (FUNC54(resultp3) || 
	    FUNC55(resultp4)) {
		inexact = TRUE;
		switch(FUNC80()) {
		case ROUNDNEAREST: /* The default. */
			if (FUNC56(resultp3)) {
				/* at least 1/2 ulp */
				if (FUNC53(resultp3) ||
				    FUNC55(resultp4) ||
				    FUNC57(resultp2)) {
					/* either exactly half way and odd or
					 * more than 1/2ulp */
					FUNC13(resultp1,resultp2);
				}
			}
	    		break;

		case ROUNDPLUS:
	    		if (FUNC29(resultp1)) {
				/* Round up positive results */
				FUNC13(resultp1,resultp2);
			}
			break;
	    
		case ROUNDMINUS:
	    		if (FUNC21(resultp1)) {
				/* Round down negative results */
				FUNC13(resultp1,resultp2);
			}
	    
		case ROUNDZERO:;
			/* truncate is simple */
		} /* end switch... */
		if (FUNC20(resultp1)) result_exponent++;
	}
	if (result_exponent >= DBL_INFINITY_EXPONENT) {
                /* trap if OVERFLOWTRAP enabled */
                if (FUNC77()) {
                        /*
                         * Adjust bias of result
                         */
                        FUNC42(resultp1,result_exponent,ovfl);
                        FUNC10(resultp1,resultp2,dstptr);
                        if (inexact)
                            if (FUNC75())
                                return (OPC_2E_OVERFLOWEXCEPTION |
					OPC_2E_INEXACTEXCEPTION);
                            else FUNC81();
                        return (OPC_2E_OVERFLOWEXCEPTION);
                }
                inexact = TRUE;
                FUNC83();
                /* set result to infinity or largest number */
                FUNC41(resultp1,resultp2);

	} else if (result_exponent <= 0) {	/* underflow case */
		if (FUNC79()) {
                        /*
                         * Adjust bias of result
                         */
                	FUNC42(resultp1,result_exponent,unfl);
			FUNC10(resultp1,resultp2,dstptr);
                        if (inexact)
                            if (FUNC75())
                                return (OPC_2E_UNDERFLOWEXCEPTION |
					OPC_2E_INEXACTEXCEPTION);
                            else FUNC81();
	    		return(OPC_2E_UNDERFLOWEXCEPTION);
		}
		else if (inexact && is_tiny) FUNC84();
	}
	else FUNC35(resultp1,result_exponent);
	FUNC10(resultp1,resultp2,dstptr);
	if (inexact) 
		if (FUNC75()) return(OPC_2E_INEXACTEXCEPTION);
		else FUNC81();
    	return(NOEXCEPTION);
}