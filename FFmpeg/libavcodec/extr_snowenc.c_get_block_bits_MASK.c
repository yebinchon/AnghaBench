#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_10__   TYPE_2__ ;
typedef  struct TYPE_9__   TYPE_1__ ;

/* Type definitions */
struct TYPE_10__ {int type; int* color; int ref; scalar_t__ my; scalar_t__ mx; } ;
struct TYPE_9__ {int b_width; int block_max_depth; int b_height; TYPE_2__ const* block; } ;
typedef  TYPE_1__ SnowContext ;
typedef  TYPE_2__ const BlockNode ;

/* Variables and functions */
 int BLOCK_INTRA ; 
 int FUNC0 (int) ; 
 int FUNC1 (int) ; 
 TYPE_2__ const null_block ; 
 int /*<<< orphan*/  FUNC2 (TYPE_1__*,int*,int*,int,TYPE_2__ const*,TYPE_2__ const*,TYPE_2__ const*) ; 

__attribute__((used)) static inline int FUNC3(SnowContext *s, int x, int y, int w){
    const int b_stride = s->b_width << s->block_max_depth;
    const int b_height = s->b_height<< s->block_max_depth;
    int index= x + y*b_stride;
    const BlockNode *b     = &s->block[index];
    const BlockNode *left  = x ? &s->block[index-1] : &null_block;
    const BlockNode *top   = y ? &s->block[index-b_stride] : &null_block;
    const BlockNode *tl    = y && x ? &s->block[index-b_stride-1] : left;
    const BlockNode *tr    = y && x+w<b_stride ? &s->block[index-b_stride+w] : tl;
    int dmx, dmy;
//  int mx_context= av_log2(2*FFABS(left->mx - top->mx));
//  int my_context= av_log2(2*FFABS(left->my - top->my));

    if(x<0 || x>=b_stride || y>=b_height)
        return 0;
/*
1            0      0
01X          1-2    1
001XX        3-6    2-3
0001XXX      7-14   4-7
00001XXXX   15-30   8-15
*/
//FIXME try accurate rate
//FIXME intra and inter predictors if surrounding blocks are not the same type
    if(b->type & BLOCK_INTRA){
        return 3+2*( FUNC1(2*FUNC0(left->color[0] - b->color[0]))
                   + FUNC1(2*FUNC0(left->color[1] - b->color[1]))
                   + FUNC1(2*FUNC0(left->color[2] - b->color[2])));
    }else{
        FUNC2(s, &dmx, &dmy, b->ref, left, top, tr);
        dmx-= b->mx;
        dmy-= b->my;
        return 2*(1 + FUNC1(2*FUNC0(dmx)) //FIXME kill the 2* can be merged in lambda
                    + FUNC1(2*FUNC0(dmy))
                    + FUNC1(2*b->ref));
    }
}