#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_21__   TYPE_4__ ;
typedef  struct TYPE_20__   TYPE_3__ ;
typedef  struct TYPE_19__   TYPE_2__ ;
typedef  struct TYPE_18__   TYPE_1__ ;

/* Type definitions */
struct TYPE_18__ {int /*<<< orphan*/  zfs_name; int /*<<< orphan*/ * zfs_hdl; } ;
typedef  TYPE_1__ zfs_handle_t ;
struct TYPE_19__ {scalar_t__ verbosity; scalar_t__ backup; scalar_t__ holds; scalar_t__ props; scalar_t__ dedup; scalar_t__ progress; int /*<<< orphan*/  parsable; scalar_t__ dryrun; int /*<<< orphan*/  doall; int /*<<< orphan*/  replicate; int /*<<< orphan*/  raw; } ;
typedef  TYPE_2__ sendflags_t ;
typedef  int /*<<< orphan*/  pthread_t ;
struct TYPE_20__ {int pa_fd; scalar_t__ pa_verbosity; int /*<<< orphan*/  pa_estimate; int /*<<< orphan*/  pa_parsable; TYPE_1__* pa_zhp; int /*<<< orphan*/  member_0; } ;
typedef  TYPE_3__ progress_arg_t ;
typedef  int /*<<< orphan*/  libzfs_handle_t ;
typedef  int /*<<< orphan*/  errbuf ;
struct TYPE_21__ {int /*<<< orphan*/  member_0; } ;
typedef  TYPE_4__ dedup_arg_t ;

/* Variables and functions */
 int /*<<< orphan*/  B_FALSE ; 
 int /*<<< orphan*/  B_TRUE ; 
#define  EACCES 143 
#define  EBUSY 142 
#define  EDQUOT 141 
#define  EFAULT 140 
#define  EFBIG 139 
#define  EIO 138 
#define  ENOENT 137 
#define  ENOLINK 136 
#define  ENOSPC 135 
#define  ENOSTR 134 
#define  ENXIO 133 
#define  EPIPE 132 
#define  ERANGE 131 
#define  EROFS 130 
#define  ESRCH 129 
#define  EXDEV 128 
 int /*<<< orphan*/  EZFS_BADBACKUP ; 
 int /*<<< orphan*/  EZFS_BUSY ; 
 int /*<<< orphan*/  EZFS_CROSSTARGET ; 
 int /*<<< orphan*/  EZFS_CRYPTOFAILED ; 
 int /*<<< orphan*/  EZFS_NOENT ; 
 int /*<<< orphan*/  EZFS_THREADCREATEFAILED ; 
 void* PTHREAD_CANCELED ; 
 int /*<<< orphan*/  TEXT_DOMAIN ; 
 int /*<<< orphan*/  ZFS_TYPE_DATASET ; 
 int /*<<< orphan*/  FUNC0 (int) ; 
 char* FUNC1 (int /*<<< orphan*/ ,char*) ; 
 int errno ; 
 int FUNC2 (TYPE_1__*,char const*,int,TYPE_2__*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,char const*,char*) ; 
 int FUNC3 (TYPE_1__*,TYPE_4__*,int,int /*<<< orphan*/ *,int*) ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC5 (TYPE_2__*) ; 
 int FUNC6 (int /*<<< orphan*/ ,char const*,int,int /*<<< orphan*/ ,char const*) ; 
 int /*<<< orphan*/  FUNC7 (int /*<<< orphan*/ ) ; 
 int FUNC8 (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,TYPE_3__*) ; 
 int /*<<< orphan*/  FUNC9 (int /*<<< orphan*/ ,void**) ; 
 int FUNC10 (int,int /*<<< orphan*/ *) ; 
 int FUNC11 (TYPE_1__*,int /*<<< orphan*/ *,int,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ ,scalar_t__,scalar_t__,scalar_t__,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  send_progress_thread ; 
 int /*<<< orphan*/  FUNC12 (TYPE_1__*,TYPE_1__*) ; 
 int /*<<< orphan*/  FUNC13 (char*,int,char*,...) ; 
 scalar_t__ FUNC14 (char const*,char) ; 
 char* FUNC15 (int) ; 
 int /*<<< orphan*/  FUNC16 (TYPE_1__*) ; 
 int FUNC17 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC18 (int /*<<< orphan*/ *,char*,...) ; 
 TYPE_1__* FUNC19 (int /*<<< orphan*/ *,char const*,int /*<<< orphan*/ ) ; 
 int FUNC20 (int /*<<< orphan*/ *,int,char*) ; 

int
FUNC21(zfs_handle_t *zhp, const char *from, int fd, sendflags_t *flags,
    const char *redactbook)
{
	int err;
	libzfs_handle_t *hdl = zhp->zfs_hdl;
	int orig_fd = fd;
	pthread_t ddtid, ptid;
	progress_arg_t pa = { 0 };
	dedup_arg_t dda = { 0 };

	char errbuf[1024];
	(void) FUNC13(errbuf, sizeof (errbuf), FUNC1(TEXT_DOMAIN,
	    "warning: cannot send '%s'"), zhp->zfs_name);

	if (from != NULL && FUNC14(from, '@')) {
		zfs_handle_t *from_zhp = FUNC19(hdl, from,
		    ZFS_TYPE_DATASET);
		if (from_zhp == NULL)
			return (-1);
		if (!FUNC12(from_zhp, zhp)) {
			FUNC16(from_zhp);
			FUNC18(hdl, FUNC1(TEXT_DOMAIN,
			    "not an earlier snapshot from the same fs"));
			return (FUNC17(hdl, EZFS_CROSSTARGET, errbuf));
		}
		FUNC16(from_zhp);
	}

	/*
	 * Send fs properties
	 */
	if (flags->props || flags->holds || flags->backup) {
		/*
		 * Note: the header generated by send_prelim_records()
		 * assumes that the incremental source is in the same
		 * filesystem/volume as the target (which is a requirement
		 * when doing "zfs send -R").  But that isn't always the
		 * case here (e.g. send from snap in origin, or send from
		 * bookmark).  We pass from=NULL, which will omit this
		 * information from the prelim records; it isn't used
		 * when receiving this type of stream.
		 */
		err = FUNC11(zhp, NULL, fd, B_TRUE, B_FALSE,
		    flags->verbosity > 0, flags->dryrun, flags->raw,
		    flags->replicate, flags->backup, flags->holds,
		    flags->props, flags->doall, NULL, NULL);
		if (err != 0)
			return (err);
	}

	/*
	 * Perform size estimate if verbose was specified.
	 */
	if (flags->verbosity != 0) {
		err = FUNC2(zhp, from, fd, flags, 0, 0, 0, redactbook,
		    errbuf);
		if (err != 0)
			return (err);
	}

	if (flags->dryrun)
		return (0);

	/*
	 * If deduplication is requested, spawn a thread that will deduplicate
	 * the data coming out of the kernel.
	 */
	if (flags->dedup) {
		err = FUNC3(zhp, &dda, fd, &ddtid, &fd);
		if (err != 0)
			return (err);
	}

	/*
	 * If progress reporting is requested, spawn a new thread to poll
	 * ZFS_IOC_SEND_PROGRESS at a regular interval.
	 */
	if (flags->progress) {
		pa.pa_zhp = zhp;
		pa.pa_fd = fd;
		pa.pa_parsable = flags->parsable;
		pa.pa_estimate = B_FALSE;
		pa.pa_verbosity = flags->verbosity;

		err = FUNC8(&ptid, NULL,
		    send_progress_thread, &pa);
		if (err != 0) {
			FUNC18(zhp->zfs_hdl, FUNC15(errno));
			if (flags->dedup) {
				(void) FUNC7(ddtid);
				(void) FUNC0(fd);
				(void) FUNC9(ddtid, NULL);
			}
			return (FUNC17(zhp->zfs_hdl,
			    EZFS_THREADCREATEFAILED, errbuf));
		}
	}

	err = FUNC6(zhp->zfs_name, from, fd,
	    FUNC5(flags), redactbook);

	if (flags->progress) {
		void *status = NULL;
		if (err != 0)
			(void) FUNC7(ptid);
		(void) FUNC9(ptid, &status);
		int error = (int)(uintptr_t)status;
		if (error != 0 && status != PTHREAD_CANCELED) {
			char errbuf[1024];
			(void) FUNC13(errbuf, sizeof (errbuf),
			    FUNC1(TEXT_DOMAIN, "progress thread exited "
			    "nonzero"));
			return (FUNC20(hdl, error, errbuf));
		}
	}
	if (flags->dedup) {
		if (err != 0)
			(void) FUNC7(ddtid);
		(void) FUNC0(fd);
		(void) FUNC9(ddtid, NULL);
	}

	if (flags->props || flags->holds || flags->backup) {
		/* Write the final end record. */
		err = FUNC10(orig_fd, NULL);
		if (err != 0)
			return (FUNC20(hdl, err, errbuf));
	}
	if (err != 0) {
		switch (errno) {
		case EXDEV:
			FUNC18(hdl, FUNC1(TEXT_DOMAIN,
			    "not an earlier snapshot from the same fs"));
			return (FUNC17(hdl, EZFS_CROSSTARGET, errbuf));

		case ENOENT:
		case ESRCH:
			if (FUNC4(zhp->zfs_name)) {
				FUNC18(hdl, FUNC1(TEXT_DOMAIN,
				    "incremental source (%s) does not exist"),
				    from);
			}
			return (FUNC17(hdl, EZFS_NOENT, errbuf));

		case EACCES:
			FUNC18(hdl, FUNC1(TEXT_DOMAIN,
			    "dataset key must be loaded"));
			return (FUNC17(hdl, EZFS_CRYPTOFAILED, errbuf));

		case EBUSY:
			FUNC18(hdl, FUNC1(TEXT_DOMAIN,
			    "target is busy; if a filesystem, "
			    "it must not be mounted"));
			return (FUNC17(hdl, EZFS_BUSY, errbuf));

		case EDQUOT:
		case EFBIG:
		case EIO:
		case ENOLINK:
		case ENOSPC:
		case ENOSTR:
		case ENXIO:
		case EPIPE:
		case ERANGE:
		case EFAULT:
		case EROFS:
			FUNC18(hdl, FUNC15(errno));
			return (FUNC17(hdl, EZFS_BADBACKUP, errbuf));

		default:
			return (FUNC20(hdl, errno, errbuf));
		}
	}
	return (err != 0);
}