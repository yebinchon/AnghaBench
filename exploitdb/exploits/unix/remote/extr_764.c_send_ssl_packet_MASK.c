#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
struct TYPE_3__ {int* write_key; int /*<<< orphan*/  write_seq; int /*<<< orphan*/  sock; int /*<<< orphan*/  rc4_write_key; scalar_t__ encrypted; } ;
typedef  TYPE_1__ ssl_conn ;
typedef  int /*<<< orphan*/  MD5_CTX ;

/* Variables and functions */
 int BUFSIZE ; 
 int MD5_DIGEST_LENGTH ; 
 int /*<<< orphan*/  FUNC0 (unsigned char*,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ *,...) ; 
 int /*<<< orphan*/  FUNC3 (int /*<<< orphan*/ ,int,unsigned char*,unsigned char*) ; 
 int RC4_KEY_LENGTH ; 
 int /*<<< orphan*/  FUNC4 (int) ; 
 int /*<<< orphan*/  FUNC5 (unsigned char*,unsigned char*,int) ; 
 int FUNC6 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC7 (char*,int) ; 
 int /*<<< orphan*/  FUNC8 (int,unsigned char*) ; 
 int /*<<< orphan*/  FUNC9 (int /*<<< orphan*/ ,unsigned char*,int,int /*<<< orphan*/ ) ; 

void FUNC10(ssl_conn* ssl, unsigned char* rec, int rec_len)
{
	unsigned char buf[BUFSIZE];
	unsigned char* p;
	int tot_len;
	MD5_CTX ctx;
	int seq;


	if (ssl->encrypted)
		tot_len = rec_len + MD5_DIGEST_LENGTH;	/* RC4 needs no padding */
	else
		tot_len = rec_len;

	if (2 + tot_len > BUFSIZE) {
		FUNC7("send_ssl_packet: Record length out of range (rec_len = %d)\n", rec_len);
		FUNC4(1);
	}

	p = buf;
	FUNC8(tot_len, p);

	buf[0] = buf[0] | 0x80;	/* two byte header */

	if (ssl->encrypted) {
		/* calculate the MAC */
		seq = FUNC6(ssl->write_seq);

		FUNC1(&ctx);
		FUNC2(&ctx, ssl->write_key, RC4_KEY_LENGTH);
		FUNC2(&ctx, rec, rec_len);
		FUNC2(&ctx, &seq, 4);
		FUNC0(p, &ctx);

		p+=MD5_DIGEST_LENGTH;

		FUNC5(p, rec, rec_len);

		/* encrypt the payload */
		FUNC3(ssl->rc4_write_key, tot_len, &buf[2], &buf[2]);

	}
	else {
		FUNC5(p, rec, rec_len);
	}

	FUNC9(ssl->sock, buf, 2 + tot_len, 0);

	/* the sequence number is incremented by both encrypted and plaintext packets
*/
	ssl->write_seq++;
}