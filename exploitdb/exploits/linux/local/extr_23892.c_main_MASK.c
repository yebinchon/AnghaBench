#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct timeval {int tv_usec; scalar_t__ tv_sec; } ;
typedef  int /*<<< orphan*/  fd_set ;

/* Variables and functions */
 scalar_t__ ESRCH ; 
 scalar_t__ FUNC0 (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC1 (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  PTRACE_SYSCALL ; 
 int /*<<< orphan*/  PTRACE_TRACEME ; 
 int /*<<< orphan*/  FUNC3 (int) ; 
 int /*<<< orphan*/  FUNC4 (int) ; 
 scalar_t__ errno ; 
 int /*<<< orphan*/  FUNC5 (char*,char**) ; 
 int /*<<< orphan*/  FUNC6 (int) ; 
 int FUNC7 () ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ ,char*) ; 
 int FUNC9 (int*) ; 
 int /*<<< orphan*/  FUNC10 (char*) ; 
 int /*<<< orphan*/  FUNC11 (int /*<<< orphan*/ ,int,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 int FUNC12 (int,char*,int) ; 
 scalar_t__ FUNC13 (int,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,struct timeval*) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  FUNC14 (int,char*,int) ; 

int FUNC15(int argc, char *argv[])
{
        int pid;
        int input[2];
        int output[2];
        int error[2];
        int ret;
        fd_set readfds;

        if (argc < 2) {
                FUNC10("usage: ./systrace_exp <target> <arg1> <arg2> ... <argn>\n");
                FUNC6(0);
        }

        ret = FUNC9(input);
        if (ret) {
                FUNC10("Unable to create pipe\n");
                FUNC6(1);
        }
        ret = FUNC9(output);
        if (ret) {
                FUNC10("Unable to create pipe\n");
                FUNC6(1);
        }
        ret = FUNC9(error);
        if (ret) {
                FUNC10("Unable to create pipe\n");
                FUNC6(1);
        }

        pid = FUNC7();

        if (pid > 0) {
                char somechar;
                int highest;
                struct timeval time;

                time.tv_sec = 0;
                time.tv_usec = 1000;

                FUNC3(input[0]);
                FUNC3(output[1]);
                FUNC3(error[1]);

                FUNC2(&readfds);
                FUNC1(0, &readfds);
                FUNC1(output[0], &readfds);
                FUNC1(error[0], &readfds);
                while (1) {
                        FUNC1(0, &readfds);
                        FUNC1(output[0], &readfds);
                        FUNC1(error[0], &readfds);
                        time.tv_sec = 0;
                        time.tv_usec = 1000;
                        while ((FUNC13(error[0] + 1, &readfds, NULL, NULL, &time)) > 0) {
                                if (FUNC0(0, &readfds)) {
                                        if (FUNC12(0, &somechar, 1) != 1)
                                                FUNC6(0);
                                        FUNC14(input[1], &somechar, 1);
                                }
                                if (FUNC0(output[0], &readfds)) {
                                        if (FUNC12(output[0], &somechar, 1) != 1)
                                                FUNC6(0);
                                        FUNC14(1, &somechar, 1);
                                }
                                if (FUNC0(error[0], &readfds)) {
                                        if (FUNC12(error[0], &somechar, 1) != 1)
                                                FUNC6(0);
                                        FUNC14(2, &somechar, 1);
                                }
                                FUNC1(0, &readfds);
                                FUNC1(output[0], &readfds);
                                FUNC1(error[0], &readfds);
                                time.tv_sec = 0;
                                time.tv_usec = 1000;
                        }

                        FUNC11(PTRACE_SYSCALL, pid, NULL, NULL);
                        if (errno == ESRCH)
                                break;
                }
        } else if (pid == 0) {
                FUNC3(input[1]);
                FUNC3(output[0]);
                FUNC3(error[0]);
                FUNC3(0);
                FUNC4(input[0]);
                FUNC3(1);
                FUNC4(output[1]);
                FUNC3(2);
                FUNC4(error[1]);
                FUNC11(PTRACE_TRACEME, 0, NULL, NULL);
                if (argc == 2)
                        FUNC5(argv[1], NULL);
                else
                        FUNC5(argv[1], argv + 1);
        } else {
                FUNC8(stderr, "Unable to fork.\n");
                FUNC6(1);
        }

        return 0;
}