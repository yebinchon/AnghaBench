#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_2__   TYPE_1__ ;

/* Type definitions */
struct TYPE_2__ {char* name; char* origin; struct TYPE_2__* next; } ;
typedef  TYPE_1__ stub ;
typedef  int /*<<< orphan*/  line ;
typedef  int /*<<< orphan*/  FILE ;

/* Variables and functions */
 int /*<<< orphan*/  FUNC0 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC1 (char*,int,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * FUNC2 (char*,char*) ; 
 int /*<<< orphan*/  FUNC3 (int /*<<< orphan*/ *,char*,...) ; 
 scalar_t__ FUNC4 (char) ; 
 scalar_t__ FUNC5 (int) ; 
 int /*<<< orphan*/  FUNC6 (char*,char*,int) ; 
 int /*<<< orphan*/  FUNC7 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/ * FUNC8 (char*,char*) ; 
 int /*<<< orphan*/  FUNC9 (char*,int,char*,char*,...) ; 
 int /*<<< orphan*/  stderr ; 
 char* FUNC10 (char*,char) ; 
 int /*<<< orphan*/  FUNC11 (char*,char*) ; 
 void* FUNC12 (char*) ; 
 char* FUNC13 (char*,char) ; 
 char* FUNC14 (char*,char*) ; 
 int /*<<< orphan*/  FUNC15 (char*) ; 

int FUNC16( int argc, char **argv ) {
    char line[1024];
    char *make = "make";
    char *nm = "nm";
    char *origin = "unknown.a";
    stub *functions = NULL, *new_f, *imports = NULL, *search;
    FILE *make_f, *nm_f;
    int i, libstart = argc;
    FILE *out = FUNC2("tests/stubs.tst","w");

    if( argc == 1 ) {
        if( out ) FUNC0( out );
        FUNC15(argv[0]);
        return 1;
    }

    if( !out ) {
        FUNC3( &stderr, "Could not write file tests/stubs.tst\n" );
        return 1;
    }

    FUNC3( out, "# Automatically generated by stubgen\n" );

    for( i = 1; i < argc; i++ ) {
        if( !FUNC11( argv[i], "-m" ) ) {
            make = argv[i+1];
            i++;
        } else if( !FUNC11( argv[i], "-n" ) ) {
            nm = argv[i+1];
            i++;
        } else { libstart = i; break; }
    }

    FUNC9( line, sizeof(line), "%s test 2>&1", make );
    make_f = FUNC8( line, "r" );

    if( !make_f ) {
        FUNC0( out );
        FUNC3( &stderr, "Could not run %s test\n", make );
        return 1;
    }

    while( FUNC1( line, sizeof(line), make_f ) ) {
        char *end_of_location;
        char *begin_q, *end_q;

        if( !FUNC14( line, "undefined reference to" ) ) continue;

        end_of_location = FUNC13( line, ':' );

        if( !end_of_location ) continue;

        begin_q = FUNC10( end_of_location, '`' );
        end_q = FUNC10( end_of_location, '\'' );

        if( !begin_q || !end_q ) continue;

        begin_q += 2; /* skip `_ */

        FUNC6( line, begin_q, end_q - begin_q );
        line[end_q - begin_q] = 0;

        for( new_f = functions; new_f; new_f = new_f->next )
            if( !FUNC11( new_f->name, line ) ) break;

        if( new_f ) continue;

        new_f = (stub *)FUNC5( sizeof(stub) );
        if( !new_f )
        {
            FUNC3( &stderr, "Out of memory\n" );
            FUNC0( out );
            FUNC7( make_f );
            return 1;
        }

        new_f->name = FUNC12( line );
        new_f->next = functions;
        functions = new_f;
    }

    /* Scan libraries and collect available import sections */
    for( i = libstart; i < argc; i++ ) {
        FUNC9( line, sizeof(line), "%s %s", nm, argv[i] );
        nm_f = FUNC8( line, "r" );

        for( origin = argv[i]; *argv[i]; argv[i]++ )
            if( *argv[i] == '/' || *argv[i] == '\\' )
                origin = argv[i] + 1;


        if( !nm_f ) {
            FUNC3( &stderr, "Could not run %s\n", line );
            continue;
        }

        while( FUNC1( line, sizeof(line), nm_f ) ) {
            char *import_sign, *eol;

            if( !(import_sign = FUNC14( line, " I " )) ) continue;

            import_sign += 3;
            while( *import_sign && FUNC4(*import_sign) ) import_sign++;

            /* Strip ws after name */
            for( eol = import_sign; *eol && !FUNC4(*eol); eol++ );

            *eol = 0;

            for( new_f = imports; new_f; new_f = new_f->next )
                if( !FUNC11( new_f->name, import_sign ) ) break;

            if( new_f ) continue;

            new_f = (stub *)FUNC5( sizeof(stub) );
            if( !new_f )
            {
                FUNC3( &stderr, "Out of memory\n" );
                FUNC0( out );
                FUNC7( make_f );
                FUNC7( nm_f );
                return 1;
            }

            new_f->name   = FUNC12( import_sign + 1 );
            new_f->origin = origin;
            new_f->next   = imports;
            imports = new_f;
        }

        FUNC7( nm_f );
    }

    /* Now we have a list of unique functions and a list of imports,
    lookup each function and output the entry from the import list. */
    for( new_f = functions; new_f; new_f = new_f->next ) {
        for( search = imports; search; search = search->next ) {
            if( !FUNC11( new_f->name, search->name ) ) {
                FUNC3( out, "%s %s\n", search->origin, search->name );
                continue;
            }
        }
    }

    FUNC0( out );
    FUNC7( make_f );
    return 0;
}