#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int u8 ;
typedef  int u32 ;
struct tegra_dsi {int video_fifo_depth; int host_fifo_depth; int /*<<< orphan*/  dev; } ;
struct mipi_dsi_packet {int* header; int size; int payload_length; int /*<<< orphan*/  payload; } ;
struct mipi_dsi_msg {int flags; scalar_t__ rx_len; scalar_t__ rx_buf; } ;
struct mipi_dsi_host {int dummy; } ;
typedef  size_t ssize_t ;

/* Variables and functions */
 int /*<<< orphan*/  DSI_CONTROL ; 
 int DSI_CONTROL_HOST_ENABLE ; 
 int FUNC0 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  DSI_HOST_CONTROL ; 
 int DSI_HOST_CONTROL_CRC_RESET ; 
 int DSI_HOST_CONTROL_CS ; 
 int DSI_HOST_CONTROL_ECC ; 
 int DSI_HOST_CONTROL_FIFO_RESET ; 
 int DSI_HOST_CONTROL_FIFO_SEL ; 
 int DSI_HOST_CONTROL_HS ; 
 int DSI_HOST_CONTROL_PKT_BTA ; 
 int DSI_HOST_CONTROL_TX_TRIG_HOST ; 
 int /*<<< orphan*/  DSI_POWER_CONTROL ; 
 int DSI_POWER_CONTROL_ENABLE ; 
 int /*<<< orphan*/  DSI_RD_DATA ; 
 int /*<<< orphan*/  DSI_STATUS ; 
 int DSI_STATUS_OVERFLOW ; 
 int DSI_STATUS_UNDERFLOW ; 
 int /*<<< orphan*/  DSI_WR_DATA ; 
 size_t ENOSPC ; 
 int MIPI_DSI_MSG_REQ_ACK ; 
 int MIPI_DSI_MSG_USE_LPM ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ ,char*,size_t) ; 
 struct tegra_dsi* FUNC2 (struct mipi_dsi_host*) ; 
 size_t FUNC3 (struct mipi_dsi_packet*,struct mipi_dsi_msg const*) ; 
 size_t FUNC4 (struct tegra_dsi*,struct mipi_dsi_msg const*,size_t) ; 
 int FUNC5 (struct tegra_dsi*,int /*<<< orphan*/ ) ; 
 size_t FUNC6 (struct tegra_dsi*,int) ; 
 size_t FUNC7 (struct tegra_dsi*,int) ; 
 int /*<<< orphan*/  FUNC8 (struct tegra_dsi*,int,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC9 (struct tegra_dsi*,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  FUNC10 (int,int) ; 

__attribute__((used)) static ssize_t FUNC11(struct mipi_dsi_host *host,
				       const struct mipi_dsi_msg *msg)
{
	struct tegra_dsi *dsi = FUNC2(host);
	struct mipi_dsi_packet packet;
	const u8 *header;
	size_t count;
	ssize_t err;
	u32 value;

	err = FUNC3(&packet, msg);
	if (err < 0)
		return err;

	header = packet.header;

	/* maximum FIFO depth is 1920 words */
	if (packet.size > dsi->video_fifo_depth * 4)
		return -ENOSPC;

	/* reset underflow/overflow flags */
	value = FUNC5(dsi, DSI_STATUS);
	if (value & (DSI_STATUS_UNDERFLOW | DSI_STATUS_OVERFLOW)) {
		value = DSI_HOST_CONTROL_FIFO_RESET;
		FUNC8(dsi, value, DSI_HOST_CONTROL);
		FUNC10(10, 20);
	}

	value = FUNC5(dsi, DSI_POWER_CONTROL);
	value |= DSI_POWER_CONTROL_ENABLE;
	FUNC8(dsi, value, DSI_POWER_CONTROL);

	FUNC10(5000, 10000);

	value = DSI_HOST_CONTROL_CRC_RESET | DSI_HOST_CONTROL_TX_TRIG_HOST |
		DSI_HOST_CONTROL_CS | DSI_HOST_CONTROL_ECC;

	if ((msg->flags & MIPI_DSI_MSG_USE_LPM) == 0)
		value |= DSI_HOST_CONTROL_HS;

	/*
	 * The host FIFO has a maximum of 64 words, so larger transmissions
	 * need to use the video FIFO.
	 */
	if (packet.size > dsi->host_fifo_depth * 4)
		value |= DSI_HOST_CONTROL_FIFO_SEL;

	FUNC8(dsi, value, DSI_HOST_CONTROL);

	/*
	 * For reads and messages with explicitly requested ACK, generate a
	 * BTA sequence after the transmission of the packet.
	 */
	if ((msg->flags & MIPI_DSI_MSG_REQ_ACK) ||
	    (msg->rx_buf && msg->rx_len > 0)) {
		value = FUNC5(dsi, DSI_HOST_CONTROL);
		value |= DSI_HOST_CONTROL_PKT_BTA;
		FUNC8(dsi, value, DSI_HOST_CONTROL);
	}

	value = FUNC0(0) | DSI_CONTROL_HOST_ENABLE;
	FUNC8(dsi, value, DSI_CONTROL);

	/* write packet header, ECC is generated by hardware */
	value = header[2] << 16 | header[1] << 8 | header[0];
	FUNC8(dsi, value, DSI_WR_DATA);

	/* write payload (if any) */
	if (packet.payload_length > 0)
		FUNC9(dsi, DSI_WR_DATA, packet.payload,
				  packet.payload_length);

	err = FUNC6(dsi, 250);
	if (err < 0)
		return err;

	if ((msg->flags & MIPI_DSI_MSG_REQ_ACK) ||
	    (msg->rx_buf && msg->rx_len > 0)) {
		err = FUNC7(dsi, 250);
		if (err < 0)
			return err;

		count = err;

		value = FUNC5(dsi, DSI_RD_DATA);
		switch (value) {
		case 0x84:
			/*
			dev_dbg(dsi->dev, "ACK\n");
			*/
			break;

		case 0x87:
			/*
			dev_dbg(dsi->dev, "ESCAPE\n");
			*/
			break;

		default:
			FUNC1(dsi->dev, "unknown status: %08x\n", value);
			break;
		}

		if (count > 1) {
			err = FUNC4(dsi, msg, count);
			if (err < 0)
				FUNC1(dsi->dev,
					"failed to parse response: %zd\n",
					err);
			else {
				/*
				 * For read commands, return the number of
				 * bytes returned by the peripheral.
				 */
				count = err;
			}
		}
	} else {
		/*
		 * For write commands, we have transmitted the 4-byte header
		 * plus the variable-length payload.
		 */
		count = 4 + packet.payload_length;
	}

	return count;
}