#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */
typedef  struct TYPE_3__   TYPE_1__ ;

/* Type definitions */
typedef  int /*<<< orphan*/  uint64_t ;
typedef  char WCHAR ;
struct TYPE_3__ {int /*<<< orphan*/ * pwszName; } ;
typedef  TYPE_1__ VDS_VOLUME_PROP ;
typedef  int /*<<< orphan*/  USHORT ;
typedef  int ULONG ;
typedef  int /*<<< orphan*/  LPWSTR ;
typedef  char* LPCSTR ;
typedef  int /*<<< orphan*/  IVdsVolumeMF3 ;
typedef  int /*<<< orphan*/  IVdsVolume ;
typedef  int /*<<< orphan*/  IVdsSwProvider ;
typedef  int /*<<< orphan*/  IVdsServiceLoader ;
typedef  int /*<<< orphan*/  IVdsService ;
typedef  int /*<<< orphan*/  IVdsProvider ;
typedef  int /*<<< orphan*/  IVdsPack ;
typedef  int /*<<< orphan*/  IVdsAsync ;
typedef  int /*<<< orphan*/  IUnknown ;
typedef  int /*<<< orphan*/  IEnumVdsObject ;
typedef  scalar_t__ HRESULT ;
typedef  int DWORD ;
typedef  int BOOL ;

/* Variables and functions */
 int /*<<< orphan*/  CHECK_FOR_USER_CANCEL ; 
 int CLSCTX_LOCAL_SERVER ; 
 int CLSCTX_REMOTE_SERVER ; 
 int /*<<< orphan*/  CLSID_VdsLoader ; 
 int /*<<< orphan*/  COINIT_APARTMENTTHREADED ; 
 scalar_t__ FUNC0 (int /*<<< orphan*/ *,int /*<<< orphan*/ *,int,int /*<<< orphan*/ *,void**) ; 
 int /*<<< orphan*/  FUNC1 (int /*<<< orphan*/ *,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC2 (int /*<<< orphan*/ *,int,int /*<<< orphan*/ *,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ ,int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC3 (int /*<<< orphan*/ *) ; 
 int ERROR_GEN_FAILURE ; 
 int ERROR_PATH_NOT_FOUND ; 
 int ERROR_SEVERITY_ERROR ; 
 scalar_t__ E_FAIL ; 
 int FUNC4 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FACILITY_STORAGE ; 
 int FALSE ; 
 int FP_COMPRESSION ; 
 int FP_QUICK ; 
 size_t FS_EXFAT ; 
 size_t FS_UDF ; 
 int /*<<< orphan*/ * FileSystemLabel ; 
 int FormatStatus ; 
 char* FUNC5 (int,int /*<<< orphan*/ ,int,int) ; 
 scalar_t__ FUNC6 (int /*<<< orphan*/ *,int,int /*<<< orphan*/ **,int*) ; 
 int /*<<< orphan*/  FUNC7 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  IID_IVdsPack ; 
 int /*<<< orphan*/  IID_IVdsProvider ; 
 int /*<<< orphan*/  IID_IVdsServiceLoader ; 
 int /*<<< orphan*/  IID_IVdsSwProvider ; 
 int /*<<< orphan*/  IID_IVdsVolume ; 
 int /*<<< orphan*/  IID_IVdsVolumeMF3 ; 
 scalar_t__ FUNC8 (int) ; 
 scalar_t__ FUNC9 (int /*<<< orphan*/ *,int /*<<< orphan*/ *,void**) ; 
 int /*<<< orphan*/  FUNC10 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  FUNC11 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC12 (int /*<<< orphan*/ *,scalar_t__*,int*) ; 
 int /*<<< orphan*/  FUNC13 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC14 (int /*<<< orphan*/ *,int /*<<< orphan*/ **) ; 
 int /*<<< orphan*/  FUNC15 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC16 (int /*<<< orphan*/ *,char*,int /*<<< orphan*/ **) ; 
 int /*<<< orphan*/  FUNC17 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC18 (int /*<<< orphan*/ *,int /*<<< orphan*/ ,int /*<<< orphan*/ **) ; 
 scalar_t__ FUNC19 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC20 (int /*<<< orphan*/ *,int /*<<< orphan*/ *,void**) ; 
 scalar_t__ FUNC21 (int /*<<< orphan*/ *,int /*<<< orphan*/ **) ; 
 int /*<<< orphan*/  FUNC22 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC23 (int /*<<< orphan*/ *,char*,int /*<<< orphan*/ ,int,char*,int,int /*<<< orphan*/ **) ; 
 scalar_t__ FUNC24 (int /*<<< orphan*/ *,int /*<<< orphan*/ **,int*) ; 
 int /*<<< orphan*/  FUNC25 (int /*<<< orphan*/ *) ; 
 scalar_t__ FUNC26 (int /*<<< orphan*/ *,TYPE_1__*) ; 
 scalar_t__ FUNC27 (int /*<<< orphan*/ *,int /*<<< orphan*/ *,void**) ; 
 int /*<<< orphan*/  FUNC28 (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  MSG_217 ; 
 int /*<<< orphan*/  MSG_218 ; 
 int /*<<< orphan*/  MSG_220 ; 
 int /*<<< orphan*/  MSG_222 ; 
 int /*<<< orphan*/  OP_CREATE_FS ; 
 int /*<<< orphan*/  OP_FORMAT ; 
 int /*<<< orphan*/  FUNC29 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ; 
 int /*<<< orphan*/  FUNC30 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,char*,...) ; 
 int /*<<< orphan*/  RPC_C_AUTHN_LEVEL_CONNECT ; 
 int /*<<< orphan*/  RPC_C_IMP_LEVEL_IMPERSONATE ; 
 int /*<<< orphan*/  FUNC31 (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  SETTING_USE_UDF_VERSION ; 
 scalar_t__ FUNC32 (scalar_t__) ; 
 scalar_t__ S_OK ; 
 int /*<<< orphan*/  FUNC33 (int) ; 
 int TRUE ; 
 int /*<<< orphan*/  FUNC34 (int /*<<< orphan*/ ,float) ; 
 int /*<<< orphan*/  FUNC35 (int /*<<< orphan*/ ,int /*<<< orphan*/ ,int,int) ; 
 int /*<<< orphan*/  FUNC36 (int /*<<< orphan*/ *,int) ; 
 scalar_t__ VDS_E_OPERATION_PENDING ; 
 int /*<<< orphan*/  VDS_QUERY_SOFTWARE_PROVIDERS ; 
 int /*<<< orphan*/  FUNC37 (scalar_t__) ; 
 scalar_t__ VDS_S_PROPERTIES_INCOMPLETE ; 
 int /*<<< orphan*/  FUNC38 () ; 
 scalar_t__ dur_mins ; 
 scalar_t__ dur_secs ; 
 float format_percent ; 
 int /*<<< orphan*/  FUNC39 (char*) ; 
 scalar_t__ FUNC40 (char*,int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  FUNC41 (char*,...) ; 
 char* FUNC42 (char*) ; 
 scalar_t__ FUNC43 (char*,int /*<<< orphan*/ ) ; 

__attribute__((used)) static BOOL FUNC44(DWORD DriveIndex, uint64_t PartitionOffset, DWORD ClusterSize, LPCSTR FSName, LPCSTR Label, DWORD Flags)
{
	BOOL r = FALSE, bFoundVolume = FALSE;
	HRESULT hr;
	ULONG ulFetched;
	IVdsServiceLoader *pLoader;
	IVdsService *pService;
	IEnumVdsObject *pEnum;
	IUnknown *pUnk;
	char* VolumeName = NULL;
	WCHAR *wVolumeName = NULL, *wLabel = FUNC42(Label), *wFSName = FUNC42(FSName);

	if ((FUNC40(FSName, FileSystemLabel[FS_EXFAT]) == 0) && !((dur_mins == 0) && (dur_secs == 0))) {
		FUNC30(0, MSG_220, FSName, dur_mins, dur_secs);
	} else {
		FUNC30(0, MSG_222, FSName);
	}
	FUNC36(NULL, TRUE);
	VolumeName = FUNC5(DriveIndex, PartitionOffset, TRUE, TRUE);
	wVolumeName = FUNC42(VolumeName);
	if (wVolumeName == NULL) {
		FUNC41("Could not read volume name");
		FormatStatus = ERROR_SEVERITY_ERROR | FUNC4(FACILITY_STORAGE) | ERROR_GEN_FAILURE;
		goto out;
	}

	// Initialize COM
	FUNC7(FUNC1(NULL, COINIT_APARTMENTTHREADED));
	FUNC7(FUNC2(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
		RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 0, NULL));

	// Create a VDS Loader Instance
	hr = FUNC0(&CLSID_VdsLoader, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
		&IID_IVdsServiceLoader, (void **)&pLoader);
	if (hr != S_OK) {
		FUNC37(hr);
		FUNC41("Could not create VDS Loader Instance: %s", FUNC38());
		goto out;
	}

	// Load the VDS Service
	hr = FUNC16(pLoader, L"", &pService);
	FUNC17(pLoader);
	if (hr != S_OK) {
		FUNC37(hr);
		FUNC41("Could not load VDS Service: %s", FUNC38());
		goto out;
	}

	// Wait for the Service to become ready if needed
	hr = FUNC19(pService);
	if (hr != S_OK) {
		FUNC37(hr);
		FUNC41("VDS Service is not ready: %s", FUNC38());
		goto out;
	}

	// Query the VDS Service Providers
	hr = FUNC18(pService, VDS_QUERY_SOFTWARE_PROVIDERS, &pEnum);
	if (hr != S_OK) {
		FUNC37(hr);
		FUNC41("Could not query VDS Service Providers: %s", FUNC38());
		goto out;
	}

	while (FUNC6(pEnum, 1, &pUnk, &ulFetched) == S_OK) {
		IVdsProvider *pProvider;
		IVdsSwProvider *pSwProvider;
		IEnumVdsObject *pEnumPack;
		IUnknown *pPackUnk;
		CHECK_FOR_USER_CANCEL;

		// Get VDS Provider
		hr = FUNC9(pUnk, &IID_IVdsProvider, (void **)&pProvider);
		FUNC10(pUnk);
		if (hr != S_OK) {
			FUNC37(hr);
			FUNC41("Could not get VDS Provider: %s", FUNC38());
			goto out;
		}

		// Get VDS Software Provider
		hr = FUNC20(pProvider, &IID_IVdsSwProvider, (void **)&pSwProvider);
		FUNC15(pProvider);
		if (hr != S_OK) {
			FUNC37(hr);
			FUNC41("Could not get VDS Software Provider: %s", FUNC38());
			goto out;
		}

		// Get VDS Software Provider Packs
		hr = FUNC21(pSwProvider, &pEnumPack);
		FUNC22(pSwProvider);
		if (hr != S_OK) {
			FUNC37(hr);
			FUNC41("Could not get VDS Software Provider Packs: %s", FUNC38());
			goto out;
		}

		// Enumerate Provider Packs
		while (FUNC6(pEnumPack, 1, &pPackUnk, &ulFetched) == S_OK) {
			IVdsPack *pPack;
			IEnumVdsObject *pEnumVolume;
			IUnknown *pVolumeUnk;
			CHECK_FOR_USER_CANCEL;

			hr = FUNC9(pPackUnk, &IID_IVdsPack, (void **)&pPack);
			FUNC10(pPackUnk);
			if (hr != S_OK) {
				FUNC37(hr);
				FUNC41("Could not query VDS Software Provider Pack: %s", FUNC38());
				goto out;
			}

			// Use the pack interface to access the volumes
			hr = FUNC14(pPack, &pEnumVolume);
			if (hr != S_OK) {
				FUNC37(hr);
				FUNC41("Could not query VDS volumes: %s", FUNC38());
				goto out;
			}

			// List volumes
			while (FUNC6(pEnumVolume, 1, &pVolumeUnk, &ulFetched) == S_OK) {
				BOOL match;
				HRESULT hr2 = E_FAIL;
				VDS_VOLUME_PROP VolumeProps;
				LPWSTR *wszPathArray;
				ULONG ulPercentCompleted, ulNumberOfPaths;
				USHORT usFsVersion = 0;
				IVdsVolume *pVolume;
				IVdsAsync* pAsync;
				IVdsVolumeMF3 *pVolumeMF3;
				CHECK_FOR_USER_CANCEL;

				// Get the volume interface.
				hr = FUNC9(pVolumeUnk, &IID_IVdsVolume, (void **)&pVolume);
				if (hr != S_OK) {
					FUNC37(hr);
					FUNC41("Could not query VDS Volume Interface: %s", FUNC38());
					goto out;
				}

				hr = FUNC26(pVolume, &VolumeProps);
				if ((hr != S_OK) && (hr != VDS_S_PROPERTIES_INCOMPLETE)) {
					FUNC37(hr);
					FUNC28(pVolume);
					FUNC41("Could not query VDS Volume Properties: %s", FUNC38());
					continue;
				}
				FUNC3(VolumeProps.pwszName);

				// Instantiate the IVdsVolumeMF3 interface for our volume.
				hr = FUNC27(pVolume, &IID_IVdsVolumeMF3, (void **)&pVolumeMF3);
				FUNC28(pVolume);
				if (hr != S_OK) {
					FUNC37(hr);
					FUNC41("Could not access VDS VolumeMF3 interface: %s", FUNC38());
					continue;
				}

				// Query the volume GUID
				hr = FUNC24(pVolumeMF3, &wszPathArray, &ulNumberOfPaths);
				if (hr != S_OK) {
					FUNC37(hr);
					FUNC41("Could not query VDS VolumeGuidPathnames: %s", FUNC38());
					continue;
				}

				if (ulNumberOfPaths > 1)
					FUNC41("Notice: Volume %S has more than one GUID...", wszPathArray[0]);

				match = (FUNC43(wVolumeName, wszPathArray[0]) == 0);
				FUNC3(wszPathArray);
				if (!match)
					continue;

				bFoundVolume = TRUE;
				if (FUNC40(Label, FileSystemLabel[FS_UDF]) == 0)
					usFsVersion = FUNC31(SETTING_USE_UDF_VERSION);
				if (ClusterSize < 0x200) {
					ClusterSize = 0;
					FUNC41("Using default cluster size");
				} else {
					FUNC41("Using cluster size: %d bytes", ClusterSize);
				}
				format_percent = 0.0f;
				FUNC41("%s format was selected", (Flags & FP_QUICK) ? "Quick" : "Slow");
				if (Flags & FP_COMPRESSION)
					FUNC41("NTFS compression is enabled");

				hr = FUNC23(pVolumeMF3, wFSName, usFsVersion, ClusterSize, wLabel, Flags, &pAsync);
				while (FUNC32(hr)) {
					if (FUNC8(FormatStatus)) {
						FUNC11(pAsync);
						break;
					}
					hr = FUNC12(pAsync, &hr2, &ulPercentCompleted);
					if (FUNC32(hr)) {
						if (Flags & FP_QUICK) {
							// Progress report on quick format is useless, so we'll just pretend we have 2 tasks
							FUNC29(0, MSG_218, (ulPercentCompleted < 100) ? 1 : 2, 2);
							FUNC34(OP_CREATE_FS, (float)ulPercentCompleted);
						} else {
							FUNC35(OP_FORMAT, MSG_217, ulPercentCompleted, 100);
						}
						hr = hr2;
						if (hr == S_OK)
							break;
						if (hr == VDS_E_OPERATION_PENDING)
							hr = S_OK;
					}
					FUNC33(500);
				}
				if (!FUNC32(hr)) {
					FUNC37(hr);
					FUNC41("Could not format drive: %s", FUNC38());
					goto out;
				}

				FUNC13(pAsync);
				FUNC25(pVolumeMF3);

				if (!FUNC8(FormatStatus)) {
					FUNC41("Format completed.");
					r = TRUE;
				}
				goto out;
			}
		}
	}

out:
	if ((!bFoundVolume) && (FormatStatus == 0))
		FormatStatus = ERROR_SEVERITY_ERROR | FUNC4(FACILITY_STORAGE) | ERROR_PATH_NOT_FOUND;
	FUNC39(VolumeName);
	FUNC39(wVolumeName);
	FUNC39(wLabel);
	FUNC39(wFSName);
	return r;
}